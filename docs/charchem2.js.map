{"version":3,"file":"charchem2.js","mappings":"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","sources":["webpack://charchem2/./src/ChemSys.ts","webpack://charchem2/./src/browser/AutoCompileConfig.ts","webpack://charchem2/./src/browser/addClass.ts","webpack://charchem2/./src/browser/autoCompile.ts","webpack://charchem2/./src/browser/documentCompile.ts","webpack://charchem2/./src/browser/renderFormulaCanvas.ts","webpack://charchem2/./src/browser/renderFormulaCfg.ts","webpack://charchem2/./src/browser/renderFormulaSvg.ts","webpack://charchem2/./src/compiler/ChainSys.ts","webpack://charchem2/./src/compiler/ChemCompiler.ts","webpack://charchem2/./src/compiler/compile.ts","webpack://charchem2/./src/compiler/funcs/funcBackground.ts","webpack://charchem2/./src/compiler/funcs/funcC.ts","webpack://charchem2/./src/compiler/funcs/funcColor.ts","webpack://charchem2/./src/compiler/funcs/funcDblAlign.ts","webpack://charchem2/./src/compiler/funcs/funcDots.ts","webpack://charchem2/./src/compiler/funcs/funcL.ts","webpack://charchem2/./src/compiler/funcs/funcM.ts","webpack://charchem2/./src/compiler/funcs/funcPadding.ts","webpack://charchem2/./src/compiler/funcs/funcPos.ts","webpack://charchem2/./src/compiler/funcs/funcSlope.ts","webpack://charchem2/./src/compiler/funcs/funcVer.ts","webpack://charchem2/./src/compiler/funcs/funcnM.ts","webpack://charchem2/./src/compiler/funcs/funcsDict.ts","webpack://charchem2/./src/compiler/main/BracketsCtrl.ts","webpack://charchem2/./src/compiler/main/MulCounter.ts","webpack://charchem2/./src/compiler/main/NodesBranch.ts","webpack://charchem2/./src/compiler/main/StackItem.ts","webpack://charchem2/./src/compiler/main/addNodeItem.ts","webpack://charchem2/./src/compiler/main/agent.ts","webpack://charchem2/./src/compiler/main/agentAnalyse.ts","webpack://charchem2/./src/compiler/main/autoCorrection.ts","webpack://charchem2/./src/compiler/main/bondCommon.ts","webpack://charchem2/./src/compiler/main/bondPolygonal.ts","webpack://charchem2/./src/compiler/main/bondRing.ts","webpack://charchem2/./src/compiler/main/bondSimple.ts","webpack://charchem2/./src/compiler/main/bondSpline.ts","webpack://charchem2/./src/compiler/main/bondUniversal.ts","webpack://charchem2/./src/compiler/main/brackets.ts","webpack://charchem2/./src/compiler/main/branch.ts","webpack://charchem2/./src/compiler/main/chemOp.ts","webpack://charchem2/./src/compiler/main/colors.ts","webpack://charchem2/./src/compiler/main/createLabel.ts","webpack://charchem2/./src/compiler/main/entity.ts","webpack://charchem2/./src/compiler/main/findNode.ts","webpack://charchem2/./src/compiler/main/item.ts","webpack://charchem2/./src/compiler/main/middlePoint.ts","webpack://charchem2/./src/compiler/main/multipier.ts","webpack://charchem2/./src/compiler/main/node.ts","webpack://charchem2/./src/compiler/parse/comment.ts","webpack://charchem2/./src/compiler/parse/isDigit.ts","webpack://charchem2/./src/compiler/parse/isSpace.ts","webpack://charchem2/./src/compiler/parse/parseNum.ts","webpack://charchem2/./src/compiler/parse/parsePadding.ts","webpack://charchem2/./src/compiler/parse/prepareText.ts","webpack://charchem2/./src/compiler/parse/scan.ts","webpack://charchem2/./src/compiler/parse/scanArgs.ts","webpack://charchem2/./src/compiler/parse/scanBondSuffix.ts","webpack://charchem2/./src/compiler/parse/scanCharge.ts","webpack://charchem2/./src/compiler/parse/scanCoeff.ts","webpack://charchem2/./src/compiler/parse/scanId.ts","webpack://charchem2/./src/compiler/parse/scanInt.ts","webpack://charchem2/./src/compiler/parse/scanOp.ts","webpack://charchem2/./src/compiler/parse/scanPostItem.ts","webpack://charchem2/./src/compiler/parse/skipSpaces.ts","webpack://charchem2/./src/compiler/preprocessor/Macros.ts","webpack://charchem2/./src/compiler/preprocessor/PreProcCtx.ts","webpack://charchem2/./src/compiler/preprocessor/bodyPreprocess.ts","webpack://charchem2/./src/compiler/preprocessor/defMacro.ts","webpack://charchem2/./src/compiler/preprocessor/execMacros.ts","webpack://charchem2/./src/compiler/preprocessor/mainPreProcess.ts","webpack://charchem2/./src/compiler/preprocessor/readFormalPars.ts","webpack://charchem2/./src/compiler/preprocessor/scanPar.ts","webpack://charchem2/./src/compiler/sourceMap/getSrcItemsForObject.ts","webpack://charchem2/./src/compiler/sourceMap/index.ts","webpack://charchem2/./src/compiler/state/stateAgent.ts","webpack://charchem2/./src/compiler/state/stateAgentBegin.ts","webpack://charchem2/./src/compiler/state/stateAgentIn.ts","webpack://charchem2/./src/compiler/state/stateAgentMid.ts","webpack://charchem2/./src/compiler/state/stateAgentSpace.ts","webpack://charchem2/./src/compiler/state/stateBegin.ts","webpack://charchem2/./src/compiler/state/stateBracketBegin.ts","webpack://charchem2/./src/compiler/state/stateCharge.ts","webpack://charchem2/./src/compiler/state/stateCommentIn.ts","webpack://charchem2/./src/compiler/state/stateCommentPre.ts","webpack://charchem2/./src/compiler/state/stateCustom.ts","webpack://charchem2/./src/compiler/state/stateElement.ts","webpack://charchem2/./src/compiler/state/stateFuncName.ts","webpack://charchem2/./src/compiler/state/stateNodeRef.ts","webpack://charchem2/./src/compiler/state/stateOpEnd.ts","webpack://charchem2/./src/compiler/state/statePostItem.ts","webpack://charchem2/./src/compiler/state/stateUniBond.ts","webpack://charchem2/./src/core/ChemAgent.ts","webpack://charchem2/./src/core/ChemAtom.ts","webpack://charchem2/./src/core/ChemBackground.ts","webpack://charchem2/./src/core/ChemBond.ts","webpack://charchem2/./src/core/ChemBracket.ts","webpack://charchem2/./src/core/ChemCharge.ts","webpack://charchem2/./src/core/ChemComma.ts","webpack://charchem2/./src/core/ChemComment.ts","webpack://charchem2/./src/core/ChemCustom.ts","webpack://charchem2/./src/core/ChemError.ts","webpack://charchem2/./src/core/ChemExpr.ts","webpack://charchem2/./src/core/ChemK.ts","webpack://charchem2/./src/core/ChemMul.ts","webpack://charchem2/./src/core/ChemNode.ts","webpack://charchem2/./src/core/ChemNodeItem.ts","webpack://charchem2/./src/core/ChemObj.ts","webpack://charchem2/./src/core/ChemOp.ts","webpack://charchem2/./src/core/ChemRadical.ts","webpack://charchem2/./src/core/ChemSubObj.ts","webpack://charchem2/./src/core/ElemList.ts","webpack://charchem2/./src/core/ElemRecord.ts","webpack://charchem2/./src/core/PeriodicTable.ts","webpack://charchem2/./src/core/StructAnalyzer.ts","webpack://charchem2/./src/core/isEmptyNode.ts","webpack://charchem2/./src/core/isNodeHidden.ts","webpack://charchem2/./src/core/isTextBrackets.ts","webpack://charchem2/./src/core/k2s.ts","webpack://charchem2/./src/core/makeChargeText.ts","webpack://charchem2/./src/drawSys/ChemImgProps.ts","webpack://charchem2/./src/drawSys/browser/HtmlCanvasLocalFont.ts","webpack://charchem2/./src/drawSys/browser/HtmlCanvasSurface.ts","webpack://charchem2/./src/drawSys/browser/SvgWebLocalFont.ts","webpack://charchem2/./src/drawSys/browser/SvgWebSurface.ts","webpack://charchem2/./src/drawSys/browser/WebFontCache.ts","webpack://charchem2/./src/drawSys/browser/browserUtils/makeWebFontProps.ts","webpack://charchem2/./src/drawSys/browser/browserUtils/traceBox.ts","webpack://charchem2/./src/drawSys/browser/browserUtils/webFontWeight.ts","webpack://charchem2/./src/drawSys/browser/createBrowserChemImgProps.ts","webpack://charchem2/./src/drawSys/figures/FigBSpline.ts","webpack://charchem2/./src/drawSys/figures/FigEllipse.ts","webpack://charchem2/./src/drawSys/figures/FigFrame.ts","webpack://charchem2/./src/drawSys/figures/FigHashTrapezoid.ts","webpack://charchem2/./src/drawSys/figures/FigPath.ts","webpack://charchem2/./src/drawSys/figures/FigRect.ts","webpack://charchem2/./src/drawSys/figures/FigText.ts","webpack://charchem2/./src/drawSys/figures/Figure.ts","webpack://charchem2/./src/drawSys/figures/drawRect.ts","webpack://charchem2/./src/drawSys/figures/renderTopFrame.ts","webpack://charchem2/./src/drawSys/figures/rubber/braces.ts","webpack://charchem2/./src/drawSys/figures/rubber/closeBracket.ts","webpack://charchem2/./src/drawSys/figures/rubber/drawRubberFigure.ts","webpack://charchem2/./src/drawSys/figures/rubber/getRubberBracket.ts","webpack://charchem2/./src/drawSys/figures/rubber/openBracket.ts","webpack://charchem2/./src/drawSys/figures/rubber/scalePath.ts","webpack://charchem2/./src/drawSys/figures/rubber/squareBrackets.ts","webpack://charchem2/./src/drawSys/svg/SvgSurface.ts","webpack://charchem2/./src/drawSys/svg/standaloneExportOptions.ts","webpack://charchem2/./src/drawSys/svg/svgUtils/buildSvgText.ts","webpack://charchem2/./src/drawSys/utils/createLocalFontHash.ts","webpack://charchem2/./src/drawSys/utils/createRulesList.ts","webpack://charchem2/./src/drawSys/utils/fontFaceProps.ts","webpack://charchem2/./src/drawSys/utils/fontWeightValue.ts","webpack://charchem2/./src/drawSys/utils/pathToString.ts","webpack://charchem2/./src/drawSys/utils/scaleFontFace.ts","webpack://charchem2/./src/drawSys/utils/tracePath.ts","webpack://charchem2/./src/equation/ChemEquation.ts","webpack://charchem2/./src/equation/checkElementsMatching.ts","webpack://charchem2/./src/equation/coeffEnumerators.ts","webpack://charchem2/./src/equation/equationDict.ts","webpack://charchem2/./src/equation/isSuitableForEquation.ts","webpack://charchem2/./src/equation/makeSourceWithNewCoeffs.ts","webpack://charchem2/./src/getVersion.ts","webpack://charchem2/./src/inspectors/calcCharge.ts","webpack://charchem2/./src/inspectors/calcMass.ts","webpack://charchem2/./src/inspectors/isAbstract.ts","webpack://charchem2/./src/inspectors/isTextFormula.ts","webpack://charchem2/./src/inspectors/locateAtomNumber.ts","webpack://charchem2/./src/inspectors/makeBruttoKey.ts","webpack://charchem2/./src/inspectors/makeElemList.ts","webpack://charchem2/./src/inspectors/makeTextFormula.ts","webpack://charchem2/./src/lang/Lang.ts","webpack://charchem2/./src/lang/baseDictEn.ts","webpack://charchem2/./src/lang/baseDictRu.ts","webpack://charchem2/./src/lang/index.ts","webpack://charchem2/./src/lang/replaceLangParams.ts","webpack://charchem2/./src/math/Matrix2x3.ts","webpack://charchem2/./src/math/Point.ts","webpack://charchem2/./src/math/Rational.ts","webpack://charchem2/./src/math/Rect.ts","webpack://charchem2/./src/math/angles.ts","webpack://charchem2/./src/math/index.ts","webpack://charchem2/./src/math/massUtils.ts","webpack://charchem2/./src/math/radians.ts","webpack://charchem2/./src/structBuilder/NodeInfo.ts","webpack://charchem2/./src/structBuilder/applyPadding.ts","webpack://charchem2/./src/structBuilder/bond/clipLine.ts","webpack://charchem2/./src/structBuilder/bond/clipLineByNode.ts","webpack://charchem2/./src/structBuilder/bond/doubleBond.ts","webpack://charchem2/./src/structBuilder/bond/drawBezierBond.ts","webpack://charchem2/./src/structBuilder/bond/drawBond.ts","webpack://charchem2/./src/structBuilder/bond/drawBondAB.ts","webpack://charchem2/./src/structBuilder/bond/drawBondArrow.ts","webpack://charchem2/./src/structBuilder/bond/drawBondPoly.ts","webpack://charchem2/./src/structBuilder/bond/getBondColor.ts","webpack://charchem2/./src/structBuilder/bond/getBondStyleWidth.ts","webpack://charchem2/./src/structBuilder/bond/singleLine.ts","webpack://charchem2/./src/structBuilder/bond/softBondTemplate.ts","webpack://charchem2/./src/structBuilder/bond/tripleBond.ts","webpack://charchem2/./src/structBuilder/bond/wedgeBond.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/AgentCmd.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/AgentCmdBrClose.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/AgentCmdBrOpen.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/AgentCmdBridge.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/AgentCmdMul.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/AgentCmdMulBridge.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/AgentCmdNode.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/AgentCmdSoftBond.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/Clusters.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/PAgentCtx.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/brackets/processBrackets.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/buildAgentPrior.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/createAgentCmd.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/createCoeff.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/drawAllBonds.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/drawBackground.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/drawMul.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/findAgentCenter.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/prepareNodes.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/processCommands.ts","webpack://charchem2/./src/structBuilder/buildAgentPrior/unwind.ts","webpack://charchem2/./src/structBuilder/buildExpression.ts","webpack://charchem2/./src/structBuilder/buildFrame.ts","webpack://charchem2/./src/structBuilder/buildItem.ts","webpack://charchem2/./src/structBuilder/buildNode.ts","webpack://charchem2/./src/structBuilder/buildOp.ts","webpack://charchem2/./src/structBuilder/drawCharge.ts","webpack://charchem2/./src/structBuilder/drawLewisShell.ts","webpack://charchem2/./src/structBuilder/drawText.ts","webpack://charchem2/./src/structBuilder/drawTextNear.ts","webpack://charchem2/./src/structBuilder/drawTextWithMarkup.ts","webpack://charchem2/./src/structBuilder/getTextInternalRect.ts","webpack://charchem2/./src/table/CellRender.ts","webpack://charchem2/./src/table/TableRulesEasyChemistry.ts","webpack://charchem2/./src/table/TableRulesShort.ts","webpack://charchem2/./src/table/TableRulesStd.ts","webpack://charchem2/./src/table/TableRulesWide.ts","webpack://charchem2/./src/table/drawPeriodicTable.ts","webpack://charchem2/./src/table/fallingNumbers.ts","webpack://charchem2/./src/table/findCategory.ts","webpack://charchem2/./src/table/tableCategories.ts","webpack://charchem2/./src/textBuilder/buildTextNodes/addItemProps.ts","webpack://charchem2/./src/textBuilder/buildTextNodes/buildTextNodes.ts","webpack://charchem2/./src/textBuilder/buildTextNodes/cloneTextNode.ts","webpack://charchem2/./src/textBuilder/buildTextNodes/correctBondsDirection.ts","webpack://charchem2/./src/textBuilder/buildTextNodes/createTextOp.ts","webpack://charchem2/./src/textBuilder/buildTextNodes/dictKeys.ts","webpack://charchem2/./src/textBuilder/buildTextNodes/index.ts","webpack://charchem2/./src/textBuilder/buildTextNodes/optimizeColors.ts","webpack://charchem2/./src/textBuilder/buildTextNodes/splitColumn.ts","webpack://charchem2/./src/textBuilder/buildTextNodes/splitRichText.ts","webpack://charchem2/./src/textBuilder/buildTextNodes/splitScripts.ts","webpack://charchem2/./src/textBuilder/htmlRich/HtmlRichClasses.ts","webpack://charchem2/./src/textBuilder/htmlRich/buildHtmlRich.ts","webpack://charchem2/./src/textBuilder/htmlRich/cchOperation.ts","webpack://charchem2/./src/textBuilder/htmlRich/createHtmlRichNodes.ts","webpack://charchem2/./src/textBuilder/htmlRich/makeCchTag.ts","webpack://charchem2/./src/textBuilder/mathml/MathMLOptions.ts","webpack://charchem2/./src/textBuilder/mathml/buildMathML.ts","webpack://charchem2/./src/textBuilder/mathml/createMathMLNode.ts","webpack://charchem2/./src/textBuilder/mathml/utils/mathColumn.ts","webpack://charchem2/./src/textBuilder/mathml/utils/mathItem.ts","webpack://charchem2/./src/textBuilder/mathml/utils/mathOptRow.ts","webpack://charchem2/./src/textBuilder/mathml/utils/mathRichText.ts","webpack://charchem2/./src/textBuilder/mathml/utils/mathScripted.ts","webpack://charchem2/./src/textBuilder/mathml/utils/mathText.ts","webpack://charchem2/./src/textBuilder/mathml/utils/onNodeItem.ts","webpack://charchem2/./src/textBuilder/tex/buildTeX.ts","webpack://charchem2/./src/textBuilder/tex/replaceSpecialTeXSymbols.ts","webpack://charchem2/./src/textBuilder/tex/texColors.ts","webpack://charchem2/./src/textBuilder/textFormula.ts","webpack://charchem2/./src/textBuilder/text/buildTextFormat.ts","webpack://charchem2/./src/textBuilder/xmlNode/addClassToXmlNode.ts","webpack://charchem2/./src/textBuilder/xmlNode/optimizeXmlColors.ts","webpack://charchem2/./src/textBuilder/xmlNode/renderXmlNode.ts","webpack://charchem2/./src/textRules/RulesBase.ts","webpack://charchem2/./src/textRules/dictTextRules.ts","webpack://charchem2/./src/textRules/rulesBB.ts","webpack://charchem2/./src/textRules/rulesCharChem.ts","webpack://charchem2/./src/textRules/rulesHtml.ts","webpack://charchem2/./src/textRules/rulesMhchem.ts","webpack://charchem2/./src/textRules/rulesRTF.ts","webpack://charchem2/./src/textRules/rulesText.ts","webpack://charchem2/./src/types/CoeffPos.ts","webpack://charchem2/./src/utils/addAll.ts","webpack://charchem2/./src/utils/addAllSet.ts","webpack://charchem2/./src/utils/cmp.ts","webpack://charchem2/./src/utils/color/colorHex.ts","webpack://charchem2/./src/utils/color/colorNamesMap.ts","webpack://charchem2/./src/utils/color/colorRgb.ts","webpack://charchem2/./src/utils/color/getRgbSamples.ts","webpack://charchem2/./src/utils/color/parseColorCss.ts","webpack://charchem2/./src/utils/color/traceColor.ts","webpack://charchem2/./src/utils/delay.ts","webpack://charchem2/./src/utils/getItemForced.ts","webpack://charchem2/./src/utils/ifDef.ts","webpack://charchem2/./src/utils/isSubStr.ts","webpack://charchem2/./src/utils/lastItem.ts","webpack://charchem2/./src/utils/listToDict.ts","webpack://charchem2/./src/utils/markup.ts","webpack://charchem2/./src/utils/removeItem.ts","webpack://charchem2/./src/utils/romanNum.ts","webpack://charchem2/./src/utils/xml/drawTag.ts","webpack://charchem2/./src/utils/xml/escapeXml.ts","webpack://charchem2/./src/utils/xml/textInsideTag.ts","webpack://charchem2/./src/version.ts","webpack://charchem2/webpack/bootstrap","webpack://charchem2/./src/index.ts"],"sourcesContent":["import { AutoCompileConfig } from \"./browser/AutoCompileConfig\";\nimport { renderFormulaCfg } from \"./browser/renderFormulaCfg\";\nimport { compile } from \"./compiler/compile\";\nimport { ChemExpr } from \"./core/ChemExpr\";\nimport { ChemObj } from \"./core/ChemObj\";\nimport { getVersion, getVersionStr } from \"./getVersion\";\nimport { makeBruttoKey } from \"./inspectors/makeBruttoKey\";\nimport { isAbstract } from \"./inspectors/isAbstract\";\nimport { Lang, LangParams, LocalDict } from \"./lang\";\nimport { calcMass } from \"./inspectors/calcMass\";\nimport { ChemAtom } from \"./core/ChemAtom\";\nimport { findElement } from \"./core/PeriodicTable\";\nimport { drawPeriodicTable } from \"./table/drawPeriodicTable\";\nimport { documentCompile } from \"./browser/documentCompile\";\nimport { tableRulesStd } from \"./table/TableRulesStd\";\nimport { tableRulesWide } from \"./table/TableRulesWide\";\nimport { tableRulesEasyChemistry } from \"./table/TableRulesEasyChemistry\";\nimport { TableRules } from \"./table/TableRules\";\nimport { tableRulesShort } from \"./table/TableRulesShort\";\nimport {\n  categoryBlock,\n  categoryBlockDLa,\n  categoryProps,\n  TCategories,\n} from \"./table/tableCategories\";\nimport { findCategory } from \"./table/findCategory\";\nimport { ChemAgent } from \"./core/ChemAgent\";\nimport { XmlAttrs } from \"./utils/xml/xmlTypes\";\nimport { drawTag } from \"./utils/xml/drawTag\";\nimport { escapeXml } from \"./utils/xml/escapeXml\";\nimport { calcCharge } from \"./inspectors/calcCharge\";\nimport { roundMass } from \"./math/massUtils\";\nimport { makeFormulaSvgText } from \"./browser/renderFormulaSvg\";\nimport { WebFontCache } from \"./drawSys/browser/WebFontCache\";\nimport { ChemEquation } from \"./equation/ChemEquation\";\nimport { RulesBase } from \"./textRules/RulesBase\";\nimport { makeTextFormula } from \"./inspectors/makeTextFormula\";\nimport { dictTextRules } from \"./textRules/dictTextRules\";\nimport {\n  textFormula,\n  FmtDef,\n  FmtType,\n  textTypes,\n} from \"./textBuilder/textFormula\";\n\nexport const ChemSys = Object.freeze({\n  addDict(globalDict: Record<string, LocalDict>) {\n    Lang.addDict(globalDict);\n  },\n  get ver(): number[] {\n    return getVersion();\n  },\n  get verStr(): string {\n    return getVersionStr();\n  },\n  compile(formula: string): ChemExpr {\n    return compile(formula);\n  },\n  documentCompile(cfg: AutoCompileConfig = {}) {\n    return documentCompile(cfg);\n  },\n  draw(\n    owner: Element,\n    exprOrCode: ChemExpr | ChemAgent | string,\n    config?: AutoCompileConfig\n  ): boolean {\n    renderFormulaCfg(owner, exprOrCode, config ?? {});\n    return true;\n  },\n  makeSVG(\n    exprOrCode: ChemExpr | ChemAgent | string,\n    fontPropsCache?: WebFontCache\n  ): string {\n    const expr =\n      typeof exprOrCode === \"string\" ? compile(exprOrCode) : exprOrCode;\n    return makeFormulaSvgText(expr, fontPropsCache);\n  },\n  /**\n   * @deprecated next version: ChemSys.textFormula()\n   * @param objOrCode if string, then formula code, else ChemObj (usually ChemExpr)\n   * @param rules by default = dictTextRules.text\n   * @returns\n   */\n  makeTextFormula(objOrCode: ChemObj | string, rules?: RulesBase): string {\n    const chemObj =\n      typeof objOrCode === \"string\" ? compile(objOrCode) : objOrCode;\n    return makeTextFormula(chemObj, rules);\n  },\n  /**\n   * @deprecated next version: ChemSys.testTypesList (for ChemSys.textFormula())\n   */\n  dictTextRules,\n\n  textFormula(\n    objOrCode: ChemObj | string,\n    fmtOrType: FmtDef | FmtType\n  ): string {\n    return textFormula(objOrCode, fmtOrType);\n  },\n  get textTypesList(): readonly FmtType[] {\n    return textTypes;\n  },\n\n  makeBruttoKey(src: ChemObj | string): string {\n    return makeBruttoKey(src);\n  },\n  makeBrutto(src: ChemObj | string): ChemExpr {\n    return compile(makeBruttoKey(src));\n  },\n  lang(key: string, params?: LangParams, langId?: string): string {\n    return Lang.tr(key, params, langId);\n  },\n  get curLang(): string {\n    return Lang.curLang;\n  },\n  set curLang(locale: string) {\n    Lang.curLang = locale;\n  },\n  get navLang(): string | undefined {\n    return Lang.navLang;\n  },\n  get Dict(): Record<string, LocalDict> {\n    return Lang.dict;\n  },\n  isAbstract(chemObj: ChemObj): boolean {\n    return isAbstract(chemObj);\n  },\n  calcMass(chemObj: ChemObj, applyAgentK?: boolean): number {\n    return calcMass(chemObj, applyAgentK);\n  },\n  roundMass(mass: number): number {\n    return roundMass(mass);\n  },\n  calcCharge(chemObj: ChemObj): number {\n    return calcCharge(chemObj);\n  },\n  findElem(id: string): ChemAtom | undefined {\n    return findElement(id);\n  },\n  drawTable(rules?: TableRules): string {\n    return drawPeriodicTable(rules);\n  },\n  findCategory(table: TCategories, elemId: string, locale?: string) {\n    return findCategory(table, elemId, locale);\n  },\n  TblRules: {\n    Std: tableRulesStd,\n    Wide: tableRulesWide,\n    Short: tableRulesShort,\n    EasyChemistry: tableRulesEasyChemistry,\n  },\n  TblCategory: {\n    block: categoryBlock,\n    blockDLa: categoryBlockDLa,\n    props: categoryProps,\n  },\n  drawTag(tag: string, attrs: XmlAttrs, content?: string | number): string {\n    return content === undefined\n      ? drawTag(tag, attrs, true)\n      : `${drawTag(tag, attrs)}${escapeXml(String(content))}</${tag}>`;\n  },\n  esc(content: string | number): string {\n    return escapeXml(String(content));\n  },\n\n  /**\n   * Solving a chemical equation\n   * @param equation example: \"H2 + O2 = H2O\"\n   * @returns Its recommended to use result.isOk() or getMessage() to check a result expression.\n   *   You can use result.src and result.getAgents() to get results of equalize\n   */\n  equalize(equation: string): ChemExpr {\n    const eq = new ChemEquation();\n    eq.initBySrc(equation);\n    eq.solve();\n    if (!eq.isSolved()) {\n      return ChemExpr.createWithError(eq.makeError(), equation);\n    }\n    return eq.getExpr()!;\n  },\n});\n","import { WebFontCache } from \"../drawSys/browser/WebFontCache\";\nimport { RulesHtml } from \"../textRules/rulesHtml\";\n\nexport type DrawSysId = \"svg\" | \"canvas\";\n\nexport interface AutoCompileConfig {\n  nonText?: boolean; // default: false. If true, then text format is not used\n  drawSysId?: DrawSysId; // default: svg\n  formulaSelector?: string; // default: .echem-formula\n  fontPropsCache?: WebFontCache;\n  rules?: RulesHtml;\n}\n\nexport const DrawSysIds: Record<DrawSysId, boolean> = {\n  svg: true,\n  canvas: true,\n};\n","export const addClass = (elem: Element, className: string) => {\n  if (elem.classList) {\n    elem.classList.add(className);\n  } else {\n    const cls: string | null = elem.getAttribute(\"class\");\n    const clsList: string[] = cls ? cls.split(\" \") : [];\n    const clsSet = new Set<string>(clsList);\n    clsSet.add(className);\n    elem.setAttribute(\"class\", Array.from(clsSet).join(\" \"));\n  }\n};\n","import { WebFontCache } from \"../drawSys/browser/WebFontCache\";\nimport { AutoCompileConfig, DrawSysId, DrawSysIds } from \"./AutoCompileConfig\";\nimport { documentCompile } from \"./documentCompile\";\n\nexport const fontPropsCache = new WebFontCache();\n\nexport const autoCompile = () => {\n  if (!document) return;\n  const nodes = document.querySelectorAll(\n    \".easyChemConfig,.CharChemConfig,body.echem-auto-compile\"\n  );\n  if (nodes.length === 0) return;\n  const cfgNode = nodes[nodes.length - 1]!;\n  const cfg: AutoCompileConfig = {\n    fontPropsCache,\n  };\n\n  const drawSys = cfgNode.getAttribute(\"data-drawsys\");\n  if (typeof drawSys === \"string\") {\n    const drawSysId = drawSys.toLowerCase();\n    if (drawSysId in DrawSysIds) {\n      cfg.drawSysId = drawSysId as DrawSysId;\n    }\n  }\n\n  const useText = cfgNode.getAttribute(\"data-usetext\");\n  if (typeof useText === \"string\") {\n    const useTextLow = useText.toLowerCase();\n    cfg.nonText = useTextLow === \"no\";\n  }\n\n  documentCompile(cfg);\n};\n\nexport const addAutoCompileEvent = () => {\n  window?.addEventListener(\"DOMContentLoaded\", autoCompile);\n};\n","import { delay } from \"../utils/delay\";\nimport { AutoCompileConfig } from \"./AutoCompileConfig\";\nimport { renderFormulaCfg } from \"./renderFormulaCfg\";\n\nexport const documentCompile = async (\n  config: AutoCompileConfig\n): Promise<void> => {\n  if (!document) return Promise.reject(new Error(\"Document expected\"));\n  try {\n    const selector = config.formulaSelector ?? \".echem-formula\";\n    const list = document.querySelectorAll(selector);\n    // Тут могут быть разные реализации. Например, webworker или lazy-view\n    // Но пока просто делаем перерыв после каждой отрисовки, чтобы браузер мог получать управление между ними\n    // не подходит queueMicrotask. Нужно создавать макрозадачу\n    let i = 0;\n    let elem = list[i++];\n    while (elem) {\n      elementCompile(elem, config);\n      elem = list[i++];\n      // eslint-disable-next-line no-await-in-loop\n      await delay(1);\n    }\n  } catch (e) {\n    return Promise.reject(e);\n  }\n  return Promise.resolve();\n};\n\nexport const elementCompile = (elem: Element, config: AutoCompileConfig) => {\n  // @ts-ignore\n  const code = elem.textContent ?? elem.innerText;\n  renderFormulaCfg(elem, code, config);\n};\n","import { createBrowserChemImgProps } from \"../drawSys/browser/createBrowserChemImgProps\";\nimport { renderTopFrame } from \"../drawSys/figures/renderTopFrame\";\nimport { HtmlCanvasSurface } from \"../drawSys/browser/HtmlCanvasSurface\";\nimport { WebFontCache } from \"../drawSys/browser/WebFontCache\";\nimport { ChemExpr } from \"../core/ChemExpr\";\nimport { ChemAgent } from \"../core/ChemAgent\";\nimport { buildFrame } from \"../structBuilder/buildFrame\";\nimport { addClass } from \"./addClass\";\n\nexport const renderFormulaCanvas = (\n  owner: Element,\n  expr: ChemExpr | ChemAgent,\n  fontPropsCache?: WebFontCache\n): void => {\n  if (!document) return;\n  // eslint-disable-next-line no-param-reassign\n  owner.innerHTML = \"\"; // clear owner's content\n  const canvas = document.createElement(\"canvas\");\n  owner.append(canvas);\n  const surface = new HtmlCanvasSurface(canvas, fontPropsCache);\n  const props = createBrowserChemImgProps(owner, surface);\n  renderTopFrame(buildFrame(expr, props), surface);\n  addClass(owner, \"echem-is-canvas\");\n};\n","import { ChemAgent } from \"../core/ChemAgent\";\nimport { compile } from \"../compiler/compile\";\nimport { ChemExpr } from \"../core/ChemExpr\";\nimport { isTextFormula } from \"../inspectors/isTextFormula\";\nimport { AutoCompileConfig } from \"./AutoCompileConfig\";\nimport { renderFormulaCanvas } from \"./renderFormulaCanvas\";\nimport { renderFormulaSvg } from \"./renderFormulaSvg\";\nimport { addClass } from \"./addClass\";\nimport { textFormula } from \"../textBuilder/textFormula\";\n\nexport const renderFormulaCfg = (\n  owner: Element,\n  exprOrCode: ChemExpr | ChemAgent | string,\n  config: AutoCompileConfig\n): void => {\n  const expr =\n    typeof exprOrCode === \"string\" ? compile(exprOrCode) : exprOrCode;\n  if (expr instanceof ChemExpr && !expr.isOk()) {\n    owner.classList?.add(\"echem-error\");\n    owner.setAttribute(\"title\", expr.getMessage());\n  } else {\n    const canText = !config.nonText && isTextFormula(expr);\n    if (canText) {\n      // eslint-disable-next-line no-param-reassign\n      owner.innerHTML = textFormula(expr, \"html\");\n      addClass(owner, \"echem-is-text\");\n    } else if (config.drawSysId === \"canvas\") {\n      renderFormulaCanvas(owner, expr, config.fontPropsCache);\n    } else {\n      renderFormulaSvg(owner, expr, config.fontPropsCache);\n    }\n    if (expr instanceof ChemExpr) {\n      owner.setAttribute(\"data-src\", expr.src0.trim());\n    }\n  }\n};\n","import { WebFontCache } from \"../drawSys/browser/WebFontCache\";\nimport { ChemExpr } from \"../core/ChemExpr\";\nimport { SvgWebSurface } from \"../drawSys/browser/SvgWebSurface\";\nimport { createBrowserChemImgProps } from \"../drawSys/browser/createBrowserChemImgProps\";\nimport { renderTopFrame } from \"../drawSys/figures/renderTopFrame\";\nimport { ChemAgent } from \"../core/ChemAgent\";\nimport { buildFrame } from \"../structBuilder/buildFrame\";\nimport { standaloneExportOptions } from \"../drawSys/svg/standaloneExportOptions\";\nimport { addClass } from \"./addClass\";\n\n/**\n * Make a local SVG image for the specified expression on the given HTML element.\n * @param owner HTML element. The content will be completely replaced by the SVG image.\n * @param expr\n */\nexport const renderFormulaSvg = (\n  owner: Element,\n  expr: ChemExpr | ChemAgent,\n  fontPropsCache?: WebFontCache\n) => {\n  if (typeof document === \"undefined\") return;\n  const surface = new SvgWebSurface(fontPropsCache);\n  const props = createBrowserChemImgProps(owner, surface);\n  const frame = buildFrame(expr, props);\n  renderTopFrame(frame, surface);\n  const { bounds } = frame;\n  // eslint-disable-next-line no-param-reassign\n  owner.innerHTML = surface.exportText({\n    width: `${bounds.width}px`,\n    height: `${bounds.height}px`,\n  });\n  addClass(owner, \"echem-is-svg\");\n};\n\nexport const makeFormulaSvgText = (\n  expr: ChemExpr | ChemAgent,\n  fontPropsCache?: WebFontCache\n) => {\n  if (typeof document === \"undefined\") return \"\";\n  const tmp = document.createElement(\"div\");\n  tmp.setAttribute(\"class\", \"echem-formula\");\n  try {\n    document.body.append(tmp);\n    const surface = new SvgWebSurface(fontPropsCache);\n    const props = createBrowserChemImgProps(tmp, surface);\n    const frame = buildFrame(expr, props);\n    renderTopFrame(frame, surface);\n    const { bounds } = frame;\n    return surface.exportText({\n      ...standaloneExportOptions,\n      width: `${bounds.width}px`,\n      height: `${bounds.height}px`,\n    });\n  } finally {\n    tmp.remove();\n  }\n};\n","/* eslint-disable no-param-reassign */\nimport { Point } from \"../math/Point\";\nimport { Int } from \"../types\";\nimport { ChemCompiler } from \"./ChemCompiler\";\nimport { ChemNode } from \"../core/ChemNode\";\nimport { ChemBond } from \"../core/ChemBond\";\n\nlet baseChainId = 1;\nconst generateChainId = (): Int => baseChainId++;\n\nlet baseSubChainId = 1;\nconst generateSubChainId = (): Int => baseSubChainId++;\n\ntype BondOptional = ChemBond | undefined;\n\nexport class ChainSys {\n  private readonly compiler: ChemCompiler;\n\n  constructor(compiler: ChemCompiler) {\n    this.compiler = compiler;\n  }\n\n  private chainsDict: Record<Int, Set<Int>> = {};\n\n  private subChainsDict: Record<Int, ChemNode[]> = {};\n\n  private curChainId = 0;\n\n  curSubChainId = 0;\n\n  private lastBond: BondOptional;\n\n  private stack: BondOptional[] = [];\n\n  getLastBond(): BondOptional {\n    return this.lastBond;\n  }\n\n  onBranchBegin() {\n    this.stack.unshift(this.lastBond);\n  }\n\n  onBranchEnd() {\n    this.lastBond = this.stack.shift();\n  }\n\n  private createChain(): Int {\n    this.lastBond = undefined;\n    const newChainId = generateChainId();\n    this.chainsDict[newChainId] = new Set();\n    return newChainId;\n  }\n\n  private getCurChain(): Set<Int> {\n    if (this.curChainId === 0) {\n      this.curChainId = this.createChain();\n    }\n    return this.chainsDict[this.curChainId]!;\n  }\n\n  createSubChain(): Int {\n    this.lastBond = undefined;\n    const newId = generateSubChainId();\n    this.curSubChainId = newId;\n    this.subChainsDict[newId] = [];\n    this.getCurChain().add(newId);\n    return newId;\n  }\n\n  private getCurSubChain(): ChemNode[] {\n    if (this.curSubChainId === 0) {\n      this.curSubChainId = this.createSubChain();\n    }\n    return this.subChainsDict[this.curSubChainId]!;\n  }\n\n  addNode(node: ChemNode) {\n    if (node.chain === 0) {\n      this.getCurSubChain().push(node);\n      node.chain = this.curChainId;\n      node.subChain = this.curSubChainId;\n    } else {\n      this.curChainId = node.chain;\n      this.curSubChainId = node.subChain;\n    }\n  }\n\n  setCurNode(node: ChemNode) {\n    this.curChainId = node.chain;\n    this.curSubChainId = node.subChain;\n  }\n\n  addBond(bond: ChemBond) {\n    if (bond.soft) {\n      this.createSubChain();\n    }\n    this.lastBond = bond;\n  }\n\n  private mergeSubChains(dstId: Int, srcId: Int, step: Point) {\n    if (dstId === srcId) {\n      return;\n    }\n    const nodes: ChemNode[] = this.subChainsDict[srcId]!;\n    nodes.forEach((it) => {\n      it.subChain = dstId;\n      it.pt.iadd(step);\n    });\n    const dstNodes = this.subChainsDict[dstId];\n    if (dstNodes) nodes.forEach((it) => dstNodes.push(it));\n    delete this.subChainsDict[srcId];\n    if (this.curSubChainId === srcId) {\n      this.curSubChainId = dstId;\n    }\n  }\n\n  /**\n   * scrChain присоединяется к dstChain\n   */\n  private mergeChains(srcNode: ChemNode, dstNode: ChemNode) {\n    const srcChainId = srcNode.chain;\n    const dstChainId = dstNode.chain;\n    if (srcChainId !== dstChainId) {\n      this.compiler\n        .curAgent!.nodes.filter((it) => it.chain === srcChainId)\n        .forEach((it) => {\n          it.chain = dstChainId;\n        });\n    }\n  }\n\n  private makeTransitionBond(bond: ChemBond) {\n    bond.soft = false;\n    bond.dir = undefined;\n    const node1 = bond.nodes[1];\n    if (node1) {\n      this.addNode(node1);\n    }\n  }\n\n  /**\n   * Связь, у которой второй узел указан через ссылку\n   */\n  bondToRef(bond: ChemBond) {\n    const [srcNode, dstNode] = bond.nodes;\n    if (!srcNode || !dstNode) {\n      return;\n    }\n    // Если узлы принадлежат разным цепям, то нужно срастить две цепи\n    const srcSubChain: Int = srcNode.subChain;\n    const dstSubChain: Int = dstNode.subChain;\n    if (srcSubChain !== dstSubChain) {\n      // Если разные подцепи соединяются мягкой связью, то они остаются разными\n      // иначе подцепи сращиваются\n      if (!bond.soft) {\n        // Если цепи разные, то их нужно объединить\n        const srcChain: Int = srcNode.chain;\n        const dstChain: Int = dstNode.chain;\n        if (srcChain !== dstChain) {\n          this.mergeChains(srcNode, dstNode);\n          const step = dstNode.pt.minus(srcNode.pt).minus(bond.dir!);\n          this.mergeSubChains(dstSubChain, srcSubChain, step);\n        } else {\n          // Если цепь одна, но разные подцепи, то это переходная связь\n          this.makeTransitionBond(bond);\n        }\n      }\n    } else {\n      // Но если узлы в одной подцепи, то корректировать шаг связи\n      bond.dir = dstNode.pt.minus(srcNode.pt);\n    }\n    this.compiler.curNode = dstNode;\n    this.curChainId = dstNode.chain;\n    this.curSubChainId = dstNode.subChain;\n  }\n\n  changeBondToHard(bond: ChemBond) {\n    const dstNode = bond.nodes[0];\n    if (dstNode) {\n      const srcNode = bond.nodes[1];\n      if (srcNode) {\n        if (srcNode.chain !== dstNode.chain) {\n          throw Error(\"Different chains\");\n        }\n        this.mergeSubChains(\n          dstNode.subChain,\n          srcNode.subChain,\n          bond.dir ?? new Point()\n        );\n      }\n      this.curSubChainId = dstNode.subChain;\n      this.curChainId = dstNode.chain;\n    }\n  }\n\n  closeChain() {\n    this.curChainId = 0;\n    this.curSubChainId = 0;\n    this.lastBond = undefined;\n  }\n\n  closeSubChain() {\n    this.curSubChainId = 0;\n    this.lastBond = undefined;\n  }\n\n  findNode(pt: Point): ChemNode | undefined {\n    return this.getCurSubChain().find((it) => it.pt.equals(pt));\n  }\n}\n","import { CoeffPosOrAngle } from \"../types/CoeffPos\";\nimport { Int, Double, Char } from \"../types\";\nimport { LangParams } from \"../lang\";\nimport { ChemAgent } from \"../core/ChemAgent\";\nimport { ChemNode } from \"../core/ChemNode\";\nimport { LewisDot } from \"../core/ChemNodeItem\";\nimport { ChemExpr } from \"../core/ChemExpr\";\nimport { ChemObj } from \"../core/ChemObj\";\nimport { ChemOp } from \"../core/ChemOp\";\nimport { BondAlign, ChemBond } from \"../core/ChemBond\";\nimport { ChemChargeOwner } from \"../core/ChemChargeOwner\";\nimport { ChemComment } from \"../core/ChemComment\";\nimport { ChemError } from \"../core/ChemError\";\n\nimport { ChainSys } from \"./ChainSys\";\nimport { MiddlePoint } from \"./types\";\nimport { MulCounter } from \"./main/MulCounter\";\nimport { NodesBranch } from \"./main/NodesBranch\";\nimport { StackItem } from \"./main/StackItem\";\n\nimport { stateBegin } from \"./state/stateBegin\";\nimport { prepareText } from \"./parse/prepareText\";\nimport { BracketsCtrl } from \"./main/BracketsCtrl\";\nimport { ParamsChemBackground } from \"../core/ChemBackground\";\nimport { ChemCompilerOptions } from \"./ChemCompilerOptions\";\nimport { SrcMapItem, SpecPart } from \"./sourceMap\";\n\nexport type CompilerState = (c: ChemCompiler) => Int;\n\nexport class ChemCompiler {\n  readonly srcText: string;\n\n  readonly options: ChemCompilerOptions;\n\n  constructor(srcText: string, options?: ChemCompilerOptions) {\n    this.srcText = srcText;\n    this.options = options ?? {};\n    if (this.options.srcMap) {\n      this.srcMap = [];\n      this.expr.srcMap = this.srcMap;\n    }\n  }\n\n  readonly expr = new ChemExpr();\n\n  text = \"\";\n\n  pos = 0;\n\n  srcMap?: SrcMapItem[];\n\n  curState: CompilerState = stateBegin;\n\n  curEntity?: ChemObj;\n\n  curOp?: ChemOp;\n\n  curAgent?: ChemAgent;\n\n  agentMode?: \"begin\" | \"in\";\n\n  curNode?: ChemNode;\n\n  curBond?: ChemBond;\n\n  chargeOwner?: ChemChargeOwner; // Объект, к которому применится конструкция ^\n\n  curPart: Int = 0;\n\n  elementStartPos: Int = 0;\n\n  preComm?: ChemComment;\n\n  preCommPos?: number;\n\n  readonly chainSys = new ChainSys(this);\n\n  references: Record<string, ChemNode> = {};\n\n  readonly mulCounter: MulCounter = new MulCounter();\n\n  readonly varsDict: Record<string, Double> = {};\n\n  curWidth = 0;\n\n  readonly nodesBranch = new NodesBranch();\n\n  readonly bracketsCtrl = new BracketsCtrl();\n\n  readonly middlePoints: MiddlePoint[] = [];\n\n  private readonly stack: StackItem[] = [];\n\n  background?: ParamsChemBackground;\n\n  push(item: StackItem) {\n    this.stack.unshift(item);\n  }\n\n  pop(): StackItem | undefined {\n    return this.stack.shift();\n  }\n\n  private altFlag: boolean = false;\n\n  setAltFlag() {\n    this.altFlag = true;\n  }\n\n  getAltFlag(): boolean {\n    const value = this.altFlag;\n    this.altFlag = false;\n    return value;\n  }\n\n  varSlope: Double = 0.0;\n\n  varLength: Double = 1.0;\n\n  varMass?: Double; // special mass for next element - $M()\n\n  varAtomNumber?: Int | \"\"; // number in $nM(mass, number)\n\n  varColor?: string;\n\n  varItemColor?: string;\n\n  varItemColor1?: string;\n\n  varAtomColor?: string;\n\n  varAtomColor1?: string;\n\n  varAlign?: BondAlign;\n\n  varPadding: number[] = [];\n\n  centralNode: boolean = false;\n\n  varDots?: LewisDot[] = undefined;\n\n  varPos?: CoeffPosOrAngle = undefined;\n\n  entityBegin?: number;\n\n  eject<K extends \"varPos\" | \"varDots\" | \"entityBegin\" | \"preCommPos\">(\n    key: K\n  ): ChemCompiler[K] {\n    const v = this[key];\n    this[key] = undefined;\n    return v;\n  }\n\n  curChar(): Char {\n    return this.text[this.pos]!;\n  }\n\n  nextChar(): Char {\n    return this.text[this.pos + 1]!;\n  }\n\n  subStr(startPos: Int): string {\n    return this.text.slice(startPos, this.pos);\n  }\n\n  isFinish(): boolean {\n    return this.pos >= this.text.length;\n  }\n\n  /**\n   * Специальная функция сравнения, соответствует ли указанная строка value\n   * содержимому text, начиная с позиции pos\n   */\n  isCurPosEq(value: string): boolean {\n    return (\n      value ===\n      this.text.slice(\n        this.pos,\n        Math.min(this.text.length, this.pos + value.length)\n      )\n    );\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  error(msgId: string, params: LangParams): never {\n    const newParams = { ...params };\n    const { pos } = newParams;\n    if (typeof pos === \"number\") {\n      newParams.pos = pos + 1;\n    }\n    throw new ChemError(msgId, newParams);\n  }\n\n  setState(newState: CompilerState, deltaPos: Int = 0): Int {\n    this.curState = newState;\n    return deltaPos;\n  }\n\n  addSrcMapItem(obj: ChemObj, begin?: number, part?: SpecPart) {\n    const { srcMap, pos: end } = this;\n    if (begin !== undefined && srcMap) {\n      srcMap.push({ begin, end, obj, part });\n    }\n  }\n}\n\nexport const createTestCompiler = (text: string): ChemCompiler => {\n  const compiler = new ChemCompiler(text);\n  prepareText(compiler);\n  return compiler;\n};\n","import { ChemExpr } from \"../core/ChemExpr\";\nimport { ChemCompiler } from \"./ChemCompiler\";\nimport { ChemCompilerOptions } from \"./ChemCompilerOptions\";\nimport { closeEntity } from \"./main/entity\";\nimport { prepareText } from \"./parse/prepareText\";\n\nexport const compile = (\n  text: string,\n  options?: ChemCompilerOptions\n): ChemExpr => {\n  const compiler = new ChemCompiler(text, options);\n  try {\n    prepareText(compiler);\n    while (!compiler.isFinish()) {\n      const step = compiler.curState(compiler);\n      compiler.pos += step;\n    }\n    closeEntity(compiler);\n  } catch (e) {\n    compiler.expr.error = e;\n  }\n  return compiler.expr;\n};\n","/**\n * Границы:\n *  Фон по-умолчанию применяется к следующему узлу, но можно указать иные узлы.\n *  Либо: весь агент\n *  Если функция в конце выражения или объявляется несколько подряд, то у них нет узла и их надо указать явно.\n * фон должен захватить все указанные узлы\n * Фигура: rect (default), round, ellipse\n * r (borderRadius) для rect\n * padding\n * fill\n * stroke\n * width\n *\n * Если формула нескольео раз использует похожий набор параметров, можно использовать макрос\n */\n\nimport { ChemNode } from \"../../core/ChemNode\";\nimport {\n  ChemBackground,\n  ParamsChemBackground,\n} from \"../../core/ChemBackground\";\nimport { Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { parseNum } from \"../parse/parseNum\";\nimport { findNodeEx } from \"../main/findNode\";\nimport { parsePadding } from \"../parse/parsePadding\";\n\nexport const funcBackground = (\n  compiler: ChemCompiler,\n  args: string[],\n  pos: Int[]\n) => {\n  if (compiler.background) {\n    // Возможно указать несколько фонов подряд.\n    // Тогда фоновая команда создается не дожидаясь объявления узла.\n    // Само собой, нужно корректно указывать узлы.\n    compiler.curAgent?.commands.push(new ChemBackground(compiler.background));\n  }\n  compiler.background = parseBackgroundArgs(compiler, args, pos);\n};\n\nconst shapeNames = new Set([\"rect\", \"round\", \"ellipse\"]);\n\nexport const parseBackgroundArgs = (\n  compiler: ChemCompiler,\n  args: string[],\n  pos: Int[]\n): ParamsChemBackground => {\n  const params: ParamsChemBackground = {};\n  args.forEach((arg, i) => {\n    const curPos = pos[i]!;\n    const argt = arg.trim();\n    if (argt === \"*\") {\n      params.isAll = true;\n    } else {\n      const divPos = arg.indexOf(\":\");\n      if (divPos < 0) {\n        if (shapeNames.has(argt)) {\n          params.shape = argt;\n        } else if (!params.fill) {\n          params.fill = arg;\n        }\n      } else {\n        const key = arg.slice(0, divPos);\n        const val = arg.slice(divPos + 1);\n        const valPos = curPos + divPos + 1;\n        switch (key) {\n          case \"\":\n          case \"to\":\n            params.nodes = parseNodes(compiler, val, valPos);\n            break;\n          case \"fill\":\n          case \"f\":\n            params.fill = val.trim();\n            break;\n          case \"stroke\":\n          case \"s\":\n            params.stroke = val.trim();\n            break;\n          case \"width\":\n          case \"w\":\n            params.strokeWidth = parseNum(compiler, val, valPos);\n            break;\n          case \"padding\":\n          case \"p\":\n            params.padding = parsePadding(compiler, val, valPos);\n            break;\n          case \"r\":\n            params.borderRadius = parseNum(compiler, val, valPos);\n            break;\n          default:\n            break;\n        }\n      }\n    }\n  });\n  return params;\n};\n\nconst parseNodes = (\n  compiler: ChemCompiler,\n  nodesList: string,\n  pos: Int\n): ChemNode[] => {\n  const chunks = nodesList.split(\";\");\n  let curPos = 0;\n  return chunks.map((nodeDef) => {\n    const node = findNodeEx(compiler, nodeDef, curPos + pos);\n    curPos += nodeDef.length + 1;\n    return node;\n  });\n};\n","import { ChemCompiler } from \"../ChemCompiler\";\n\nexport const funcC = (compiler: ChemCompiler) => {\n  compiler.centralNode = true;\n};\n","/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\n\nexport const funcColor = (\n  compiler: ChemCompiler,\n  [value]: string[],\n  pos: Int[]\n) => {\n  compiler.varColor = value;\n};\n\nexport const funcItemColor = (\n  compiler: ChemCompiler,\n  [value]: string[],\n  pos: Int[]\n) => {\n  compiler.varItemColor = value;\n};\n\nexport const funcItemColor1 = (\n  compiler: ChemCompiler,\n  [value]: string[],\n  pos: Int[]\n) => {\n  compiler.varItemColor1 = value;\n};\n\nexport const funcAtomColor = (\n  compiler: ChemCompiler,\n  [value]: string[],\n  pos: Int[]\n) => {\n  compiler.varAtomColor = value;\n};\n\nexport const funcAtomColor1 = (\n  compiler: ChemCompiler,\n  [value]: string[],\n  pos: Int[]\n) => {\n  compiler.varAtomColor1 = value;\n};\n","import { BondAlign } from \"../../core/ChemBond\";\nimport { ChemCompiler } from \"../ChemCompiler\";\n\nconst aligns = { r: 1, R: 1, l: 1, L: 1, m: 1, M: 1 };\n\nexport const funcDblAlign = (\n  compiler: ChemCompiler,\n  args: string[]\n  // @Suppress(\"UNUSED_PARAMETER\") pos: List<Int>\n) => {\n  compiler.varAlign =\n    args[0]! in aligns ? (args[0]![0]!.toLowerCase() as BondAlign) : undefined;\n};\n","import { LewisDot } from \"../../core/ChemNodeItem\";\nimport { Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { parseNum } from \"../parse/parseNum\";\n\n/*\n 1. Compatible for ver 0.0\n  UTDBLRutdblr for pairs of points top, bottom, left and right\n  ! = all 8 positions\n  (L) = :O, (Lb) = .O, (R) = O:, (LR) = :O:, (LbRb) = .O., (T) = (U) = Ö \n  LR = !UD\n 2. Compatible for 1.0\n  List of angles\n  (22,-22) = O:\n 3. Features of 2.0:\n  - using colors: $dots(c:red,UD) or $dots(c:blue,22,-22)\n  - using combination of different parameters: (c:green,T,c:red,180)\n*/\n\n// Цвета по приоритетности (при отрисовке): цвет точки, цвет атома, цвет элемента, дефолтный цвет\n\nconst rxCompact = /^!?([LR][dbtu]?|[UTDB][lr]?)+$/;\n\nexport const splitDotPositions = (descr: string): number[] => {\n  //    5  6  U=T\n  // L 4 ## 7  R\n  //   3 ## 0\n  //    2  1  B=D\n  const result: number[] = [];\n  const isRev = descr[0] === \"!\";\n  let i = isRev ? 1 : 0;\n  const check2 = (match: string, n: number) => {\n    if (match.indexOf(descr[i]!) >= 0) {\n      result.push(n);\n      i++;\n      return true;\n    }\n    return false;\n  };\n  const checkEx = (m1: string, n1: number, m2: string, n2: number): void => {\n    // eslint-disable-next-line no-unused-expressions\n    check2(m1, n1) || check2(m2, n2) || result.push(n1, n2);\n  };\n  while (i < descr.length) {\n    const c = descr[i++];\n    if (c === \"R\") {\n      checkEx(\"db\", 0, \"tu\", 7);\n    } else if (c === \"L\") {\n      checkEx(\"db\", 3, \"tu\", 4);\n    } else if (c === \"U\" || c === \"T\") {\n      checkEx(\"l\", 5, \"r\", 6);\n    } else if (c === \"B\" || c === \"D\") {\n      checkEx(\"r\", 1, \"l\", 2);\n    }\n  }\n  if (!isRev) {\n    return result;\n  }\n  const revSet = result.reduce((acc, n) => {\n    acc.delete(n);\n    return acc;\n  }, new Set([0, 1, 2, 3, 4, 5, 6, 7]));\n  return Array.from(revSet);\n};\n\ninterface ResDotArgDirs {\n  cmd: \"dirs\";\n  dirs: number[]; // directions from 0 to 7\n}\ninterface ResDotArgNum {\n  cmd: \"num\";\n  num: number;\n}\ninterface ResDotArgColor {\n  cmd: \"color\";\n  color?: string;\n}\ninterface ResDotArgMargin {\n  cmd: \"margin\";\n  margin?: number;\n}\ntype ResDotArg =\n  | ResDotArgDirs\n  | ResDotArgNum\n  | ResDotArgColor\n  | ResDotArgMargin;\n\nexport const parseSingleDotArg = (\n  compiler: ChemCompiler,\n  arg: string,\n  pos: Int\n): ResDotArg | undefined => {\n  if (!arg) return undefined;\n  if (arg.startsWith(\"c:\") || arg.startsWith(\"color:\")) {\n    const color = arg.slice(arg.indexOf(\":\") + 1);\n    return { cmd: \"color\", color: color || undefined };\n  }\n  if (arg.startsWith(\"m:\") || arg.startsWith(\"margin:\")) {\n    const val = arg.slice(arg.indexOf(\":\") + 1);\n    const margin = val ? parseNum(compiler, val, pos) : undefined;\n    return { cmd: \"margin\", margin };\n  }\n  if (arg === \"!\" || rxCompact.test(arg)) {\n    return { cmd: \"dirs\", dirs: splitDotPositions(arg) };\n  }\n  return { cmd: \"num\", num: parseNum(compiler, arg, pos) };\n};\n\nexport const parseDotsArgs = (\n  compiler: ChemCompiler,\n  args: string[],\n  pos: Int[]\n): LewisDot[] => {\n  const dots: LewisDot[] = [];\n  let color: string | undefined;\n  let margin: number | undefined;\n  const params = () => {\n    const res: { color?: string; margin?: number } = {};\n    if (color) res.color = color;\n    if (margin) res.margin = margin;\n    return res;\n  };\n  const addAngle = (angle: number) => {\n    dots.push({ ...params(), angle });\n  };\n  const addPos = (dotPos: number) => {\n    dots.push({ ...params(), pos: dotPos });\n  };\n  args.forEach((arg, i) => {\n    const r: ResDotArg | undefined = parseSingleDotArg(compiler, arg, pos[i]!);\n    switch (r?.cmd) {\n      case \"dirs\":\n        r.dirs.forEach((dir) => addPos(dir));\n        break;\n      case \"num\":\n        addAngle(r.num);\n        break;\n      case \"color\":\n        color = r.color;\n        break;\n      case \"margin\":\n        margin = r.margin;\n        break;\n      default:\n        break;\n    }\n  });\n  return dots;\n};\n\nexport const funcDots = (\n  compiler: ChemCompiler,\n  args: string[],\n  pos: Int[]\n) => {\n  const dots: LewisDot[] = parseDotsArgs(compiler, args, pos);\n  compiler.varDots = dots;\n};\n","import { Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { parseNum } from \"../parse/parseNum\";\n\nexport const funcL = (compiler: ChemCompiler, args: string[], pos: Int[]) => {\n  compiler.varLength =\n    args.length === 0 ? 1.0 : parseNum(compiler, args[0]!, pos[0]!);\n};\n","import { Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { parseNum } from \"../parse/parseNum\";\n\nexport const funcM = (compiler: ChemCompiler, args: string[], pos: Int[]) => {\n  if (args.length > 0) {\n    compiler.varMass = parseNum(compiler, args[0]!, pos[0]!);\n  }\n};\n","import { Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { parseNum } from \"../parse/parseNum\";\n\nexport const funcPadding = (\n  compiler: ChemCompiler,\n  args: string[],\n  pos: Int[]\n) => {\n  compiler.varPadding = args.map((arg, i) => parseNum(compiler, arg, pos[i]!));\n};\n","import { CoeffPos, rxCoeffPos } from \"../../types/CoeffPos\";\nimport { Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { parseNum } from \"../parse/parseNum\";\n\n// В случае использования угла не действуют supKX и subKX\n\nexport const funcPos = (compiler: ChemCompiler, args: string[], pos: Int[]) => {\n  const arg = args[0];\n  if (!arg) return;\n  if (rxCoeffPos.test(arg)) {\n    compiler.varPos = arg as CoeffPos;\n  } else {\n    compiler.varPos = parseNum(compiler, arg, pos[0]!);\n  }\n};\n","import { Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { parseNum } from \"../parse/parseNum\";\n\nexport const funcSlope = (\n  compiler: ChemCompiler,\n  args: string[],\n  pos: Int[]\n) => {\n  compiler.varSlope =\n    args.length === 0 ? 0.0 : parseNum(compiler, args[0]!, pos[0]!);\n};\n","import { getVersion } from \"../../getVersion\";\nimport { Int } from \"../../types\";\nimport { ifDef } from \"../../utils/ifDef\";\nimport { ChemCompiler } from \"../ChemCompiler\";\n\nconst toIntOrZero = (s: string = \"\"): Int => +s || 0;\n\n// Эта функция должна обеспечивть совместимость с предыдущими версиями\n// Возможно передать в одном параметре оба номера через точку 1.1\n// Но можно и через запятую. Тогда это два параметра\nexport const parseVerParameter = (args: string[]): [Int, Int] => {\n  const [a, b] = args;\n  const verStr: string =\n    ifDef(a, (v1) => ifDef(b, (v2) => `${v1}.${v2}`) ?? a) ?? b ?? \"0.0\";\n  const verList = verStr.split(\".\");\n  const verList2 = [\n    verList.length === 0 ? \"0\" : verList[0]!,\n    verList.length < 2 ? \"0\" : verList[1]!,\n  ];\n  return [toIntOrZero(verList2[0]), toIntOrZero(verList2[1])];\n};\n\nexport const funcVer = (compiler: ChemCompiler, args: string[]) => {\n  const [high, low] = parseVerParameter(args);\n  const currentVersion = getVersion();\n  if (\n    high > currentVersion[0]! ||\n    (high === currentVersion[0] && low > currentVersion[1]!)\n  ) {\n    compiler.error(\"Invalid version\", {\n      cur: `${currentVersion[0]}.${currentVersion[1]}`,\n      need: `${high}.${low}`,\n    });\n  }\n};\n","// Масса следующего элемента плюс атомный номер   238 #  #\n// Например $nM(238)U                                 #  #\n//                                                 92  ##\n// Или можно $nM(1,0){n}\n\nimport { Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { funcM } from \"./funcM\";\n\nexport const funcnM = (compiler: ChemCompiler, args: string[], pos: Int[]) => {\n  funcM(compiler, args, pos);\n  // \"\" означает, что надо использовать массу того атома, к которому применяется функция\n  // в отличие от undefined, который означает, что номер элемента вообще не выводится\n  compiler.varAtomNumber = args.length > 1 ? cvt(args[1]!) : \"\";\n};\n\nconst cvt = (s: string): number | undefined => {\n  if (!s) return undefined;\n  const n = +s;\n  return Number.isNaN(n) ? undefined : n;\n};\n","import { Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { funcBackground } from \"./funcBackground\";\nimport { funcC } from \"./funcC\";\nimport {\n  funcAtomColor,\n  funcAtomColor1,\n  funcColor,\n  funcItemColor,\n  funcItemColor1,\n} from \"./funcColor\";\nimport { funcDblAlign } from \"./funcDblAlign\";\nimport { funcDots } from \"./funcDots\";\nimport { funcL } from \"./funcL\";\nimport { funcM } from \"./funcM\";\nimport { funcnM } from \"./funcnM\";\nimport { funcPadding } from \"./funcPadding\";\nimport { funcPos } from \"./funcPos\";\nimport { funcSlope } from \"./funcSlope\";\nimport { funcVer } from \"./funcVer\";\n\ntype ChemFunc = (compiler: ChemCompiler, args: string[], argPos: Int[]) => void;\n\nexport const funcsDict: Record<string, ChemFunc> = {\n  atomColor: funcAtomColor,\n  atomColor1: funcAtomColor1,\n  background: funcBackground,\n  bg: funcBackground, // short form of 'background'\n  C: funcC,\n  color: funcColor,\n  dblAlign: funcDblAlign,\n  dots: funcDots,\n  itemColor: funcItemColor,\n  itemColor1: funcItemColor1,\n  L: funcL,\n  M: funcM,\n  nM: funcnM,\n  padding: funcPadding,\n  pos: funcPos,\n  slope: funcSlope,\n  ver: funcVer,\n};\n","import { ChemBracketBegin, ChemBracketEnd } from \"../../core/ChemBracket\";\nimport { ChemNode } from \"../../core/ChemNode\";\n\nexport class BracketsCtrl {\n  private queue: (ChemBracketBegin | ChemBracketEnd)[] = [];\n\n  clear() {\n    this.queue.length = 0;\n  }\n\n  onNode(node: ChemNode) {\n    this.queue.forEach((obj) => {\n      obj.nodes[1] = node;\n    });\n    this.clear();\n  }\n\n  onBracket(obj: ChemBracketBegin | ChemBracketEnd) {\n    this.queue.push(obj);\n  }\n}\n","import { Int } from \"../../types\";\nimport { ChemMul } from \"../../core/ChemMul\";\nimport { ChemNode } from \"../../core/ChemNode\";\n\n/*\n Множители появляются:\n - после символа *;\n - сразу после открытия скобки (это новая фича для версии 1.2)\n Закрываются автоматически:\n - перед символом *\n - перед закрытием СООТВЕТСТВУЮЩЕЙ скобки\n - в конце агента\n */\n\nexport class MulCounter {\n  private mul?: ChemMul;\n\n  private bracketCounter: Int = 0;\n\n  onOpenBracket() {\n    if (this.mul) {\n      ++this.bracketCounter;\n    }\n  }\n\n  onNode(node: ChemNode) {\n    const { mul } = this;\n    if (mul && !mul.nodes[1]) {\n      mul.nodes[1] = node;\n    }\n  }\n\n  onCloseBracket() {\n    if (this.mul) {\n      --this.bracketCounter;\n    }\n  }\n\n  close() {\n    this.mul = undefined;\n  }\n\n  create(newMul: ChemMul) {\n    this.mul = newMul;\n  }\n\n  getMulForBracket(): ChemMul | undefined {\n    return this.bracketCounter > 0 ? undefined : this.mul;\n  }\n\n  getMulForced(): ChemMul | undefined {\n    return this.mul;\n  }\n}\n","import { ChemNode } from \"../../core/ChemNode\";\n\nexport class NodesBranch {\n  private readonly nbStack: Array<ChemNode[]> = []; // mutableListOf<MutableList<ChemNode>>()\n\n  nodes: ChemNode[] = [];\n\n  onBranchBegin() {\n    const copy = [...this.nodes];\n    this.nbStack.unshift(copy);\n  }\n\n  onBranchEnd() {\n    const svNodes = this.nbStack.shift();\n    if (svNodes) this.nodes = svNodes;\n  }\n\n  onSubChain() {\n    this.nodes.length = 0;\n  }\n\n  onNode(node: ChemNode) {\n    this.nodes.push(node);\n  }\n}\n","import { Int } from \"../../types\";\n\nexport abstract class StackItem {\n  constructor(public readonly pos: Int) {}\n\n  abstract msgInvalidClose(): string;\n}\n","import { ChemCompiler } from \"../ChemCompiler\";\nimport { ChemSubObj } from \"../../core/ChemSubObj\";\nimport { ChemNodeItem } from \"../../core/ChemNodeItem\";\nimport { getNodeForced } from \"./node\";\nimport { closeItem } from \"./item\";\nimport { getAtomColor, getItemColor } from \"./colors\";\nimport { ifDef } from \"../../utils/ifDef\";\n\nexport const addNodeItem = (\n  compiler: ChemCompiler,\n  subObj: ChemSubObj\n): ChemNodeItem => {\n  closeItem(compiler);\n  const item = new ChemNodeItem(subObj);\n  ifDef(compiler.varMass, (it) => {\n    item.mass = it;\n    compiler.varMass = undefined;\n  });\n  item.color = getItemColor(compiler);\n  item.atomColor = getAtomColor(compiler);\n  item.atomNum = compiler.varAtomNumber;\n  item.bCenter = compiler.getAltFlag();\n  item.dots = compiler.varDots;\n  compiler.varDots = undefined;\n  compiler.varAtomNumber = undefined;\n  getNodeForced(compiler, false).items.push(item);\n  return item;\n};\n","import { Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { ChemAgent } from \"../../core/ChemAgent\";\nimport { ChemK } from \"../../core/ChemK\";\nimport { onCreateEntity, closeEntity } from \"./entity\";\nimport { addNodeItem } from \"./addNodeItem\";\nimport { closeNode, openNode, updateAutoNode } from \"./node\";\nimport { checkMul, startMul } from \"./multipier\";\nimport { checkBranch, closeBranch } from \"./branch\";\nimport { scanCoeff } from \"../parse/scanCoeff\";\nimport { checkMiddlePoints } from \"./middlePoint\";\nimport { stateAgentMid } from \"../state/stateAgentMid\";\nimport { ChemBackground } from \"../../core/ChemBackground\";\n\nexport const createAgent = (compiler: ChemCompiler): ChemAgent => {\n  let { pos } = compiler;\n  const { preComm } = compiler;\n  closeEntity(compiler);\n  const agent = new ChemAgent();\n  agent.part = compiler.curPart;\n  compiler.curAgent = agent;\n  onCreateEntity(compiler, agent);\n  if (preComm) {\n    pos = compiler.eject(\"preCommPos\") ?? pos;\n    addNodeItem(compiler, preComm);\n  }\n  compiler.references = {};\n  compiler.varMass = undefined;\n  compiler.curWidth = 0;\n  compiler.centralNode = false;\n  compiler.varPadding = [];\n  compiler.varDots = undefined;\n  compiler.nodesBranch.onSubChain();\n  compiler.bracketsCtrl.clear();\n  if (compiler.srcMap) {\n    compiler.entityBegin = pos;\n  }\n  return agent;\n};\n\nexport const closeChain = (compiler: ChemCompiler) => {\n  const { curBond } = compiler;\n  if (curBond) {\n    if (curBond.nodes.length === 2 && !curBond.nodes[1]) {\n      openNode(compiler, true);\n    }\n  }\n  compiler.curBond = undefined;\n  closeNode(compiler);\n  compiler.chainSys.closeChain();\n  compiler.nodesBranch.onSubChain();\n  compiler.bracketsCtrl.clear();\n};\n\nexport const onCloseAgent = (compiler: ChemCompiler) => {\n  const { curAgent } = compiler;\n  if (curAgent) {\n    checkMul(compiler);\n    checkMiddlePoints(compiler);\n    closeChain(compiler);\n    compiler.curAgent = undefined;\n    compiler.getAltFlag();\n    compiler.curBond = undefined;\n    checkBranch(compiler);\n    finalUpdateBondsForNodes(curAgent);\n    finalUpdateAutoNodes(curAgent);\n    if (compiler.background) {\n      curAgent.commands.push(new ChemBackground(compiler.background));\n    }\n    compiler.background = undefined;\n    curAgent.bonds.forEach((b, i) => {\n      b.index = i;\n    });\n    compiler.addSrcMapItem(curAgent, compiler.entityBegin);\n    compiler.agentMode = undefined;\n  }\n};\n\nexport const star = (compiler: ChemCompiler): Int => {\n  compiler.pos++;\n  if (compiler.curChar() === \")\") {\n    return closeBranch(compiler);\n  }\n  checkMul(compiler);\n  startMul(compiler, scanCoeff(compiler) ?? new ChemK(1), false);\n  return compiler.setState(stateAgentMid);\n};\n\nexport const finalUpdateBondsForNodes = (agent: ChemAgent) => {\n  // update bonds field for all nodes\n  agent.walk({\n    bond(obj) {\n      obj.nodes.forEach((it) => it?.addBond(obj));\n    },\n  });\n};\n\nexport const finalUpdateAutoNodes = (agent: ChemAgent) => {\n  agent.walk({\n    nodePre(obj) {\n      if (obj.autoMode) {\n        updateAutoNode(obj);\n      }\n    },\n  });\n};\n","import { ChemCompiler } from \"../ChemCompiler\";\nimport { Int } from \"../../types\";\nimport { createSimpleBond, scanSimpleBond } from \"./bondSimple\";\nimport { closeChain, star } from \"./agent\";\nimport { createLabel } from \"./createLabel\";\nimport { closeBranch, openBranch } from \"./branch\";\nimport { addNodeItem } from \"./addNodeItem\";\nimport { instChemComma } from \"../../core/ChemComma\";\nimport { getNodeForced } from \"./node\";\nimport { stateAgentMid } from \"../state/stateAgentMid\";\nimport { stateElement } from \"../state/stateElement\";\nimport { stateCommentIn } from \"../state/stateCommentIn\";\nimport { stateCustom } from \"../state/stateCustom\";\nimport { stateAgentSpace } from \"../state/stateAgentSpace\";\nimport { stateNodeRef } from \"../state/stateNodeRef\";\nimport { stateCharge } from \"../state/stateCharge\";\nimport {\n  closeBracketShort,\n  openParentheses,\n  openSquareBracket,\n} from \"./brackets\";\nimport { stateUniBond } from \"../state/stateUniBond\";\nimport { stateFuncName } from \"../state/stateFuncName\";\n\nexport const agentAnalyse = (\n  compiler: ChemCompiler,\n  onDefault: () => Int\n): Int => {\n  compiler.agentMode = \"in\";\n  const c = compiler.curChar();\n  const pos0 = compiler.pos;\n  const bond = scanSimpleBond(compiler);\n  if (bond) {\n    createSimpleBond(compiler, bond, pos0);\n    return compiler.setState(stateAgentMid);\n  }\n  if (c >= \"A\" && c <= \"Z\") {\n    // Извлечь первый заглавный символ элемента. Следующие должны быть маленькими\n    compiler.elementStartPos = compiler.pos;\n    return compiler.setState(stateElement, 1);\n  }\n  switch (c) {\n    case \"`\":\n      compiler.setAltFlag();\n      return compiler.setState(stateAgentMid, 1);\n    case \"{\":\n      return compiler.setState(stateCustom, 1);\n    case '\"':\n      return compiler.setState(stateCommentIn, 1);\n    case \";\":\n      closeChain(compiler);\n      return compiler.setState(stateAgentSpace, 1);\n    case \":\":\n      return createLabel(compiler);\n    case \"#\":\n      return compiler.setState(stateNodeRef, 1);\n    case \"^\":\n      return compiler.setState(stateCharge, 1);\n    case \"$\":\n      return compiler.setState(stateFuncName, 1);\n    case \"<\":\n      return openBranch(compiler);\n    case \">\":\n      return closeBranch(compiler);\n    case \"(\":\n      return openParentheses(compiler);\n    case \"[\":\n      return openSquareBracket(compiler);\n    case \")\":\n    case \"]\":\n    case \"}\":\n      return closeBracketShort(compiler);\n    case \"*\":\n      return star(compiler);\n    case \",\":\n      return comma(compiler);\n    case \"_\":\n      return compiler.setState(stateUniBond, 1);\n    case \"c\":\n      getNodeForced(compiler, true);\n      return compiler.setState(stateAgentMid, 1);\n\n    default:\n      return onDefault();\n  }\n};\n\nconst comma = (compiler: ChemCompiler): Int => {\n  addNodeItem(compiler, instChemComma);\n  return compiler.setState(stateAgentMid, 1);\n};\n","import { Double, Int } from \"../../types\";\nimport { ChemBond } from \"../../core/ChemBond\";\nimport { ifDef } from \"../../utils/ifDef\";\nimport { makeBondStep } from \"./bondSimple\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { getLastBond } from \"./bondUniversal\";\nimport { is0 } from \"../../math\";\n\n// -1, `-1, 0, 0, 1, `1\nconst horizAngles: Double[] = [-60.0, 120.0, 0.0, 0.0, 60.0, -120.0];\n\nconst newAngleDeg = (bond: ChemBond): Double =>\n  horizAngles[(bond.slope + 1) * 2 + (bond.isNeg ? 1 : 0)]!;\n\nconst correct = (bond: ChemBond, length?: Double) => {\n  bond.dir = makeBondStep(newAngleDeg(bond), length ?? bond.dir!.length());\n  bond.isCorr = true;\n  ifDef(bond.nodes[1], (it) => {\n    it.pt = bond.calcPt();\n  });\n};\n\nconst correctPrev = (\n  compiler: ChemCompiler,\n  prevBond: ChemBond,\n  length?: Double\n) => {\n  if (prevBond.nodes[1]?.fixed) {\n    return;\n  }\n  const corrNode = prevBond.nodes[1];\n  if (!corrNode) {\n    correct(prevBond, length);\n    return;\n  }\n  const { subChain } = corrNode;\n  const oldPos = corrNode.pt;\n  correct(prevBond, length);\n  const step = corrNode.pt.minus(oldPos);\n  const allNodes = compiler.curAgent!.nodes;\n  const dstNodes = allNodes\n    .slice(corrNode.index + 1)\n    .filter((it) => it.subChain === subChain);\n  dstNodes.reverse();\n  dstNodes.forEach((it) => {\n    it.pt.iadd(step);\n  });\n};\n\nexport const autoCorrection = (\n  compiler: ChemCompiler,\n  bond: ChemBond,\n  slopeSign: Int\n) => {\n  if (compiler.varSlope !== 0.0) {\n    // Если указан угол наклона при помощи $slope(x)\n    return;\n  }\n  const prevBond = getLastBond(compiler);\n  // Если нет предыдущей связи, то коррекция невозможна\n  if (!prevBond) return;\n  if (!prevBond.isAuto) {\n    // Коррекция возможно только если предыдущая связь создана из простого описания\n    return;\n  }\n\n  const { dir } = prevBond;\n  if (prevBond.isAuto && dir && is0(dir.y) && slopeSign !== 0) {\n    // Стыковка горизонтальной связи с наклонной\n    correct(bond, compiler.varLength);\n    return;\n  }\n  if (\n    prevBond.slope !== 0 &&\n    prevBond.isCorr &&\n    slopeSign !== 0 &&\n    prevBond.isNeg !== bond.isNeg\n  ) {\n    // Стыковка предыдущей откорректированной наклонной связи\n    // с тем же наклоном, но в обратном направлении\n    correct(bond, compiler.varLength);\n    return;\n  }\n  // Варианты с коррекцией предыдущей связи\n  if (\n    prevBond.slope !== 0 &&\n    !prevBond.isCorr &&\n    slopeSign !== 0 &&\n    prevBond.isNeg !== bond.isNeg &&\n    prevBond.slope !== bond.slope\n  ) {\n    correctPrev(compiler, prevBond);\n    correct(bond, compiler.varLength);\n    return;\n  }\n  // Стыковка с горизонтальной связью\n  if (prevBond.slope !== 0 && !prevBond.isCorr && bond.isHorizontal()) {\n    correctPrev(compiler, prevBond);\n  }\n};\n","import { ChemCompiler } from \"../ChemCompiler\";\nimport { ChemBond } from \"../../core/ChemBond\";\nimport { ChemNode } from \"../../core/ChemNode\";\nimport { ChemBracketEnd } from \"../../core/ChemBracket\";\nimport { closeNode, openNode } from \"./node\";\nimport { lastItem } from \"../../utils/lastItem\";\nimport { removeItem } from \"../../utils/removeItem\";\nimport { applyMiddlePoints } from \"./middlePoint\";\n\nexport const createCommonBond = (compiler: ChemCompiler): ChemBond => {\n  const bond = new ChemBond();\n  bond.color = compiler.varColor;\n  return bond;\n};\n\nexport const changeBondToHard = (compiler: ChemCompiler, bond: ChemBond) => {\n  bond.soft = false;\n  compiler.chainSys.changeBondToHard(bond);\n};\n\nexport const bindNodeToBond = (\n  compiler: ChemCompiler,\n  node: ChemNode,\n  chemBond: ChemBond\n) => {\n  compiler.curNode = node;\n\n  chemBond.nodes[1] = node;\n  const node0 = chemBond.nodes[0];\n  const auto0: boolean = node0?.autoMode ?? false;\n  // Если хотя бы один узел автоматический, то связь не мягкая\n  if (chemBond.soft && (auto0 || node.autoMode)) {\n    changeBondToHard(compiler, chemBond);\n  }\n  if (chemBond.soft) {\n    compiler.nodesBranch.onSubChain();\n    compiler.nodesBranch.onNode(node);\n  }\n  compiler.curBond = undefined;\n  // Для жесткой связи можно вычислить координаты второго узла относительно первого\n  const { dir } = chemBond;\n  if (dir && node0 && !chemBond.soft && !dir.isZero()) {\n    node.pt = node0.pt.plus(dir);\n  }\n};\n\nexport const bindNodeToCurrentBond = (\n  compiler: ChemCompiler,\n  node?: ChemNode\n) => {\n  const { curBond } = compiler;\n  if (curBond) {\n    bindNodeToBond(compiler, node ?? openNode(compiler, true), curBond);\n  }\n};\n\nexport const findBondBetweenNodes = (\n  compiler: ChemCompiler,\n  nodeA: ChemNode,\n  nodeB: ChemNode\n): ChemBond | undefined =>\n  compiler.curAgent!.bonds.find((it) => {\n    const { nodes } = it;\n    return (\n      !it.middlePoints &&\n      nodes.length === 2 &&\n      ((nodes[0] === nodeA && nodes[1] === nodeB) ||\n        (nodes[0] === nodeB && nodes[1] === nodeA))\n    );\n  });\n\nexport const getNodeForBondStart = (\n  compiler: ChemCompiler,\n  bond?: ChemBond\n): ChemNode => {\n  const { curNode } = compiler;\n  if (curNode) {\n    // Если текущий узел есть, то использовать его\n    return curNode;\n  }\n  // Возможна ситуация, когда связь стыкуется к ранее закрытой скобке\n  const lastCmd = lastItem(compiler.curAgent!.commands);\n  const bracketEnd: ChemBracketEnd | undefined =\n    lastCmd instanceof ChemBracketEnd ? lastCmd : undefined;\n  if (bracketEnd) {\n    const { nodeIn } = bracketEnd;\n    if (nodeIn) {\n      bracketEnd.bond = bond;\n      return nodeIn;\n    }\n  }\n  return openNode(compiler, true);\n};\n\n// Предполагается, что свойства bond уже заполнены. В первую очередь: dir, n, soft\nexport const onOpenBond = (\n  compiler: ChemCompiler,\n  bond: ChemBond,\n  begin: number\n) => {\n  if (compiler.srcMap) {\n    compiler.srcMap.push({ begin, end: compiler.pos, obj: bond });\n  }\n  const oldNode = getNodeForBondStart(compiler, bond);\n  closeNode(compiler);\n  applyMiddlePoints(compiler, bond);\n  if (bond.n === 2.0 && !bond.align) {\n    bond.align = compiler.varAlign;\n  }\n  bond.nodes[0] = oldNode;\n  if (bond.isAuto && oldNode.autoMode) {\n    // Если первый узел простой связи является автоматическим, то связь не мягкая\n    bond.soft = false;\n  }\n  bond.color = compiler.varColor;\n  /*\n    Здесь нельзя делать предположений о том, какой будет узел на другом конце.\n    Хотя вектор уже известен, но далее может появиться ссылка и связь может стать переходной.\n     */\n  compiler.curAgent!.addBond(bond);\n  compiler.curBond = bond;\n  compiler.chainSys.addBond(bond);\n};\n\nexport const mergeBonds = (\n  compiler: ChemCompiler,\n  oldBond: ChemBond,\n  newBond: ChemBond,\n  newNode: ChemNode\n) => {\n  // При наложении связей от новой только добавляется кратность.\n  // Остальные характеристики значения не имеют\n  oldBond.n += newBond.n;\n  compiler.curNode = newNode;\n  compiler.curBond = oldBond;\n  // узел фиксируется, чтобы его не сместило при автокоррекции\n  newNode.fixed = true;\n  newBond.isAuto = false;\n  newBond.soft = false;\n  newBond.nodes[1] = newNode;\n\n  // Конечные координаты отрезка должны совпадать со старой связью.\n  // Но направление может поменяться т.к. это имеет значение для отрисовки следующих связей\n  const [nbn0, nbn1] = newBond.nodes;\n  if (nbn0 && nbn1) {\n    newBond.dir = nbn1.pt.minus(nbn0.pt);\n  }\n\n  compiler.chainSys.addBond(newBond);\n  removeItem(compiler.curAgent!.bonds, newBond);\n  removeItem(compiler.curAgent!.commands, newBond);\n};\n","import { Char, Double, Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { isDigit } from \"../parse/isDigit\";\nimport { createCommonBond, onOpenBond } from \"./bondCommon\";\nimport { createPolygonStep } from \"./bondUniversal\";\nimport { scanBondSuffix } from \"../parse/scanBondSuffix\";\n\nexport const createPolygonalBond = (compiler: ChemCompiler) => {\n  const beginPos = compiler.pos - 1;\n  const mode: Char = compiler.curChar();\n  let multiplicity = 1;\n  let sign: Int = 0;\n  if (mode === \"p\") sign = 1;\n  else if (mode === \"q\") sign = -1;\n  if (!sign) {\n    // Эта ошибка не может возникнуть из-за ошибки пользователя. Только если ошибка в компиляторе.\n    compiler.error(\"Invalid polygonal bond descriptor [c]\", { c: mode });\n  }\n  compiler.pos++;\n  // Далее возможен повторный символ, который означает двойную связь\n  if (compiler.curChar() === mode) {\n    multiplicity++;\n    compiler.pos++;\n  }\n  // Далее возможно указание количество углов полигона (Если не указано, то 5)\n  let strCount = \"\";\n  while (isDigit(compiler.curChar())) {\n    strCount += compiler.curChar();\n    compiler.pos++;\n  }\n  const count: Int = +strCount || 0;\n\n  const bond = createCommonBond(compiler);\n  bond.n = multiplicity as Double;\n  bond.dir = createPolygonStep(\n    compiler,\n    sign * (count || 5),\n    compiler.varLength\n  );\n\n  scanBondSuffix(compiler, bond);\n  bond.tx = compiler.subStr(beginPos);\n\n  onOpenBond(compiler, bond, beginPos);\n};\n","import { Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { ChemNode } from \"../../core/ChemNode\";\nimport { getNodeForced } from \"./node\";\nimport { createCommonBond } from \"./bondCommon\";\n\nexport const findRingNodes = (\n  compiler: ChemCompiler\n): (ChemNode | undefined)[] | undefined => {\n  const curNode = getNodeForced(compiler, true);\n  const nodesFull = compiler.nodesBranch.nodes;\n  const nodes = nodesFull.slice(0, nodesFull.length - 1);\n  const j = nodes.lastIndexOf(curNode);\n  return j < 0 ? undefined : nodes.slice(j);\n};\n\nexport const findRingNodesEx = (\n  compiler: ChemCompiler\n): (ChemNode | undefined)[] =>\n  findRingNodes(compiler) ??\n  compiler.error(\"Cant close ring\", { pos: compiler.pos - 2 });\n\nexport const createRingBond = (compiler: ChemCompiler, deltaPos: Int) => {\n  compiler.pos += deltaPos;\n  const bond = createCommonBond(compiler);\n  bond.nodes = findRingNodesEx(compiler);\n  bond.n = 1.0;\n  bond.tx = \"o\";\n  bond.ext = \"o\";\n  bond.isCycle = true;\n  compiler.curAgent!.addBond(bond);\n  compiler.curBond = undefined;\n};\n","import { Double, Int } from \"../../types\";\nimport { pointFromDeg, Point } from \"../../math/Point\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { ChemBond } from \"../../core/ChemBond\";\nimport { createCommonBond, onOpenBond } from \"./bondCommon\";\nimport { scanBondSuffix } from \"../parse/scanBondSuffix\";\nimport { autoCorrection } from \"./autoCorrection\";\n\n/**\n * Вектор связи.\n * @param angleDegree Точное значениеугла в градусах. Не допускается 0\n * @param length Длина из compiler.varLength. Значение 0 воспринимается как 1\n */\nexport const makeBondStep = (angleDegree: Double, length: Double) =>\n  pointFromDeg(angleDegree).times(length === 0.0 ? 1.0 : length);\n\n// 0=(кратность), 1=(угол в градусах), 2=(знак наклона), 3=(признак мягкой связи), 4=(текст)\nclass BondDef {\n  constructor(\n    public readonly n: Int,\n    public readonly angle: Int,\n    public readonly slope: Int,\n    public readonly soft: boolean = false,\n    public readonly text?: string\n  ) {}\n\n  create(compiler: ChemCompiler, bondId: string): ChemBond {\n    const bond = createCommonBond(compiler);\n    bond.tx = this.text ?? bondId;\n    bond.n = this.n as Double;\n    bond.soft = this.soft;\n    bond.dir = this.calcDir(compiler, bond);\n    bond.slope = this.slope;\n    bond.isAuto = true;\n    bond.isText = this.angle === 0 && this.slope === 0;\n    autoCorrection(compiler, bond, this.slope);\n    return bond;\n  }\n\n  calcDir(compiler: ChemCompiler, bond: ChemBond): Point {\n    let angleDegree: Double;\n    if (this.slope === 0) {\n      angleDegree = this.angle as Double;\n    } else {\n      bond.slope = this.slope;\n      const srcAngle = compiler.varSlope === 0.0 ? 30.0 : compiler.varSlope;\n      angleDegree = srcAngle * this.slope;\n    }\n    if (compiler.getAltFlag()) {\n      angleDegree += 180.0;\n      bond.isNeg = true;\n    }\n    return makeBondStep(angleDegree, compiler.varLength);\n  }\n}\n\nconst soft1 = new BondDef(1, 0, 0, true, \"-\");\nconst soft3 = new BondDef(3, 0, 0, true, \"≡\");\n\nconst bondDefDict: Record<string, BondDef> = {\n  \"-\": soft1,\n  \"–\": soft1, // special character u2013\n  \"−\": soft1, // u2212\n  \"=\": new BondDef(2, 0, 0, true),\n  \"%\": soft3,\n  \"≡\": soft3,\n  \"--\": new BondDef(1, 0, 0, false, \"-\"),\n  \"==\": new BondDef(2, 0, 0, false, \"=\"),\n  \"%%\": new BondDef(3, 0, 0, false, \"≡\"),\n  \"|\": new BondDef(1, 90, 0),\n  \"||\": new BondDef(2, 90, 0),\n  \"|||\": new BondDef(3, 90, 0),\n  \"/\": new BondDef(1, 0, -1),\n  \"//\": new BondDef(2, 0, -1),\n  \"///\": new BondDef(3, 0, -1),\n  \"\\\\\": new BondDef(1, 0, 1),\n  \"\\\\\\\\\": new BondDef(2, 0, 1),\n  \"\\\\\\\\\\\\\": new BondDef(3, 0, 1),\n};\n\nexport const scanSimpleBond = (\n  compiler: ChemCompiler\n): ChemBond | undefined => {\n  let bondId = \"\";\n  let bondDef: BondDef | null = null;\n  for (;;) {\n    const curBondId = bondId + compiler.curChar();\n    // Постепенно увеличиваем длину описания\n    // Как только получается несуществующее описание, то закончить цикл\n    const curBondDef = bondDefDict[curBondId];\n    if (!curBondDef) return bondDef?.create(compiler, bondId);\n    bondId = curBondId;\n    bondDef = curBondDef;\n    compiler.pos++;\n  }\n};\n\nexport const createSimpleBond = (\n  compiler: ChemCompiler,\n  bond: ChemBond,\n  begin: number\n) => {\n  scanBondSuffix(compiler, bond);\n  onOpenBond(compiler, bond, begin);\n};\n","import { Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { ChemNode } from \"../../core/ChemNode\";\nimport { findNodeEx } from \"./findNode\";\nimport { findRingNodes } from \"./bondRing\";\nimport { ifDef } from \"../../utils/ifDef\";\nimport { lastItem } from \"../../utils/lastItem\";\nimport { getNodeForced } from \"./node\";\nimport { ArgsInfo, scanArgs } from \"../parse/scanArgs\";\nimport { makeParamsDict, setBondProperties } from \"./bondUniversal\";\nimport { createCommonBond } from \"./bondCommon\";\n\nconst nodesInterval = (\n  compiler: ChemCompiler,\n  refs: string[],\n  pos: Int\n): ChemNode[] => {\n  const nodeA = findNodeEx(compiler, refs[0]!, pos);\n  const nodeB = findNodeEx(compiler, refs[1]!, pos + refs[0]!.length + 1);\n  const first = Math.min(nodeA.index, nodeB.index);\n  const last = Math.max(nodeA.index, nodeB.index);\n  return compiler.curAgent!.nodes.slice(first, last + 1);\n};\n\n/**\n * Список вершин, которые будут включены в сплайновую связь\n * Разделитель - точка с запятой\n * Можно указать интервал через двоеточие\n * Пример: #1:4;6\n */\nexport const parseNodesListDef = (\n  compiler: ChemCompiler,\n  value: string,\n  valuePos: Int\n): (ChemNode | undefined)[] | undefined => {\n  if (!value) {\n    return undefined;\n  }\n  const chunks = value.split(\";\");\n  let curPos = valuePos;\n  const nodes: ChemNode[] = chunks.reduce(\n    (srcList: ChemNode[], chunk: string) => {\n      const refs = chunk.split(\":\");\n      const dstList: ChemNode[] =\n        refs.length === 1\n          ? [...srcList, findNodeEx(compiler, chunk, curPos)]\n          : [...srcList, ...nodesInterval(compiler, refs, curPos)];\n\n      curPos += chunk.length + 1;\n      return dstList;\n    },\n    []\n  );\n  return nodes;\n};\n\ninterface NodesList {\n  nodes: (ChemNode | undefined)[];\n  isCycle: boolean;\n}\n\nconst autoLocateNodes = (compiler: ChemCompiler): NodesList =>\n  ifDef(findRingNodes(compiler), (nodes) => ({ nodes, isCycle: true })) ?? {\n    nodes: [...compiler.nodesBranch.nodes],\n    isCycle: false,\n  };\n\nconst checkCycledList = (nodes: (ChemNode | undefined)[]): NodesList =>\n  nodes.length > 1 && nodes[0] === lastItem(nodes)\n    ? { nodes: nodes.slice(0, nodes.length - 1), isCycle: true }\n    : { nodes, isCycle: false };\n\nexport const createSplineBond = (compiler: ChemCompiler) => {\n  // compiler.curChar == 's'\n  compiler.pos++;\n  getNodeForced(compiler, true);\n  let args: ArgsInfo;\n  if (compiler.curChar() !== \"(\") {\n    args = { args: [], argPos: [] };\n  } else {\n    compiler.pos++;\n    args = scanArgs(compiler);\n  }\n  const params = makeParamsDict(args.args, args.argPos);\n  const bond = createCommonBond(compiler);\n  bond.isCycle = false;\n  bond.tx = \"s\";\n  setBondProperties(compiler, bond, params);\n  const nodes: (ChemNode | undefined)[] | undefined = ifDef(\n    params[\"#\"],\n    (param) => parseNodesListDef(compiler, param.value, param.valuePos)\n  );\n  const nodesList: NodesList = nodes\n    ? checkCycledList(nodes)\n    : autoLocateNodes(compiler);\n  bond.nodes = nodesList.nodes;\n  bond.isCycle = \"o\" in params || nodesList.isCycle;\n  bond.ext = \"s\";\n  compiler.curAgent!.addBond(bond);\n  compiler.curBond = undefined;\n};\n","import { BondAlign, ChemBond } from \"../../core/ChemBond\";\nimport { Int, Char, Double } from \"../../types\";\nimport { Point, pointFromDeg, pointFromRad } from \"../../math/Point\";\nimport { rad2deg } from \"../../math/radians\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { listToDict } from \"../../utils/listToDict\";\nimport { findNodeEx } from \"./findNode\";\nimport { ifDef } from \"../../utils/ifDef\";\nimport { parseNum } from \"../parse/parseNum\";\nimport {\n  createCommonBond,\n  getNodeForBondStart,\n  onOpenBond,\n} from \"./bondCommon\";\n/*\nГеометрические параметры: A, a, L, P, p, x, y\nНесовместимы между собой: p, P, a, A. (В порядке убывания приоритета) Зато их можно комбинировать их с x, y\nL обычно использования совместно с A или a. Может быть использовано с P, хотя в этом мало пользы.\n */\n\nexport interface UniBondParam {\n  key: Char;\n  value: string;\n  valuePos: Int;\n}\n\ntype BondParams = Record<Char, UniBondParam | undefined>;\n\nexport const makeParamsDict = (args: string[], argPos: Int[]): BondParams => {\n  const paramsList = args\n    .map((descr, index) =>\n      !descr\n        ? null\n        : {\n            key: descr[0],\n            value: descr.substring(1),\n            valuePos: argPos[index]! + 1,\n          }\n    )\n    .filter((it) => it) as UniBondParam[];\n  return listToDict(paramsList, ({ key }) => key);\n};\n\nexport const calcPolygonDir = (prevDir: Point, count: Int): Point =>\n  pointFromRad(prevDir.polarAngle() + (Math.PI * 2) / count).times(\n    prevDir.length()\n  );\n\n/**\n * @param count Can be negative for counter-clock wise\n */\nexport const createPolygonStep = (\n  compiler: ChemCompiler,\n  count: Int,\n  defaultLength: Double\n): Point => {\n  const prevDir = getLastBond(compiler)?.dir;\n  return (\n    ifDef(prevDir, (it) => calcPolygonDir(it, count)) ??\n    new Point(defaultLength, 0.0)\n  );\n};\n\nexport const parseRefsList = (\n  compiler: ChemCompiler,\n  value: string,\n  pos: Int\n): Point => {\n  if (!value) {\n    compiler.error(\"Invalid node reference '[ref]'\", { ref: \"\", pos });\n  }\n  let paramPos = pos;\n  const points = value.split(\";\").map((ref) => {\n    const node = findNodeEx(compiler, ref, paramPos);\n    paramPos += ref.length + 1;\n    return node.pt;\n  });\n  const vectorSum = points.reduce((sum, vec) => sum.iadd(vec), new Point());\n  const midPt = vectorSum.times(1.0 / (points.length as Double));\n  // Здесь используется допущение, что перед любой универсальной связью проверяется наличие узла\n  const curNode =\n    compiler.curNode ?? compiler.error(\"Expected node before bond\", { pos });\n  return midPt.minus(curNode.pt);\n};\n\nexport const parseAxisCoordinate = (\n  compiler: ChemCompiler,\n  isX: boolean,\n  value: string,\n  pos: Int\n): Double => {\n  if (!value.startsWith(\"#\")) return parseNum(compiler, value, pos);\n\n  const center = parseRefsList(compiler, value.slice(1), pos + 1);\n  return isX ? center.x : center.y;\n};\n\nexport const getLastBond = (compiler: ChemCompiler): ChemBond | undefined =>\n  // compiler.curBond\n  compiler.chainSys.getLastBond();\n\nexport const calcBondDirection = (\n  compiler: ChemCompiler,\n  params: BondParams\n): Point => {\n  const getLength = (): Double => {\n    const it = params.L;\n    return it ? parseNum(compiler, it.value, it.valuePos) : compiler.varLength;\n  };\n\n  const fromAngle = (a: Double): Point => pointFromDeg(a).times(getLength());\n\n  const getPrevBond = (): ChemBond | undefined => getLastBond(compiler);\n\n  const dir: Point =\n    ifDef(params.p, (it) => parseRefsList(compiler, it.value, it.valuePos)) ??\n    ifDef(params.P, (it) => {\n      // Polygonal bond\n      const n: Int =\n        it.value === \"\" ? 5 : parseNum(compiler, it.value, it.valuePos);\n      return createPolygonStep(compiler, n || 5, getLength());\n    }) ??\n    ifDef(params.a, (aParam) => {\n      const a =\n        ifDef(getPrevBond()?.dir, (it) => rad2deg(it.polarAngle())) ?? 0.0;\n      return fromAngle(a + parseNum(compiler, aParam.value, aParam.valuePos));\n    }) ??\n    ifDef(params.A, (it) =>\n      fromAngle(parseNum(compiler, it.value, it.valuePos))\n    ) ??\n    ifDef(params.L, () => fromAngle(0)) ??\n    new Point(0, 0);\n\n  ifDef(params.x, (it) => {\n    dir.x += parseAxisCoordinate(compiler, true, it.value, it.valuePos);\n  });\n  ifDef(params.y, (it) => {\n    dir.y += parseAxisCoordinate(compiler, false, it.value, it.valuePos);\n  });\n  return dir;\n};\n\nconst doubleBondSuffizes = { x: 1, l: 1, r: 1, m: 1 };\n\nexport const parseBondMultiplicity = (\n  compiler: ChemCompiler,\n  bond: ChemBond,\n  param: UniBondParam\n) => {\n  const { value } = param;\n  const getMode = (): Char => value[1]!.toLowerCase();\n  if (\n    value.length === 2 &&\n    value[0] === \"2\" &&\n    getMode() in doubleBondSuffizes\n  ) {\n    if (getMode() === \"x\") {\n      bond.setCross();\n    } else {\n      bond.align = getMode() as BondAlign;\n    }\n    bond.n = 2.0;\n  } else if (!value) {\n    bond.n = 1.0;\n  } else {\n    bond.n = parseNum(compiler, value, param.valuePos);\n  }\n};\n\nconst styleSuffixes = { m: 1, l: 1, r: 1 };\n\nexport const parseStyle = (bond: ChemBond, value: string) => {\n  if (value && value[value.length - 1]!.toLowerCase() in styleSuffixes) {\n    bond.align = value[value.length - 1]!.toLowerCase() as BondAlign;\n    bond.style = value.slice(0, value.length - 1);\n  } else {\n    bond.style = value;\n  }\n};\n\nexport const setBondProperties = (\n  compiler: ChemCompiler,\n  bond: ChemBond,\n  params: BondParams\n) => {\n  ifDef(params.N, (it) => parseBondMultiplicity(compiler, bond, it));\n  ifDef(params.h, (it) => {\n    bond.soft = true; // <- this feature of ver 0.0\n    // h+, h- : feature of ver 2.0\n    const connection = (sign: -1 | 1) => {\n      bond.n = 0;\n      if (bond.dir && bond.dir.x === 0) {\n        bond.dir.x = sign * 0.02;\n      }\n    };\n    if (it.value === \"+\") {\n      connection(1);\n    } else if (it.value === \"-\") {\n      connection(-1);\n    }\n  });\n  ifDef(params.T, (it) => {\n    bond.tx = it.value;\n  });\n  if (bond.n === 1.0 && \"H\" in params) bond.setHydrogen();\n  ifDef(params.C, (it) => {\n    // Сoordination chemical bond\n    switch (it.value) {\n      case \"-\":\n        bond.arr0 = true; // _(C-)   A<---B\n        break;\n      case \"+\": // _(C+)   A<-->B\n        bond.arr0 = true;\n        bond.arr1 = true;\n        break;\n      default: // _(C)   A--->B\n        bond.arr1 = true;\n        break;\n    }\n  });\n  if (params[\"<\"]) {\n    bond.arr0 = true;\n  }\n  if (params[\">\"]) {\n    bond.arr1 = true;\n  }\n  if (params[\"~\"]) {\n    bond.style = \"~\";\n  }\n  ifDef(params.S, (it) => parseStyle(bond, it.value));\n\n  const setWidth = (id: string, sign: Int, isGlobal: boolean) => {\n    const makePair = (): [Int | null, Int | null] => {\n      switch (id) {\n        case \"+\":\n          return [0, sign];\n        case \"-\":\n          return [sign, 0];\n        case \"0\":\n        case \"1\":\n          return [0, 0];\n        case \"2\":\n          return [sign, sign];\n        default:\n          return [null, null];\n      }\n    };\n    const [first, second] = makePair();\n    bond.w0 = first ?? compiler.curWidth;\n    bond.w1 = second ?? compiler.curWidth;\n    if (isGlobal) {\n      compiler.curWidth = second ?? compiler.curWidth;\n    }\n    return true;\n  };\n  const [id, sign, isGlobal] = ifDef(params.w, (it) => [it.value, 1, false]) ??\n    ifDef(params.d, (it) => [it.value, -1, false]) ??\n    ifDef(params.W, (it) => [it.value, 1, true]) ??\n    ifDef(params.D, (it) => [it.value, -1, true]) ?? [\"\", 0, false];\n  setWidth(id, sign, isGlobal);\n};\n\nexport const createUniversalBond = (\n  compiler: ChemCompiler,\n  args: string[],\n  argPos: Int[],\n  begin: number\n) => {\n  const bond = createCommonBond(compiler);\n  if (!compiler.curNode) {\n    compiler.curNode = getNodeForBondStart(compiler, bond);\n  }\n  const params = makeParamsDict(args, argPos);\n  bond.dir = calcBondDirection(compiler, params);\n  setBondProperties(compiler, bond, params);\n  onOpenBond(compiler, bond, begin);\n};\n","/*\n\nСкобки вкладываются совместно с ветками. То есть, если открыта ветка, а в ней скобка,\nто сначала закрывается скобка, а потом ветка.\n\nУ скобок могут быть входящая и исходящая связь, но не обязательно.\n(NH4)2SO4 - нет связей\n\nH-(CH2)4-H - Есть обе связи. Причем они мягкие. Поэтому рисуются не к узлу, а к скобке.\n\nH^+_(x1.4,N0)[Cu^+<`|hBr^-><|hBr^->]^-\n     +  Br +\n     |  |  |\n  H--|--Cu |\n     |  |  |\n     +  Br +\nЗдесь есть только входящая связь, соединяющая узел снаружи и внутри скобки\n\nКроме того, если после скобок объявить ветки, то можно сделать несколько исходящих связей.\n */\nimport { Int } from \"../../types\";\nimport { StackItem } from \"./StackItem\";\nimport { ChemBracketBegin, ChemBracketEnd } from \"../../core/ChemBracket\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { ChemNode } from \"../../core/ChemNode\";\nimport { openBranch } from \"./branch\";\nimport { closeNode, openNode } from \"./node\";\nimport { ChemMulEnd } from \"../../core/ChemMul\";\nimport { lastItem } from \"../../utils/lastItem\";\nimport { ifDef } from \"../../utils/ifDef\";\nimport { checkMulBeforeBracket } from \"./multipier\";\nimport { scanPostItem } from \"../parse/scanPostItem\";\nimport { stateAgentMid } from \"../state/stateAgentMid\";\nimport { stateBracketBegin } from \"../state/stateBracketBegin\";\n\nclass BracketDecl extends StackItem {\n  constructor(pos: Int, public readonly begin: ChemBracketBegin) {\n    super(pos);\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  override msgInvalidClose(): string {\n    return \"It is necessary to close the bracket\";\n  }\n}\n\nexport const openParentheses = (compiler: ChemCompiler): Int => {\n  // Здесь возможны следующие случаи\n  // - (* - открыть ветку\n  // - скобка для конструкций типа Ca(OH)2\n\n  // * степень окисления текущего элемента узла тоже в круглых скобках,\n  // но допустимо только после описания элемента. Поэтому см statePostItem\n  compiler.pos++;\n  if (compiler.curChar() === \"*\") {\n    return openBranch(compiler);\n  }\n  openBracket(compiler, \"(\", compiler.pos - 1);\n  return compiler.setState(stateBracketBegin);\n};\n\nexport const openSquareBracket = (compiler: ChemCompiler): Int => {\n  openBracket(compiler, \"[\", compiler.pos++);\n  return compiler.setState(stateBracketBegin);\n};\n\nexport const openBrace = (compiler: ChemCompiler): Int => {\n  openBracket(compiler, \"{\", compiler.pos - 1);\n  compiler.pos++;\n  return compiler.setState(stateBracketBegin);\n};\n\nconst openBracket = (compiler: ChemCompiler, text: string, pos: Int) => {\n  const begin = new ChemBracketBegin(text);\n  begin.color = compiler.varColor;\n  compiler.mulCounter.onOpenBracket();\n  compiler.curAgent!.commands.push(begin);\n  compiler.push(new BracketDecl(pos, begin));\n  compiler.bracketsCtrl.onBracket(begin);\n  if (compiler.varPadding.length) {\n    begin.padding = compiler.varPadding;\n    compiler.varPadding = [];\n  }\n  if (compiler.curBond) {\n    begin.bond = compiler.curBond;\n    // eslint-disable-next-line prefer-destructuring\n    begin.nodes[0] = begin.bond.nodes[0];\n  } else {\n    begin.nodes[0] = compiler.curNode;\n    closeNode(compiler);\n    compiler.chainSys.createSubChain();\n  }\n};\n\nconst bracketPairs: Record<string, string> = { \"(\": \")\", \"[\": \"]\", \"{\": \"}\" };\n\nexport const getNodeForBracketEnd = (compiler: ChemCompiler): ChemNode => {\n  const { curNode } = compiler;\n  if (curNode) {\n    return curNode;\n  }\n  const { commands } = compiler.curAgent!;\n  let lastCmd = lastItem(commands);\n  if (lastCmd instanceof ChemMulEnd) {\n    lastCmd = commands[commands.length - 2];\n  }\n  if (lastCmd instanceof ChemBracketEnd) {\n    const { nodeIn } = lastCmd;\n    if (nodeIn) return nodeIn;\n  }\n  return openNode(compiler, true);\n};\n\nexport const closeBracket = (\n  compiler: ChemCompiler,\n  text: string,\n  pos: Int\n): ChemBracketEnd =>\n  ifDef(compiler.pop(), (decl) => {\n    if (decl instanceof BracketDecl) {\n      const needCloseText: string =\n        bracketPairs[decl.begin.text] ??\n        // Такая ошибка не должна возникнуть, если правильно заполнен словарь bracketPairs\n        compiler.error(\"Invalid bracket pair [s]\", {\n          s: decl.begin.text + text,\n        });\n      if (needCloseText !== text) {\n        // Тип открытой скобки должен соответствовать типу закрытой\n        compiler.error(\"Expected [must] instead of [have]\", {\n          must: needCloseText,\n          have: text,\n          pos,\n          pos0: decl.pos,\n        });\n      }\n\n      checkMulBeforeBracket(compiler);\n      compiler.mulCounter.onCloseBracket();\n      const bracketEnd = new ChemBracketEnd(\n        text,\n        decl.begin,\n        getNodeForBracketEnd(compiler)\n      );\n      const { commands } = compiler.curAgent!;\n      commands.push(bracketEnd);\n      decl.begin.end = bracketEnd;\n      closeNode(compiler);\n      compiler.chargeOwner = bracketEnd;\n      compiler.bracketsCtrl.onBracket(bracketEnd);\n      return bracketEnd;\n    }\n    return compiler.error(\"Cant close bracket before branch\", {\n      pos,\n      pos0: decl.pos + 1,\n    });\n  }) ?? compiler.error(\"Invalid bracket close\", { pos });\n\nexport const closeBracketShort = (compiler: ChemCompiler): Int => {\n  const ch = compiler.curChar();\n  let step = 1;\n  if (ch === \"}\" && compiler.nextChar() === \"}\") {\n    step = 2;\n  }\n  const end = closeBracket(compiler, ch, compiler.pos);\n  compiler.pos += step;\n  scanPostItem(compiler, (it) => {\n    end.n = it;\n  });\n  return compiler.setState(stateAgentMid);\n};\n","import { Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { StackItem } from \"./StackItem\";\nimport { ChemNode } from \"../../core/ChemNode\";\nimport { ChemBond } from \"../../core/ChemBond\";\nimport { closeNode } from \"./node\";\nimport { bindNodeToCurrentBond, getNodeForBondStart } from \"./bondCommon\";\nimport { stateAgentMid } from \"../state/stateAgentMid\";\n\nexport class BranchDecl extends StackItem {\n  constructor(\n    pos: Int,\n    public readonly node: ChemNode,\n    public readonly bond?: ChemBond\n  ) {\n    super(pos);\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  override msgInvalidClose() {\n    return \"It is necessary to close the branch\";\n  }\n}\n\n// Указатель установлен на символ < или * для случая (*\nexport const openBranch = (compiler: ChemCompiler): Int => {\n  const curNode: ChemNode = getNodeForBondStart(compiler, undefined);\n  compiler.push(new BranchDecl(compiler.pos, curNode, compiler.curBond));\n  compiler.chainSys.onBranchBegin();\n  compiler.nodesBranch.onBranchBegin();\n  return compiler.setState(stateAgentMid, 1);\n};\n\nexport const closeBranch = (compiler: ChemCompiler): Int => {\n  const decl = compiler.pop();\n  if (decl) {\n    if (decl instanceof BranchDecl) {\n      bindNodeToCurrentBond(compiler, compiler.curNode);\n      closeNode(compiler);\n\n      compiler.curNode = decl.node;\n      compiler.chainSys.onBranchEnd();\n      compiler.nodesBranch.onBranchEnd();\n      compiler.chainSys.setCurNode(decl.node);\n\n      return compiler.setState(stateAgentMid, 1);\n    }\n    // Ошибка: ветка закрывается до того, как закрыта скобка...\n    compiler.error(\"Cant close branch before bracket\", {\n      pos: compiler.pos,\n      pos0: decl.pos + 1,\n    });\n  }\n  return compiler.error(\"Invalid branch close\", { pos: compiler.pos });\n};\n\nexport const checkBranch = (compiler: ChemCompiler) => {\n  const it = compiler.pop();\n  if (it) {\n    compiler.error(it.msgInvalidClose(), { pos: it.pos });\n  }\n};\n","import { ChemCompiler } from \"../ChemCompiler\";\nimport { ChemOp } from \"../../core/ChemOp\";\nimport { closeEntity, onCreateEntity } from \"./entity\";\n\nexport class OpDef {\n  constructor(\n    public readonly src: string,\n    public readonly dst: string | null = null,\n    public readonly div: boolean = false\n  ) {}\n\n  opCode() {\n    return this.dst ?? this.src;\n  }\n}\n\n// <-- must be before <-\n\nexport const opsList: OpDef[] = [\n  new OpDef(\"+\"),\n  new OpDef(\"-->\", \"—→\", true),\n  new OpDef(\"--|>\", \"—→\", true),\n  new OpDef(\"->\", \"→\", true),\n  new OpDef(\"®\", \"→\", true),\n  new OpDef(\"→\", null, true),\n  new OpDef(\"=\", null, true),\n  new OpDef(\"↔\", null, true),\n  new OpDef(\"<-->\", \"←→\", true), // v2.2\n  new OpDef(\"<->\", \"↔\", true),\n  new OpDef(\"<=>\", \"\\u21CC\", true),\n  new OpDef(\"<==>\", \"\\u21CC\", true),\n  new OpDef(\"*\", \"∙\"), // deprecated\n  new OpDef(\"!=\", \"≠\", true),\n  new OpDef(\"<|--\", \"←—\", true), // v2.2\n  new OpDef(\"<--\", \"←—\", true), // v2.2\n  new OpDef(\"<-\", \"←\", true), // &#x2190; v2.2\n];\n\nexport const onCloseOp = (compiler: ChemCompiler) => {\n  compiler.curOp = undefined;\n};\n\nexport const createChemOp = (compiler: ChemCompiler, def: OpDef) => {\n  const { preComm } = compiler;\n  closeEntity(compiler);\n  const op = new ChemOp(def.src, def.opCode(), def.div);\n  op.color = compiler.varColor;\n  op.commentPre = preComm;\n  if (compiler.srcMap) {\n    compiler.entityBegin =\n      compiler.eject(\"preCommPos\") ?? compiler.pos - def.src.length;\n  }\n  onCreateEntity(compiler, op);\n  compiler.curOp = op;\n  if (def.div) {\n    compiler.curPart++;\n  }\n};\n","import { ChemCompiler } from \"../ChemCompiler\";\nimport { ifDef } from \"../../utils/ifDef\";\n\nexport const getItemColor = (compiler: ChemCompiler): string | undefined =>\n  ifDef(compiler.varItemColor1, (it) => {\n    compiler.varItemColor1 = undefined;\n    return it;\n  }) ??\n  compiler.varItemColor ??\n  compiler.varColor;\n\nexport const getAtomColor = (compiler: ChemCompiler): string | undefined =>\n  ifDef(compiler.varAtomColor1, (it) => {\n    compiler.varAtomColor1 = undefined;\n    return it;\n  }) ?? compiler.varAtomColor;\n","import { ChemCompiler } from \"../ChemCompiler\";\nimport { Int } from \"../../types\";\nimport { scanId } from \"../parse/scanId\";\nimport { getNodeForced } from \"./node\";\nimport { stateAgentMid } from \"../state/stateAgentMid\";\n\n// Condition of call: compiler.curChar() == ':'\nexport const createLabel = (compiler: ChemCompiler): Int => {\n  compiler.pos++;\n  const it = scanId(compiler);\n  if (it) {\n    compiler.references[it] = getNodeForced(compiler, true);\n  } else compiler.error(\"Invalid label\", { pos: compiler.pos });\n  return compiler.setState(stateAgentMid);\n};\n","import { ChemCompiler } from \"../ChemCompiler\";\nimport { ChemObj } from \"../../core/ChemObj\";\nimport { onCloseOp } from \"./chemOp\";\nimport { onCloseAgent } from \"./agent\";\n\nexport const onCreateEntity = (compiler: ChemCompiler, entity: ChemObj) => {\n  compiler.curEntity = entity;\n  compiler.expr.entities.push(entity);\n};\n\nexport const closeEntity = (compiler: ChemCompiler) => {\n  if (compiler.curEntity) {\n    compiler.curEntity = undefined;\n    onCloseAgent(compiler);\n    onCloseOp(compiler);\n  }\n  compiler.preComm = undefined;\n};\n","import { Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { ChemNode } from \"../../core/ChemNode\";\nimport { findElement } from \"../../core/PeriodicTable\";\n\nexport const findNode = (\n  compiler: ChemCompiler,\n  ref: string\n): ChemNode | undefined => {\n  const { nodes } = compiler.curAgent!;\n  const n = +ref;\n  if (!Number.isNaN(n)) {\n    return nodes[n < 0 ? n + nodes.length : n - 1];\n  }\n  // Возможно, метка...\n  // Если была указана метка, совпадающая с обозначением элемента, то метка имеет приоритет выше\n  const node = compiler.references[ref];\n  if (node) return node;\n\n  // если указан элемент\n  const elem = findElement(ref);\n  if (elem) {\n    const elemNode = nodes.find(\n      (it) => it.items.length === 1 && it.items[0]!.obj === elem\n    );\n    if (elemNode) return elemNode;\n  }\n  return undefined;\n};\n\nexport const findNodeEx = (\n  compiler: ChemCompiler,\n  ref: string,\n  pos: Int\n): ChemNode => {\n  const node = findNode(compiler, ref);\n  if (!node) compiler.error(\"Invalid node reference '[ref]'\", { ref, pos });\n  return node;\n};\n","import { ChemCompiler } from \"../ChemCompiler\";\nimport { ChemNodeItem } from \"../../core/ChemNodeItem\";\nimport { lastItem } from \"../../utils/lastItem\";\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function\nexport const closeItem = (compiler: ChemCompiler) => {};\n\nexport const getLastItem = (compiler: ChemCompiler): ChemNodeItem | undefined =>\n  lastItem(compiler.curNode?.items);\n","/*\nСредние точки ставятся перед описанием связи.\nВ итоге общий вектор связи является суммой средних точек и самой связи\nСвязь, имеющая средние точки, не может быть мягкой\n */\n\nimport { Point } from \"../../math/Point\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { ChemBond } from \"../../core/ChemBond\";\nimport { getNodeForced } from \"./node\";\nimport { scanArgs } from \"../parse/scanArgs\";\nimport { calcBondDirection, makeParamsDict } from \"./bondUniversal\";\n\nexport const applyMiddlePoints = (compiler: ChemCompiler, bond: ChemBond) => {\n  const { middlePoints } = compiler;\n  if (middlePoints.length === 0) {\n    return;\n  }\n  const bondPoints: Point[] = middlePoints.map((it) => it.pt);\n  bondPoints.push(bond.dir!);\n  bond.middlePoints = bondPoints;\n  bond.dir = bondPoints.reduce((acc, pt) => acc.iadd(pt), new Point());\n  bond.soft = false;\n  middlePoints.length = 0;\n};\n\nexport const checkMiddlePoints = (compiler: ChemCompiler) => {\n  if (compiler.middlePoints.length !== 0) {\n    compiler.error(\"Invalid middle point\", {\n      pos: compiler.middlePoints[0]!.pos,\n    });\n  }\n};\n\nexport const createMiddlePoint = (compiler: ChemCompiler) => {\n  // compiler.curChar() == 'm'\n  const startPos = compiler.pos - 1;\n  compiler.pos++;\n  if (compiler.curChar() !== \"(\") {\n    compiler.error(\"Expected '(' after [S]\", {\n      pos: compiler.pos - 1,\n      S: \"_m\",\n    });\n  }\n  getNodeForced(compiler, true);\n  compiler.pos++;\n  const args = scanArgs(compiler);\n  const params = makeParamsDict(args.args, args.argPos);\n  const dir = calcBondDirection(compiler, params);\n  compiler.middlePoints.push({ pt: dir, pos: startPos });\n};\n","import { ChemCompiler } from \"../ChemCompiler\";\nimport { ChemK } from \"../../core/ChemK\";\nimport { ChemMul, ChemMulEnd } from \"../../core/ChemMul\";\nimport { closeNode, openNode } from \"./node\";\nimport { ifDef } from \"../../utils/ifDef\";\n\nexport const startMul = (\n  compiler: ChemCompiler,\n  k: ChemK,\n  isFirst: boolean\n) => {\n  const mul = new ChemMul(k, isFirst, compiler.varColor);\n  const { curNode, curBond } = compiler;\n  // Если нет узла, но есть связь, то надо создать автоузел, закрывающий связь.\n  mul.nodes[0] = curNode || ifDef(curBond, () => openNode(compiler, true));\n\n  closeNode(compiler);\n  compiler.chainSys.closeSubChain();\n  compiler.curAgent!.commands.push(mul);\n  compiler.mulCounter.create(mul);\n  compiler.bracketsCtrl.clear();\n};\n\nexport const stopMul = (compiler: ChemCompiler, mul: ChemMul) => {\n  compiler.mulCounter.close();\n  compiler.curAgent!.commands.push(new ChemMulEnd(mul));\n};\n\nexport const checkMulBeforeBracket = (compiler: ChemCompiler) => {\n  const it = compiler.mulCounter.getMulForBracket();\n  if (it) {\n    stopMul(compiler, it);\n  }\n};\n\nexport const checkMul = (compiler: ChemCompiler) => {\n  const it = compiler.mulCounter.getMulForced();\n  if (it) {\n    stopMul(compiler, it);\n  }\n};\n","import { Double, Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { ChemNode } from \"../../core/ChemNode\";\nimport { ChemNodeItem } from \"../../core/ChemNodeItem\";\nimport { PeriodicTable } from \"../../core/PeriodicTable\";\nimport { ChemK } from \"../../core/ChemK\";\nimport { checkMiddlePoints } from \"./middlePoint\";\nimport {\n  bindNodeToBond,\n  bindNodeToCurrentBond,\n  changeBondToHard,\n  findBondBetweenNodes,\n  mergeBonds,\n} from \"./bondCommon\";\nimport { closeItem } from \"./item\";\nimport { lastItem } from \"../../utils/lastItem\";\nimport { ChemBracketEnd } from \"../../core/ChemBracket\";\nimport { createBackground } from \"../../core/ChemBackground\";\n\nexport const closeNode = (compiler: ChemCompiler) => {\n  closeItem(compiler);\n  compiler.curNode = undefined;\n  compiler.chargeOwner = undefined;\n};\n\nexport const openNode = (\n  compiler: ChemCompiler,\n  isAuto: boolean = false\n): ChemNode => {\n  const bond = compiler.curBond;\n  if (bond) {\n    const { dir } = bond;\n    if (bond.soft && isAuto) {\n      // if second node of bond is auto, then bond is not soft\n      changeBondToHard(compiler, bond);\n    }\n    if (dir && !dir.isZero()) {\n      if (!bond.soft) {\n        const pt = bond.calcPt();\n        const existsNode = compiler.chainSys.findNode(pt);\n        if (existsNode) {\n          compiler.nodesBranch.onNode(existsNode);\n          if (!bond.soft || existsNode.autoMode) {\n            if (!bond.middlePoints) {\n              existsNode.fixed = true; // Узел уже не может автокорректироваться, т.к. это деформирует ранее построенную структуру.\n              const oldNode = bond.nodes[0]!;\n              const oldBond = findBondBetweenNodes(\n                compiler,\n                oldNode,\n                existsNode\n              );\n              if (oldBond) {\n                mergeBonds(compiler, oldBond, bond, existsNode);\n                return existsNode;\n              }\n            }\n          }\n          bindNodeToBond(compiler, existsNode, bond);\n          return existsNode;\n        }\n      }\n      // 0\\    /3  Возможна ситуация, когда уже существует мягкая связь из того же узла в том же направлении\n      //   1==2    Здесь цепь 4-1-2-5 на участке 1-2 может мержится с мягкой связью\n      // 4/    \\5\n      const softBond = compiler.curAgent?.bonds.find(\n        ({ soft, nodes, dir: testDir }) =>\n          soft &&\n          nodes.length === 2 &&\n          nodes[0]?.index === bond.nodes[0]?.index &&\n          !!nodes[1] &&\n          testDir &&\n          dir.equals(testDir)\n      );\n      if (softBond) {\n        const existsNode = softBond.nodes[1]!;\n        mergeBonds(compiler, softBond, bond, existsNode);\n        compiler.chainSys.setCurNode(existsNode);\n        return existsNode;\n      }\n    }\n  }\n  closeNode(compiler);\n  checkMiddlePoints(compiler);\n  // previous closed bracket\n  {\n    const cmd = lastItem(compiler.curAgent!.commands);\n    if (cmd instanceof ChemBracketEnd) {\n      compiler.chainSys.createSubChain();\n    }\n  }\n  const node = compiler.curAgent!.addNode(new ChemNode());\n  node.index = compiler.curAgent!.nodes.length - 1;\n  node.autoMode = isAuto;\n  // Цвет узла зависит только от $color, т.к. $itemColor и $atomColor относятся не к узлу, а к его элементам.\n  node.color = compiler.varColor;\n\n  compiler.curNode = node;\n  compiler.chargeOwner = node;\n  compiler.chainSys.addNode(node);\n  compiler.nodesBranch.onNode(node);\n  compiler.mulCounter.onNode(node);\n  node.bCenter = compiler.centralNode;\n  compiler.centralNode = false;\n\n  bindNodeToCurrentBond(compiler, node);\n  compiler.bracketsCtrl.onNode(node);\n\n  if (compiler.background) {\n    compiler.curAgent!.commands.push(\n      createBackground(compiler.background, node)\n    );\n    compiler.background = undefined;\n  }\n  return node;\n};\n\nexport const getNodeForced = (\n  compiler: ChemCompiler,\n  isAuto: boolean\n): ChemNode => compiler.curNode ?? openNode(compiler, isAuto);\n\n// Вызывается в самом конце, когда уже заполнен список bonds\nexport const updateAutoNode = (node: ChemNode) => {\n  node.items.push(new ChemNodeItem(PeriodicTable.dict.C));\n  const multipleSum: Double = Array.from(node.bonds).reduce(\n    (sum, chemBond) => sum + chemBond.n,\n    0.0\n  );\n  // Заряд влияет на валентность узла: carbon monoxide ⁻C≡O⁺\n  const charge: Int = node.charge?.value ?? 0;\n  const countH: Int = 4 + charge - Math.round(multipleSum);\n  if (countH > 0) {\n    node.items.push(new ChemNodeItem(PeriodicTable.dict.H, new ChemK(countH)));\n  }\n};\n","import { Lang } from \"../../lang/Lang\";\nimport { Char } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { ChemComment } from \"../../core/ChemComment\";\nimport { scanTo } from \"./scan\";\n\nexport const createComment = (compiler: ChemCompiler): ChemComment => {\n  const src = scanComment(compiler);\n  const dst = convertComment(src);\n  compiler.pos++;\n  return new ChemComment(dst);\n};\n\n/** Извлекает комментарий\n * Изначально pos должен быть установлен на первый символ внутри кавычек\n * В конце он установлен на завершающую кавычку\n */\nconst scanComment = (compiler: ChemCompiler): string => {\n  const pos0 = compiler.pos;\n  if (!scanTo(compiler, '\"')) {\n    compiler.error(\"Comment is not closed\", { pos: pos0 - 1 });\n  }\n  return compiler.subStr(pos0);\n};\n\nconst replaceLimited = (\n  text: string,\n  firstLimiter: Char,\n  lastLimiter: Char,\n  transform: (s: string) => string | undefined\n): string => {\n  let i = 0;\n  let result = text;\n  while (i < result.length) {\n    const beginPos = result.indexOf(firstLimiter, i);\n    if (beginPos < 0 || beginPos === result.length) break;\n    const endPos = result.indexOf(lastLimiter, beginPos + 1);\n    if (endPos < 0) break;\n    const key = result.slice(beginPos + 1, endPos);\n    const value = transform(key);\n    if (value !== undefined) {\n      // соответствие найдено. Выполняем замену\n      result = result.slice(0, beginPos) + value + result.slice(endPos + 1);\n      i = beginPos + value.length;\n    } else {\n      // соответствие не найдено. Оставляем скобки в тексте\n      i = beginPos + 1;\n    }\n  }\n  return result;\n};\n\n// Часто встречающиеся символы.\n// Внедряются в текст без каких-то синтаксических ограничителей.\n// Этот список не рекомендуется расширять, т.к. это снижает производительность\nconst specChars: [RegExp, string][] = [\n  [/\\|\\^/g, \"↑\"],\n  [/ArrowUp/g, \"↑\"],\n  [/\\|v/g, \"↓\"],\n  [/ArrowDown/g, \"↓\"],\n  [/\\^o/g, \"°\"],\n];\n\n// Выполнить подстановку специальных символов:\n// - часто встречающиеся символы типа градуса или стрелки.\n// - символы в квадратных скобках. (греческие буквы)\n// - фразы для локализации в обратных апострофах\nconst convertComment = (text: string): string => {\n  // замена частых символов\n  let result: string = specChars.reduce(\n    (acc, [first, second]) => acc.replace(first, second),\n    text\n  );\n\n  // замена символов в квадратных скобках.\n  result = replaceGreek(result);\n  // Перевод фраз из словаря\n  result = replaceLimited(result, \"`\", \"`\", (it) => Lang.findPhrase(it) ?? it);\n  return result;\n};\n\nconst replaceSlashed = (text: string): string =>\n  text.replace(/\\\\([A-Za-z][a-z]*)/g, (x, y) => specCharsB[y] || x);\n\n/**\n * Support of \\Greek in v 2.2\n */\nexport const replaceGreek = (src: string): string =>\n  replaceSlashed(replaceLimited(src, \"[\", \"]\", (it) => specCharsB[it]));\n\n// Символы в квадратных скобках.\n// Здесь можно добавлять другие символы без снижения производительности.\n// (на производительность влияет размер текста и количество скобок в нем)\n\nexport const specCharsB: Record<string, string> = {\n  alpha: \"α\",\n  Alpha: \"Α\",\n  beta: \"β\",\n  Beta: \"Β\",\n  gamma: \"γ\",\n  Gamma: \"Γ\",\n  delta: \"δ\",\n  Delta: \"Δ\",\n  epsilon: \"ε\",\n  Epsilon: \"Ε\",\n  zeta: \"ζ\",\n  Zeta: \"Ζ\",\n  eta: \"η\",\n  Eta: \"Η\",\n  theta: \"θ\",\n  Theta: \"Θ\",\n  iota: \"ι\",\n  Iota: \"Ι\",\n  kappa: \"κ\",\n  Kappa: \"Κ\",\n  lambda: \"λ\",\n  Lambda: \"Λ\",\n  mu: \"μ\",\n  Mu: \"Μ\",\n  nu: \"ν\",\n  Nu: \"Ν\",\n  xi: \"ξ\",\n  Xi: \"Ξ\",\n  omicron: \"ο\",\n  Omicron: \"Ο\",\n  pi: \"π\",\n  Pi: \"Π\",\n  rho: \"ρ\",\n  Rho: \"Ρ\",\n  sigma: \"σ\",\n  Sigma: \"Σ\",\n  tau: \"τ\",\n  Tau: \"Τ\",\n  upsilon: \"υ\",\n  Upsilon: \"Υ\",\n  phi: \"φ\",\n  Phi: \"Φ\",\n  chi: \"χ\",\n  Chi: \"Χ\",\n  psi: \"ψ\",\n  Psi: \"Ψ\",\n  omega: \"ω\",\n  Omega: \"Ω\",\n};\n","import { Char } from \"../../types\";\n\nexport const isDigit = (c: Char): boolean => c >= \"0\" && c <= \"9\";\n","import { Char } from \"../../types\";\n\nexport const isSpace = (ch: Char): boolean =>\n  ch === \" \" || ch === \"\\t\" || ch === \"\\n\";\n","import { Double, Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\n\nconst numConstDict: Record<string, Double> = {\n  $32: Math.sqrt(3.0) / 2.0,\n  $3: Math.sqrt(3.0),\n  $3x2: Math.sqrt(3.0) * 2,\n  $2: Math.sqrt(2.0),\n  $22: Math.sqrt(2.0) / 2.0,\n  $2x2: Math.sqrt(2.0) * 2,\n  \"½\": 0.5,\n  \"¼\": 1.0 / 4.0,\n  \"¾\": 3.0 / 4,\n  \"⅓\": 1.0 / 3,\n  \"⅔\": 2.0 / 3,\n};\n\nconst invalidNumber = (\n  compiler: ChemCompiler,\n  value: string,\n  pos: Int\n): never => {\n  compiler.error(\"Invalid number [n]\", { n: value, pos });\n};\n\nconst parseNumConst = (\n  compiler: ChemCompiler,\n  value: string,\n  pos: Int\n): Double => numConstDict[value] ?? invalidNumber(compiler, value, pos);\n\nconst useVariable = (compiler: ChemCompiler, name: string, pos: Int): Double =>\n  compiler.varsDict[name] ??\n  compiler.error(\"Undefined variable [name]\", { name, pos });\n\nconst declareVariable = (\n  compiler: ChemCompiler,\n  name: string,\n  value: string,\n  pos: Int\n): Double => {\n  if (!name) {\n    compiler.error(\"Expected variable name\", { pos });\n  }\n  const v = +value;\n  const n: Double = Number.isNaN(v)\n    ? parseNumConst(compiler, value, pos + name.length + 1)\n    : v;\n  compiler.varsDict[name] = n;\n  return n;\n};\n\nconst parseVariable = (\n  compiler: ChemCompiler,\n  expr: string,\n  pos: Int\n): Double => {\n  const k = expr.indexOf(\":\");\n  return k < 0\n    ? useVariable(compiler, expr, pos)\n    : declareVariable(compiler, expr.slice(0, k), expr.slice(k + 1), pos);\n};\n\nconst parseNumExt = (\n  compiler: ChemCompiler,\n  srcValue: string,\n  valuePos: Int\n): Double => {\n  let k: Double = 1.0;\n  let value: string = srcValue;\n  let curPos = valuePos;\n  if (srcValue.startsWith(\"-\")) {\n    k = -1.0;\n    curPos++;\n    value = value.slice(1);\n  }\n  if (value.startsWith(\"%\")) {\n    return parseVariable(compiler, value.slice(1), curPos + 1) * k;\n  }\n  return parseNumConst(compiler, value, curPos) * k;\n};\n\nexport const parseNum = (\n  compiler: ChemCompiler,\n  value: string,\n  pos: Int\n): Double => {\n  const v = value.trim();\n  if (!v) return 0.0;\n  const n = +v;\n  return Number.isNaN(n) ? parseNumExt(compiler, v, pos) : n;\n};\n","import { Int, Double } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { parseNum } from \"./parseNum\";\n\nexport const parsePadding = (\n  compiler: ChemCompiler,\n  values: string,\n  pos: Int\n): Double[] => {\n  const chunks = values.split(\";\");\n  let curPos = 0;\n  return chunks.map((val) => {\n    const n = parseNum(compiler, val, curPos + pos);\n    curPos += val.length + 1;\n    return n;\n  });\n};\n","import { ChemCompiler } from \"../ChemCompiler\";\nimport { mainPreProcess } from \"../preprocessor/mainPreProcess\";\n\nexport const prepareText = (compiler: ChemCompiler) => {\n  const src0 = `${compiler.srcText} `;\n  const src = mainPreProcess(src0);\n  compiler.text = src;\n  compiler.expr.src0 = src0;\n  compiler.expr.src = src;\n};\n","import { Char } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\n\nexport const scan = (\n  compiler: ChemCompiler,\n  isValid: (c: Char) => boolean\n): boolean => {\n  while (!compiler.isFinish() && isValid(compiler.curChar())) {\n    compiler.pos++;\n  }\n  return !compiler.isFinish();\n};\n\nexport const scanTo = (compiler: ChemCompiler, fin: Char): boolean =>\n  scan(compiler, (it) => it !== fin);\n","import { Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\n\nexport interface ArgsInfo {\n  args: string[];\n  argPos: Int[];\n}\n\n/**\n * Извлечение списка аргументов.\n * При входе позиция указывает на символ, следующий за (\n * При выходе - на следующий за )\n */\nexport const scanArgs = (compiler: ChemCompiler): ArgsInfo => {\n  const p0 = compiler.pos;\n  let prev = p0;\n  const args: string[] = [];\n  const argPos: Int[] = [];\n  let level = 0;\n  const addArg = () => {\n    argPos.push(prev);\n    args.push(compiler.subStr(prev));\n    prev = compiler.pos + 1;\n  };\n  while (!compiler.isFinish()) {\n    const ch = compiler.curChar();\n    if (ch === \"(\") {\n      level++;\n    } else if (ch === \")\") {\n      if (level === 0) break;\n      level--;\n    } else if (ch === \",\" && level === 0) {\n      addArg();\n    }\n    compiler.pos++;\n  }\n  if (compiler.isFinish())\n    compiler.error(\"It is necessary to close the bracket\", { pos: p0 - 1 });\n  if (p0 !== compiler.pos) {\n    addArg();\n  }\n  compiler.pos++;\n  return { args, argPos };\n};\n","import { ChemBond } from \"../../core/ChemBond\";\nimport { ChemCompiler } from \"../ChemCompiler\";\n/*\nСуффиксы позволяют указать одну из следующих модификаций для только что объявленной связи.\nВо всех версиях используется с краткими описаниями связей.\nНачиная с версии 1.0 может применяться к полигональным связям\n\nДля полигональной связи не может использоваться 0, т.к. он воспринимается как часть числа, означающего число углов полигона\nПоэтому для пустой связи нужно использовать o\n */\n\ntype Action = (bond: ChemBond) => void;\n// private data class SuffixDef(val suffix: String, val action: (bond: ChemBond) -> Unit)\n\nconst bondSuffixes: [string, Action][] = [\n  [\n    \"0\",\n    (bond) => {\n      bond.n = 0.0;\n    },\n  ],\n  [\n    \"o\",\n    (bond) => {\n      bond.n = 0.0;\n    },\n  ],\n  [\"h\", (bond) => bond.setHydrogen()],\n  [\n    \"ww\",\n    (bond) => {\n      bond.w0 = 1;\n    },\n  ],\n  [\n    \"w\",\n    (bond) => {\n      bond.w1 = 1;\n    },\n  ],\n  [\n    \"dd\",\n    (bond) => {\n      bond.w0 = -1;\n    },\n  ],\n  [\n    \"d\",\n    (bond) => {\n      bond.w1 = -1;\n    },\n  ],\n  [\"x\", (bond) => bond.setCross()],\n  [\n    \"~\",\n    (bond) => {\n      bond.style = \"~\";\n    },\n  ],\n  [\n    \"r\",\n    (bond) => {\n      bond.align = \"r\";\n    },\n  ],\n  [\n    \"m\",\n    (bond) => {\n      bond.align = \"m\";\n    },\n  ],\n  [\n    \"l\",\n    (bond) => {\n      bond.align = \"l\";\n    },\n  ],\n  [\n    \"vvv\",\n    (bond) => {\n      bond.arr0 = true;\n      bond.arr1 = true;\n    },\n  ],\n  [\n    \"vv\",\n    (bond) => {\n      bond.arr0 = true;\n    },\n  ],\n  [\n    \"v\",\n    (bond) => {\n      bond.arr1 = true;\n    },\n  ],\n];\n\nexport const scanBondSuffix = (compiler: ChemCompiler, bond: ChemBond) => {\n  for (;;) {\n    const rec = bondSuffixes.find(([suffix]) => compiler.isCurPosEq(suffix));\n    if (!rec) break;\n\n    const [suffix, action] = rec;\n    action(bond);\n    compiler.pos += suffix.length;\n  }\n};\n","import { ChemCompiler } from \"../ChemCompiler\";\nimport { ChemCharge, createCharge } from \"../../core/ChemCharge\";\nimport { CoeffPosOrAngle } from \"../../types/CoeffPos\";\n\n// Извлечение заряда из текущей позиции.\n// Возвращает объект ChemCharge или null\n\nexport const scanCharge = (\n  compiler: ChemCompiler,\n  coeffPos: CoeffPosOrAngle = \"RT\"\n): ChemCharge | undefined => {\n  if (compiler.isFinish()) return undefined;\n  const pos0 = compiler.pos;\n  let prevCharge: ChemCharge | undefined;\n  for (;;) {\n    compiler.pos++;\n    const charge = createCharge(compiler.subStr(pos0), coeffPos);\n    if (!charge) {\n      compiler.pos--;\n      break;\n    }\n    prevCharge = charge;\n    if (compiler.isFinish()) break;\n  }\n  return prevCharge;\n};\n","import { ChemCompiler } from \"../ChemCompiler\";\nimport { ChemK } from \"../../core/ChemK\";\nimport { scanTo } from \"./scan\";\nimport { CoeffPos } from \"../../types/CoeffPos\";\n\nexport const scanCoeff = (compiler: ChemCompiler): ChemK | undefined => {\n  const getCoeffPos = (): CoeffPos | undefined =>\n    compiler.getAltFlag() ? \"LB\" : undefined;\n  let ch = compiler.text[compiler.pos];\n  if (ch === \"`\") {\n    compiler.setAltFlag();\n    ch = compiler.text[++compiler.pos];\n  }\n  const pos0 = compiler.pos;\n  if (ch) {\n    if (ch >= \"0\" && ch <= \"9\") {\n      // Числовой коэфф\n      compiler.pos++;\n      while (!compiler.isFinish()) {\n        ch = compiler.text[compiler.pos];\n        if (!ch || ch < \"0\" || ch > \"9\") break;\n        compiler.pos++;\n      }\n      const s = compiler.subStr(pos0);\n      return new ChemK(+s, getCoeffPos());\n    }\n    if (ch === \"'\") {\n      // Абстрактный коэфф.\n      compiler.pos++;\n      if (!scanTo(compiler, \"'\"))\n        compiler.error(\"Abstract coefficient is not closed\", { pos: pos0 });\n      const s = compiler.subStr(pos0 + 1);\n      compiler.pos++;\n      return new ChemK(s, getCoeffPos());\n    }\n  }\n  return undefined;\n};\n","import { Char } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\n\nexport const isIdFirstChar = (c: Char): boolean => /[A-Za-z]/.test(c);\n\nconst isIdChar = (c: Char): boolean => /[A-Z\\d]/i.test(c);\n\nexport const isId = (text: string): boolean => {\n  if (!text || !isIdFirstChar(text[0]!)) return false;\n  return !Array.from(text.slice(1)).find((it) => !isIdChar(it));\n};\n\nexport const scanId = (compiler: ChemCompiler): string | undefined => {\n  const startPos = compiler.pos;\n  if (isIdFirstChar(compiler.curChar())) {\n    compiler.pos++;\n    while (isIdChar(compiler.curChar())) compiler.pos++;\n  }\n  const id = compiler.subStr(startPos);\n  return id === \"\" ? undefined : id;\n};\n","import { Int } from \"../../types\";\nimport { ChemCompiler } from \"../ChemCompiler\";\nimport { isDigit } from \"./isDigit\";\n\nexport const scanInt = (compiler: ChemCompiler): Int | undefined => {\n  const oldPos = compiler.pos;\n  if (compiler.curChar() === \"-\" && isDigit(compiler.text[oldPos + 1]!)) {\n    compiler.pos++;\n  }\n  while (isDigit(compiler.curChar())) {\n    compiler.pos++;\n  }\n  return compiler.pos === oldPos ? undefined : +compiler.subStr(oldPos);\n};\n","import { ChemCompiler } from \"../ChemCompiler\";\nimport { OpDef, opsList } from \"../main/chemOp\";\nimport { isSpace } from \"./isSpace\";\n\nexport const scanOp = (compiler: ChemCompiler): OpDef | undefined => {\n  const res = opsList.find((it) => compiler.isCurPosEq(it.src));\n  if (res) {\n    const nextPos = compiler.pos + res.src.length;\n    const nextChar = compiler.text[nextPos];\n    if (nextChar && !isSpace(nextChar) && nextChar !== '\"') {\n      // it is not operation. For example =|`=`|\n      return undefined;\n    }\n    compiler.pos += res.src.length;\n  }\n  return res;\n};\n","import { ChemCompiler } from \"../ChemCompiler\";\nimport { ChemK } from \"../../core/ChemK\";\nimport { scanCoeff } from \"./scanCoeff\";\nimport { ifDef } from \"../../utils/ifDef\";\n\nexport const scanPostItem = (\n  compiler: ChemCompiler,\n  onCoeff: (coeff: ChemK) => void\n): boolean =>\n  ifDef(scanCoeff(compiler), (it) => {\n    onCoeff(it);\n    return true;\n  }) ?? false;\n","import { ChemCompiler } from \"../ChemCompiler\";\nimport { isSpace } from \"./isSpace\";\n\nexport const skipSpaces = (compiler: ChemCompiler) => {\n  while (compiler.pos < compiler.text.length && isSpace(compiler.curChar()))\n    compiler.pos++;\n};\n","export class Macros {\n  constructor(public readonly name: string) {}\n\n  body: string = \"\";\n}\n\nexport const globalMacros: Record<string, Macros> = {};\n","import { Int } from \"../../types\";\nimport { ChemError } from \"../../core/ChemError\";\nimport { LangParams } from \"../../lang\";\n\nexport class PreProcCtx {\n  src: string = \"\";\n\n  dst: string = \"\";\n\n  pos: Int = 0;\n\n  readonly stack: string[] = [];\n\n  constructor(ctx: PreProcCtx);\n\n  constructor(aSrc: string);\n\n  constructor(aSrc: string, aPos: Int);\n\n  constructor(aSrc: PreProcCtx | string, aPos?: Int) {\n    if (aSrc instanceof PreProcCtx) {\n      this.src = aSrc.src;\n      this.pos = aSrc.pos;\n    } else {\n      this.src = aSrc;\n      if (aPos !== undefined) this.pos = aPos;\n    }\n  }\n\n  error(msg: string, errPos: Int = 0): never {\n    if (errPos !== 0) {\n      this.pos = errPos < 0 ? this.pos + errPos : errPos;\n    }\n    throw new ChemError(msg, { pos: this.pos });\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  errorPar(msg: string, params: LangParams): never {\n    throw new ChemError(msg, params);\n  }\n\n  // считать указанное число символов\n  n(count: Int = 1): string {\n    if (count === 0) {\n      return \"\";\n    }\n    if (this.pos + count > this.src.length) {\n      this.error(\"Unexpected end of macros\");\n    }\n    const start = this.pos;\n    this.pos += count;\n    return this.src.slice(start, this.pos);\n  }\n\n  // поиск подстроки\n  search(cond: string): string | undefined {\n    const start = this.pos;\n    const stop = this.src.indexOf(cond, start);\n    if (stop < 0) {\n      return undefined;\n    }\n    this.pos = stop + cond.length;\n    return this.src.slice(start, stop);\n  }\n\n  searchEx(cond: string): string {\n    return (\n      this.search(cond) ??\n      this.errorPar(\"Expected [cond] character in macros\", { cond })\n    );\n  }\n\n  // Достигнут ли конец?\n  end(): boolean {\n    return this.pos < this.src.length;\n  }\n\n  // вывод в dst\n  write(text: string) {\n    this.dst += text;\n  }\n\n  // Записать в выходной буфер остаток исходной строки (от pos до конца)\n  writeFinish() {\n    this.write(this.src.slice(this.pos));\n    this.pos = this.src.length;\n  }\n\n  push() {\n    this.stack.unshift(this.dst);\n    this.dst = \"\";\n  }\n\n  pop(): string {\n    const tmp = this.dst;\n    this.dst = this.stack.shift() || \"\";\n    return tmp;\n  }\n\n  clear() {\n    this.dst = \"\";\n  }\n}\n","import { isIdFirstChar } from \"../parse/scanId\";\nimport { defMacro } from \"./defMacro\";\nimport { PreProcCtx } from \"./PreProcCtx\";\n\n// Функция, которая ищет конец макроопределения. При этом, на вывод не идут объявления @:\n// Конструкция @:A()...@() заменяется на @A()\n// Окончание либо по концу буфера, либо по конструкции, отличающейся от @: и @A\n\nexport const bodyPreprocess = (ctx: PreProcCtx) => {\n  for (;;) {\n    const plain = ctx.search(\"@\");\n    if (plain === undefined) {\n      // макросов больше нет\n      ctx.writeFinish(); // пишем остаток строки и заканчиваем обработку\n      break;\n    }\n    ctx.write(plain); // Выводим предшествующий текст\n    const c = ctx.n(); // Следующий символ\n    if (c === \":\") {\n      // Объявление нового макроса\n      defMacro(ctx);\n    } else if (isIdFirstChar(c[0]!)) {\n      // вызов существующего макроса\n      ctx.write(`@${c}`);\n    } else {\n      // Остальные символы расцениваются как окончание тела. их разбор делает вызывающий код\n      ctx.pos--;\n      break;\n    }\n  }\n};\n","// определение нового макроса\n// имя, формальные параметры, тело\n// если завершение @; то ничего не выводится\n// если (... , то выводится @name(...\n\nimport { isIdFirstChar } from \"../parse/scanId\";\nimport { bodyPreprocess } from \"./bodyPreprocess\";\nimport { globalMacros, Macros } from \"./Macros\";\nimport { PreProcCtx } from \"./PreProcCtx\";\n\nexport const defMacro = (ctx: PreProcCtx) => {\n  const p0 = ctx.pos;\n  const name = ctx.searchEx(\"(\");\n  if (!isIdFirstChar(name[0]!)) {\n    ctx.error(\"Invalid macro name\", p0);\n  }\n  const macro = new Macros(name);\n\n  // считывание тела макроса\n  // параметры читаются вместе с телом и разбираются при каждом вызове\n  // это даёт возможность включить в них параметры вышестоящего макроса\n  ctx.push();\n  bodyPreprocess(ctx);\n  macro.body = ctx.pop();\n  // анализ окончания\n  const c = ctx.n();\n  if (c === \"(\") {\n    // Окончание с вызовом\n    ctx.write(`@${name}${c}`);\n  } else if (c !== \";\") {\n    ctx.error(\"Invalid macros end\");\n  }\n  globalMacros[name] = macro;\n};\n","import { isId } from \"../parse/scanId\";\nimport { globalMacros } from \"./Macros\";\nimport { PreProcCtx } from \"./PreProcCtx\";\nimport { MacroParams, readFormalPars } from \"./readFormalPars\";\nimport { scanPar } from \"./scanPar\";\n\nexport const applyParamValues = (\n  def: MacroParams,\n  params: string[],\n  ctx: PreProcCtx\n): PreProcCtx => {\n  if (def.names.length === 0) {\n    return ctx;\n  }\n  let curIndex = 0;\n  // Подставляем фактические значения\n  params.forEach((paramValue) => {\n    const k = paramValue.indexOf(\":\");\n    let ready = false;\n    if (k >= 0) {\n      const id = paramValue.slice(0, k);\n      if (id in def.dict) {\n        def.dict[id] = paramValue.slice(k + 1);\n        ready = true;\n      }\n    }\n    if (!ready) {\n      const name = def.names[curIndex++];\n      // Индексный параметр может быть пропущен, если пуст.\n      // Тогда вместо него будет использовано значение по умолчанию\n      if (name !== undefined && !!paramValue) {\n        def.dict[name] = paramValue;\n      }\n    }\n  });\n  // Замена параметров на значения\n  ctx.writeFinish();\n  const exl = ctx.dst.split(\"&\");\n  exl.slice(1).forEach((s, index) => {\n    const i = index + 1;\n    const id = def.names.reduce(\n      (prev, f) =>\n        s.slice(0, Math.min(f.length, s.length)) === f && f.length > prev.length\n          ? f\n          : prev,\n      \"\"\n    );\n    // Если в формуле встретился знак &, с которым не связан ни один параметр, пропускаем\n    if (id) {\n      // Замена параметра на значение\n      exl[i] = def.dict[id] + exl[i]!.slice(id.length);\n    }\n  });\n  return new PreProcCtx(exl.join(\"\"));\n};\n\nexport const readRealParams = (ctx: PreProcCtx): string[] => {\n  const result: string[] = [];\n  if (ctx.n() !== \")\") {\n    ctx.pos--;\n    do {\n      const p0 = ctx.pos;\n      const p1 = scanPar(ctx.src, p0);\n      if (p1 >= ctx.src.length) {\n        ctx.error(\"Real params list is not closed\");\n      }\n      result.push(ctx.n(p1 - p0));\n    } while (ctx.n() !== \")\");\n  }\n  return result;\n};\n\n// Исполнение макроса\n// params - индексный список фактических параметров, в тексте которых могут быть имена\n// так сделано из-за того, что до вызова точно не известно число формальных параметров\nexport const execMacros = (src: string, params: string[]): string => {\n  const ctx0 = new PreProcCtx(src);\n  // Извлечение формальных параметров\n  const p = readFormalPars(ctx0);\n  const ctx1 = applyParamValues(p, params, ctx0);\n  // Расшифровка всех макросов @A()\n  for (;;) {\n    const c = ctx1.search(\"@\");\n    if (c === undefined) {\n      ctx1.writeFinish();\n      break;\n    }\n    // Встречено объявление. Это может быть только конструкция @A\n    ctx1.write(c);\n    const name = ctx1.searchEx(\"(\");\n    if (!isId(name)) {\n      ctx1.errorPar(\"Invalid macro [name]\", { name });\n    }\n    const macro = globalMacros[name];\n    if (macro) {\n      // Извлечение фактических параметров\n      const realParams = readRealParams(ctx1);\n      ctx1.write(execMacros(macro.body, realParams));\n    } else ctx1.errorPar(\"Macros not found: [name]\", { name });\n  }\n  return ctx1.dst;\n};\n","import { bodyPreprocess } from \"./bodyPreprocess\";\nimport { execMacros } from \"./execMacros\";\nimport { PreProcCtx } from \"./PreProcCtx\";\n\nexport const mainPreProcess = (src: string): string => {\n  // основной алгоритм выполнения препроцессора для заданной строки\n  const ctx = new PreProcCtx(src);\n  bodyPreprocess(ctx);\n  if (ctx.pos !== src.length) {\n    ctx.error(\"Invalid preprocessor finish\");\n  }\n  const dummyBody = `)${ctx.dst}`;\n  return execMacros(dummyBody, []);\n};\n","import { isId } from \"../parse/scanId\";\nimport { PreProcCtx } from \"./PreProcCtx\";\nimport { scanPar } from \"./scanPar\";\n\n// Хотя names по составу является тем же списком, который можно получить из dict.keys,\n// но необходимо гарантировать точный порядок.\n// Например в JavaScript такой порядок сохраняется, а C++ или Python - нет\n// Поэтому список формальных параметров имеет словарь имя/значение и список имен\nexport interface MacroParams {\n  dict: Record<string, string>;\n  names: string[];\n}\n\n// Формальные параметры x[:XX]\nexport const readFormalPars = (ctx: PreProcCtx): MacroParams => {\n  const dict: Record<string, string> = {};\n  const names: string[] = [];\n  if (ctx.n() !== \")\") {\n    ctx.pos--;\n    for (;;) {\n      const p0 = ctx.pos;\n      const p1 = scanPar(ctx.src, p0);\n\n      if (p1 >= ctx.src.length) {\n        ctx.error(\"Formal params list is not closed\");\n      }\n      const param = ctx.n(p1 - p0); // Получено объявление очередного параметра\n      const k = param.indexOf(\":\");\n      const [first, second] =\n        k < 0\n          ? // без значения по умолчанию\n            [param, \"\"]\n          : [param.slice(0, k), param.slice(k + 1)];\n\n      // Контролируем правильность описания названия параметра\n      if (!isId(first)) {\n        ctx.errorPar(\"Invalid parameter name: [name]\", { name: first });\n      }\n      dict[first] = second;\n      names.push(first);\n      const c = ctx.n();\n      if (c === \")\") break;\n    }\n  }\n  return { dict, names };\n};\n","import { Int } from \"../../types\";\n\n// Определение границы параметра. Ограничителем является знак , или )\nexport const scanPar = (src: string, start: Int): Int => {\n  // нужно учитывать баланс скобок и кавычек\n  let lock = 0;\n  let isComment = false;\n  let pos = start;\n  while (pos < src.length) {\n    const c = src[pos];\n    if (c === '\"') isComment = !isComment;\n    else if (c === \"(\" && !isComment) lock++;\n    else if (c === \",\" && !isComment && lock === 0) break;\n    else if (c === \")\" && !isComment) {\n      if (lock > 0) lock--;\n      else break;\n    }\n    pos++;\n  }\n  return pos;\n};\n","import { ChemObj } from \"../../core/ChemObj\";\nimport { SrcMapItem } from \"./SrcMapItem\";\n\nexport const getSrcItemsForObject = (\n  needObj: ChemObj,\n  srcMap?: SrcMapItem[]\n): SrcMapItem[] => srcMap?.filter(({ obj }) => needObj === obj) ?? [];\n","export * from \"./SrcMapItem\";\nexport * from \"./getSrcItemsForObject\";\n","import { CompilerState } from \"../ChemCompiler\";\nimport { createAgent } from \"../main/agent\";\nimport { stateAgentBegin } from \"./stateAgentBegin\";\n\nexport const stateAgent: CompilerState = (compiler) => {\n  createAgent(compiler);\n  compiler.agentMode = \"begin\";\n  return compiler.setState(stateAgentBegin);\n};\n","import { ifDef } from \"../../utils/ifDef\";\nimport { CompilerState } from \"../ChemCompiler\";\nimport { scanCoeff } from \"../parse/scanCoeff\";\nimport { stateAgentIn } from \"./stateAgentIn\";\nimport { stateFuncName } from \"./stateFuncName\";\n\n/**\n * Начало агента может включать функции и коэффициент\n * @param compiler\n * @returns\n */\nexport const stateAgentBegin: CompilerState = (compiler) => {\n  compiler.agentMode = \"begin\";\n  const agent = compiler.curAgent;\n  if (!agent) {\n    compiler.error(\"stateAgentBegin with empty agent\", {});\n  } else {\n    if (compiler.curChar() === \"$\") {\n      return compiler.setState(stateFuncName, 1);\n    }\n\n    ifDef(scanCoeff(compiler), (coeff) => {\n      agent.n = coeff;\n      if (coeff) coeff.color = compiler.varColor;\n      if (compiler.srcMap) {\n        compiler.addSrcMapItem(agent, compiler.entityBegin, \"agentK\");\n        compiler.entityBegin = compiler.pos;\n      }\n    });\n  }\n  return compiler.setState(stateAgentIn);\n};\n","import { CompilerState } from \"../ChemCompiler\";\nimport { agentAnalyse } from \"../main/agentAnalyse\";\n\nexport const stateAgentIn: CompilerState = (compiler) =>\n  agentAnalyse(compiler, () =>\n    compiler.error(\"Unknown element character '[C]'\", {\n      C: compiler.curChar(),\n      pos: compiler.pos,\n    })\n  );\n","import { CompilerState } from \"../ChemCompiler\";\nimport { agentAnalyse } from \"../main/agentAnalyse\";\nimport { closeEntity } from \"../main/entity\";\nimport { stateBegin } from \"./stateBegin\";\n\nexport const stateAgentMid: CompilerState = (compiler) =>\n  agentAnalyse(compiler, () => {\n    closeEntity(compiler);\n    return compiler.setState(stateBegin);\n  });\n","import { CompilerState } from \"../ChemCompiler\";\nimport { skipSpaces } from \"../parse/skipSpaces\";\nimport { stateAgentMid } from \"./stateAgentMid\";\n\nexport const stateAgentSpace: CompilerState = (compiler) => {\n  skipSpaces(compiler);\n  return compiler.setState(stateAgentMid);\n};\n","import { CompilerState } from \"../ChemCompiler\";\nimport { createChemOp } from \"../main/chemOp\";\nimport { scanOp } from \"../parse/scanOp\";\nimport { skipSpaces } from \"../parse/skipSpaces\";\nimport { stateAgent } from \"./stateAgent\";\nimport { stateCommentPre } from \"./stateCommentPre\";\nimport { stateOpEnd } from \"./stateOpEnd\";\n\nexport const stateBegin: CompilerState = (compiler) => {\n  skipSpaces(compiler);\n  if (compiler.isFinish()) {\n    return 0;\n  }\n\n  if (compiler.curChar() === '\"') {\n    return compiler.setState(stateCommentPre, 1);\n  }\n\n  const opDef = scanOp(compiler);\n  if (opDef != null) {\n    createChemOp(compiler, opDef);\n    return compiler.setState(stateOpEnd);\n  }\n\n  // Иначе считаем, что это начало реагента\n  return compiler.setState(stateAgent);\n};\n","import { CompilerState } from \"../ChemCompiler\";\nimport { scanCoeff } from \"../parse/scanCoeff\";\nimport { ifDef } from \"../../utils/ifDef\";\nimport { startMul } from \"../main/multipier\";\nimport { stateAgentMid } from \"./stateAgentMid\";\n\nexport const stateBracketBegin: CompilerState = (compiler) => {\n  ifDef(scanCoeff(compiler), (it) => {\n    startMul(compiler, it, true);\n  });\n  return compiler.setState(stateAgentMid);\n};\n","import { ChemChargeOwner } from \"../../core/ChemChargeOwner\";\nimport { CompilerState } from \"../ChemCompiler\";\nimport { openNode } from \"../main/node\";\nimport { scanCharge } from \"../parse/scanCharge\";\nimport { stateAgentMid } from \"./stateAgentMid\";\n\nexport const stateCharge: CompilerState = (compiler) => {\n  const { pos, curNode, curBond } = compiler;\n  // Если нет явно объявленного владельца, то можно постараться создать автоузел\n  const chargeOwner: ChemChargeOwner =\n    compiler.chargeOwner ??\n    (!curNode && curBond\n      ? openNode(compiler, true)\n      : compiler.error(\"Expected node declaration before charge\", {\n          pos: pos - 1,\n        }));\n  // Наличие ` перед объявлением заряда означает, что заряд нужно вывести слева\n  const isLeft = compiler.getAltFlag();\n  const varPos = compiler.eject(\"varPos\");\n  chargeOwner.charge =\n    scanCharge(compiler, varPos ?? (isLeft ? \"LT\" : \"RT\")) ??\n    compiler.error(\"Invalid charge declaration\", { pos });\n  return compiler.setState(stateAgentMid);\n};\n","import { CompilerState } from \"../ChemCompiler\";\nimport { addNodeItem } from \"../main/addNodeItem\";\nimport { createComment } from \"../parse/comment\";\nimport { stateAgentMid } from \"./stateAgentMid\";\n\nexport const stateCommentIn: CompilerState = (compiler) => {\n  addNodeItem(compiler, createComment(compiler));\n  return compiler.setState(stateAgentMid);\n};\n","import { CompilerState } from \"../ChemCompiler\";\nimport { createComment } from \"../parse/comment\";\nimport { stateBegin } from \"./stateBegin\";\n\nexport const stateCommentPre: CompilerState = (compiler) => {\n  compiler.preCommPos = compiler.pos - 1;\n  compiler.preComm = createComment(compiler);\n  return compiler.setState(stateBegin);\n};\n","import { CompilerState } from \"../ChemCompiler\";\nimport { addNodeItem } from \"../main/addNodeItem\";\nimport { ChemRadical } from \"../../core/ChemRadical\";\nimport { ChemCustom } from \"../../core/ChemCustom\";\nimport { scanPostItem } from \"../parse/scanPostItem\";\nimport { stateAgentMid } from \"./stateAgentMid\";\nimport { openBrace } from \"../main/brackets\";\nimport { replaceGreek } from \"../parse/comment\";\nimport { scanMarkupEnd } from \"../../utils/markup\";\n\n/**\n * Создание абстрактного элемента или радикала\n */\nexport const stateCustom: CompilerState = (compiler) => {\n  if (compiler.curChar() === \"{\") {\n    //  {{\n    return openBrace(compiler);\n  }\n  const startPos = compiler.pos; // pos установлен на символ, следующий за '{'\n  compiler.pos = scanMarkupEnd(compiler.text, compiler.pos, \"}\") - 1;\n  if (compiler.text[compiler.pos] !== \"}\")\n    compiler.error(\"Abstract element is not closed\", { pos: startPos - 1 });\n  const s = replaceGreek(compiler.subStr(startPos));\n  const item = addNodeItem(compiler, ChemRadical.dict[s] ?? new ChemCustom(s));\n  compiler.pos++;\n  scanPostItem(compiler, (it) => {\n    item.n = it;\n  });\n  return compiler.setState(stateAgentMid);\n};\n","import { CompilerState } from \"../ChemCompiler\";\nimport { scan } from \"../parse/scan\";\nimport { findElement } from \"../../core/PeriodicTable\";\nimport { ChemRadical } from \"../../core/ChemRadical\";\nimport { ChemSubObj } from \"../../core/ChemSubObj\";\nimport { addNodeItem } from \"../main/addNodeItem\";\nimport { statePostItem } from \"./statePostItem\";\n\n// Извлечение элемента. Позиция первого символа elementStartPos\nexport const stateElement: CompilerState = (compiler) => {\n  scan(compiler, (it) => it >= \"a\" && it <= \"z\");\n  const id = compiler.subStr(compiler.elementStartPos);\n  const elem: ChemSubObj =\n    findElement(id) ??\n    ChemRadical.dict[id] ??\n    compiler.error(\"Unknown element '[Elem]'\", {\n      pos: compiler.elementStartPos,\n      Elem: id,\n    });\n  const item = addNodeItem(compiler, elem);\n  compiler.addSrcMapItem(item, compiler.elementStartPos);\n  return compiler.setState(statePostItem);\n};\n","import { CompilerState } from \"../ChemCompiler\";\nimport { scanTo } from \"../parse/scan\";\nimport { scanArgs } from \"../parse/scanArgs\";\nimport { ifDef } from \"../../utils/ifDef\";\nimport { stateAgentMid } from \"./stateAgentMid\";\nimport { funcsDict } from \"../funcs/funcsDict\";\nimport { stateAgentBegin } from \"./stateAgentBegin\";\n\nexport const stateFuncName: CompilerState = (compiler) => {\n  const startPos = compiler.pos; // Указывает на следующий символ за $\n  if (!scanTo(compiler, \"(\"))\n    compiler.error(\"Expected '(' after [S]\", { S: \"$\", pos: startPos - 1 });\n  const name = compiler.subStr(startPos);\n  compiler.pos++;\n  const { args, argPos } = scanArgs(compiler);\n  // Если имя функции не найдено, функция игнорируется\n  // с целью совместимости со следующими версиями\n  ifDef(funcsDict[name], (func) => func(compiler, args, argPos));\n  if (compiler.agentMode === \"begin\") {\n    // Случай, когда функция описывается раньше чем создан агент\n    return compiler.setState(stateAgentBegin);\n  }\n  return compiler.setState(stateAgentMid);\n};\n","import { ChemBond } from \"../../core/ChemBond\";\nimport { Int } from \"../../types\";\nimport { ChemCompiler, CompilerState } from \"../ChemCompiler\";\nimport { isSpace } from \"../parse/isSpace\";\nimport { stateAgentSpace } from \"./stateAgentSpace\";\nimport { ChemNode } from \"../../core/ChemNode\";\nimport { ChemAtom } from \"../../core/ChemAtom\";\nimport { findElement } from \"../../core/PeriodicTable\";\nimport { scanId } from \"../parse/scanId\";\nimport { stateAgentMid } from \"./stateAgentMid\";\nimport { scanInt } from \"../parse/scanInt\";\nimport { mergeBonds } from \"../main/bondCommon\";\n\nconst onReferenceError = (\n  compiler: ChemCompiler,\n  ref: string,\n  pos: Int\n): never => compiler.error(\"Invalid node reference '[ref]'\", { ref, pos });\n\nconst bondNodesKey = (bond: ChemBond): string =>\n  bond.nodes.map((n) => n?.index ?? \"\").join(\",\");\n\nconst useRef = (compiler: ChemCompiler, node: ChemNode) => {\n  const { curBond } = compiler;\n  if (curBond) {\n    curBond.soft = false;\n    curBond.nodes[1] = node;\n    // Здесь нужна проверка на мерж связей...\n    const curKey = bondNodesKey(curBond);\n    const prevBond = compiler.curAgent?.bonds.find(\n      (b) => bondNodesKey(b) === curKey\n    );\n    if (prevBond && prevBond !== curBond) {\n      compiler.chainSys.setCurNode(curBond.nodes[1]);\n      mergeBonds(compiler, prevBond, curBond, node);\n    } else {\n      compiler.chainSys.bondToRef(curBond);\n    }\n  } else {\n    compiler.chainSys.addNode(node);\n    compiler.nodesBranch.onNode(node);\n  }\n  compiler.curNode = node;\n  node.fixed = true;\n  compiler.nodesBranch.onNode(node);\n};\n\nconst useRefByNumber = (compiler: ChemCompiler, n: Int, startPos: Int) => {\n  const { nodes } = compiler.curAgent!;\n  const index: Int = n < 0 ? nodes.length + n : n - 1;\n  if (index < 0 || index >= nodes.length) {\n    onReferenceError(compiler, String(n), startPos);\n  }\n  useRef(compiler, nodes[index]!);\n};\n\nconst isAtomNode = (node: ChemNode, atom: ChemAtom): boolean =>\n  node.items.length === 1 && node.items[0]!.obj === atom;\n\nconst useRefByAtom = (\n  compiler: ChemCompiler,\n  atom: ChemAtom,\n  startPos: Int\n) => {\n  const { nodes } = compiler.curAgent!;\n  useRef(\n    compiler,\n    nodes.find((it) => isAtomNode(it, atom)) ??\n      onReferenceError(compiler, atom.id, startPos)\n  );\n};\n\nconst useRefById = (compiler: ChemCompiler, id: string, startPos: Int) => {\n  const ref = compiler.references[id];\n  if (ref) {\n    useRef(compiler, ref);\n  } else {\n    const elem = findElement(id);\n    if (elem) {\n      useRefByAtom(compiler, elem, startPos);\n    } else {\n      onReferenceError(compiler, id, startPos);\n    }\n  }\n};\n\nexport const stateNodeRef: CompilerState = (compiler) => {\n  if (isSpace(compiler.curChar())) {\n    return compiler.setState(stateAgentSpace);\n  }\n  const startPos = compiler.pos;\n  const n = scanInt(compiler);\n  if (n !== undefined) {\n    useRefByNumber(compiler, n, startPos);\n  } else {\n    const id = scanId(compiler);\n    if (id) {\n      useRefById(compiler, id, startPos);\n    } else onReferenceError(compiler, compiler.curChar(), startPos);\n  }\n  return compiler.setState(stateAgentMid);\n};\n","import { CompilerState } from \"../ChemCompiler\";\nimport { createComment } from \"../parse/comment\";\nimport { stateBegin } from \"./stateBegin\";\n\nexport const stateOpEnd: CompilerState = (compiler) => {\n  if (compiler.curChar() === '\"') {\n    compiler.pos++;\n    compiler.curOp!.commentPost = createComment(compiler);\n  }\n  if (compiler.curOp) {\n    compiler.addSrcMapItem(compiler.curOp, compiler.eject(\"entityBegin\"));\n  }\n  return compiler.setState(stateBegin);\n};\n","import { CompilerState } from \"../ChemCompiler\";\nimport { getLastItem } from \"../main/item\";\nimport { scanCharge } from \"../parse/scanCharge\";\nimport { scanPostItem } from \"../parse/scanPostItem\";\nimport { stateAgentMid } from \"./stateAgentMid\";\n\nexport const statePostItem: CompilerState = (compiler) => {\n  const item = getLastItem(compiler) ?? compiler.error(\"Invalid node\", {});\n  if (\n    scanPostItem(compiler, (it) => {\n      item.n = it;\n    })\n  )\n    return compiler.setState(statePostItem);\n\n  if (compiler.curChar() === \"(\") {\n    const bracketPos = compiler.pos;\n    compiler.pos++;\n    const charge = scanCharge(compiler);\n    if (charge && compiler.curChar() === \")\") {\n      item.charge = charge;\n      return compiler.setState(statePostItem, 1);\n    }\n    compiler.pos = bracketPos;\n  }\n\n  return compiler.setState(stateAgentMid);\n};\n","import { CompilerState } from \"../ChemCompiler\";\nimport { createPolygonalBond } from \"../main/bondPolygonal\";\nimport { createRingBond } from \"../main/bondRing\";\nimport { createSplineBond } from \"../main/bondSpline\";\nimport { createUniversalBond } from \"../main/bondUniversal\";\nimport { createMiddlePoint } from \"../main/middlePoint\";\nimport { scanArgs } from \"../parse/scanArgs\";\nimport { stateAgentMid } from \"./stateAgentMid\";\n\nexport const stateUniBond: CompilerState = (compiler) => {\n  const begin = compiler.pos - 1;\n  switch (compiler.curChar()) {\n    case \"(\":\n      {\n        compiler.pos++;\n        const { args, argPos } = scanArgs(compiler);\n        createUniversalBond(compiler, args, argPos, begin);\n      }\n      break;\n    case \"p\":\n    case \"q\":\n      createPolygonalBond(compiler);\n      break;\n    case \"m\":\n      createMiddlePoint(compiler);\n      break;\n    case \"o\":\n      createRingBond(compiler, 1);\n      break;\n    case \"s\":\n      createSplineBond(compiler);\n      break;\n    default:\n      createUniversalBond(compiler, [], [], begin);\n      break;\n  }\n  return compiler.setState(stateAgentMid);\n};\n","import { Int } from \"../types\";\nimport { ChemObj } from \"./ChemObj\";\nimport { ChemNode } from \"./ChemNode\";\nimport { ChemBond } from \"./ChemBond\";\nimport { ChemK } from \"./ChemK\";\nimport { Visitor } from \"./Visitor\";\nimport { StructAnalyzer } from \"./StructAnalyzer\";\n\nexport class ChemAgent extends ChemObj {\n  nodes: ChemNode[] = [];\n\n  bonds: ChemBond[] = [];\n\n  commands: ChemObj[] = [];\n\n  n: ChemK = new ChemK(1);\n\n  part: Int = 0;\n\n  stA: StructAnalyzer;\n\n  constructor() {\n    super();\n    this.stA = new StructAnalyzer(this);\n  }\n\n  setCoeff(k: ChemK | number) {\n    this.n = typeof k === \"number\" ? new ChemK(k) : k;\n  }\n\n  addNode(node: ChemNode): ChemNode {\n    this.nodes.push(node);\n    this.commands.push(node);\n    return node;\n  }\n\n  addBond(bond: ChemBond) {\n    this.bonds.push(bond);\n    this.commands.push(bond);\n  }\n\n  override walk(visitor: Visitor) {\n    visitor.agentPre?.(this);\n    if (visitor.isStop) return;\n    for (const cmd of this.commands) {\n      cmd.walk(visitor);\n      if (visitor.isStop) return;\n    }\n    visitor.agentPost?.(this);\n  }\n}\n","import { Int, Double } from \"../types\";\nimport { ChemSubObj } from \"./ChemSubObj\";\nimport { Visitor } from \"./Visitor\";\n\nexport class ChemAtom extends ChemSubObj {\n  readonly stable: boolean;\n\n  readonly epsilonMass: Double | undefined; // +/- Abridged standard atomic weight\n\n  constructor(\n    readonly n: Int, // Atomic number\n    readonly id: string, // Symbol of a chemical element: H, He, Li, Be...\n    readonly mass: Double, // Atomic mass in Daltons\n    options?: {\n      epsilonMass?: Double;\n      stable?: boolean;\n    }\n  ) {\n    super();\n    const { stable, epsilonMass } = options ?? {};\n    this.stable =\n      stable === undefined ? Math.floor(this.mass) !== this.mass : stable;\n    this.epsilonMass = epsilonMass;\n  }\n\n  walk<T extends Visitor>(visitor: T) {\n    visitor.atom?.(this);\n  }\n}\n","import { Double } from \"../types\";\nimport { ChemNode } from \"./ChemNode\";\nimport { ChemObj } from \"./ChemObj\";\n\nexport interface ParamsChemBackground {\n  shape?: string; // round, ellipse or rect\n  padding?: Double[]; // [all], [vert, horiz], [top, horiz, bottom], [top, l, bot, r]\n  isAll?: boolean;\n  nodes?: ChemNode[];\n  borderRadius?: Double;\n  fill?: string;\n  stroke?: string;\n  strokeWidth?: Double;\n}\n\n/**\n * $background()\n */\nexport class ChemBackground extends ChemObj {\n  constructor(public readonly params: ParamsChemBackground) {\n    super();\n  }\n\n  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-empty-function\n  override walk(): void {}\n}\n\nexport const createBackground = (\n  params: ParamsChemBackground,\n  curNode: ChemNode\n): ChemBackground => {\n  if (!params.isAll) {\n    // eslint-disable-next-line no-param-reassign\n    params.nodes = params.nodes ?? [];\n    params.nodes.push(curNode);\n  }\n  return new ChemBackground(params);\n};\n","import { Double, Int } from \"../types\";\nimport { Point } from \"../math/Point\";\nimport { is0, toa } from \"../math\";\nimport { ChemNode } from \"./ChemNode\";\nimport { Visitor } from \"./Visitor\";\nimport { ChemObj } from \"./ChemObj\";\nimport { isNodeHidden } from \"./isNodeHidden\";\n\nexport type BondAlign = \"x\" | \"r\" | \"m\" | \"l\";\n\nexport class ChemBond extends ChemObj {\n  n: Double = 1.0; // multiplicity of the bond\n\n  nodes: (ChemNode | undefined)[] = [undefined, undefined];\n\n  index?: Int; // index of bond in ChemAgent.bonds array\n  // TODO: может быть нарушена в closeAgent при удалении дублирующих связей !!!\n\n  dir?: Point; // bond vector\n\n  tx: string = \"\"; // text description\n\n  slope: Int = 0; // для связи, созданной из описания / = -1, для \\ = 1, для остальных =0\n\n  isText: boolean = false;\n\n  color?: string; // цвет связи\n\n  w0: Int = 0; // Толщина начала линии, 0 для обычной толщины, 1 для жирной\n\n  w1: Int = 0; // толщина конца линии\n\n  isAuto: boolean = false; // Признак связи, пригодной для автокоррекции\n\n  soft: boolean = false;\n\n  //  ~ : | I\n  style: string = \"\"; // Строковый стиль линии. Для двойных и тройных связей каждая линия указывается отдельно\n\n  align?: BondAlign; // Возможные режимы выравнивания двойной связи. x:перекрещенная, m:по центру, l:влево, r:вправо\n\n  arr0: boolean = false; // Стрелка в обратную сторону\n\n  arr1: boolean = false; // Стрелка по направлению линии\n\n  ext: \"\" | \"o\" | \"s\" = \"\"; // for _o = 'o', for _s = 's'\n\n  brk: boolean = false; // Устанавливается для конструкции типа -#a-#b-#c-, для связи, предшествующей существующему узлу\n\n  isNeg: boolean = false; // Использовался символ `\n\n  isCorr: boolean = false; // Выполнена коррекция наклона с 30 до 60 градусов\n\n  isCycle: boolean = false; // Циклическая связь. Всегда true для _o и может быть для _s\n\n  middlePoints?: Point[]; // Дополнительные точки для искривленных связей.\n  // Если связь имеет дополнительные точки, то она не будет мержиться с другими связями между этими же узлами\n\n  // Position calculate for second part of bond\n  calcPt(): Point {\n    return this.nodes[0]!.pt.plus(this.dir!);\n  }\n\n  // Get another node of bond\n  other(node: ChemNode): ChemNode | undefined {\n    if (this.nodes.length !== 2) return undefined;\n    if (this.nodes[0] === node) return this.nodes[1];\n    if (this.nodes[1] === node) return this.nodes[0];\n    return undefined;\n  }\n\n  override walk(visitor: Visitor) {\n    visitor.bond?.(this);\n  }\n\n  setHydrogen() {\n    this.style = \":\";\n    this.n = 0.0;\n  }\n\n  setCross() {\n    this.align = \"x\";\n  }\n\n  isCross() {\n    return this.align === \"x\";\n  }\n\n  checkText() {\n    // Связь считается текстовой, если она расположена горизонтально и имеет длину =1\n    const { dir } = this;\n    this.isText = dir ? is0(dir.y) && is0(Math.abs(dir.x) - 1) : false;\n  }\n\n  linearText(): string {\n    if (this.isAuto) {\n      let res: string = this.tx;\n      if (this.isNeg) res = `\\`${res}`;\n      if (is0(this.n)) res += \"0\";\n      return res;\n    }\n    return this.tx;\n  }\n\n  isHorizontal(): boolean {\n    const { dir } = this;\n    return dir ? !is0(dir.x) && is0(dir.y) : false;\n  }\n\n  debugText(): string {\n    const bondTextStd = (it: ChemBond) =>\n      `${it.nodes[0]?.index}` +\n      `(${it.soft ? \"~\" : \"\"}${it.dir?.polarAngleDeg().toFixed(0)}` +\n      `${it.n !== 1.0 ? `*${toa(it.n)}` : \"\"})` +\n      `${it.nodes[1]?.index}`;\n\n    const bondTextExt = (bond: ChemBond) =>\n      `${bond.linearText()}${bond.nodes.map((it) => it?.index)}`;\n\n    return this.nodes.length === 2 ? bondTextStd(this) : bondTextExt(this);\n  }\n\n  isVisible(): boolean {\n    if (this.isVerticalConnection()) return false;\n    return !is0(this.n) || !!this.style;\n  }\n\n  /**\n   * Vertical connection of atoms without bond drawing.\n   * Most commonly used in /N<_(y-.5)H>\\ or \\N<_(y.5)H/>\n   */\n  isVerticalConnection(): boolean {\n    const { dir, nodes } = this;\n    if (!dir || nodes.length !== 2) return false;\n    if (!nodes[0] || isNodeHidden(nodes[0])) return false;\n    if (!nodes[1] || isNodeHidden(nodes[1])) return false;\n    return is0(dir.x) && is0(Math.abs(dir.y) - 0.5);\n  }\n}\n","/* eslint-disable max-classes-per-file */\nimport { ChemBond } from \"./ChemBond\";\nimport { ChemObj } from \"./ChemObj\";\nimport { Visitor } from \"./Visitor\";\nimport { ChemChargeOwner } from \"./ChemChargeOwner\";\nimport { ChemCharge } from \"./ChemCharge\";\nimport { ChemNode, ChemNodeOptPair } from \"./ChemNode\";\nimport { ChemK } from \"./ChemK\";\n\n// Pairs of open and closed brackets\nexport const bracketPairs: Record<string, string> = {\n  \"(\": \")\",\n  \"[\": \"]\",\n  \"{{\": \"}}\",\n};\n\nexport interface CommonBracket {\n  text: string;\n  color?: string;\n  nodes: ChemNodeOptPair;\n  bond?: ChemBond;\n}\n\nexport class ChemBracketBegin extends ChemObj implements CommonBracket {\n  constructor(public readonly text: string) {\n    super();\n  }\n\n  end?: ChemBracketEnd;\n\n  isText?: boolean;\n\n  bond?: ChemBond;\n\n  color?: string;\n\n  nodes: ChemNodeOptPair = [undefined, undefined];\n\n  padding?: number[];\n\n  override walk(visitor: Visitor) {\n    visitor.bracketBegin?.(this);\n  }\n}\n\nexport class ChemBracketEnd\n  extends ChemObj\n  implements ChemChargeOwner, CommonBracket\n{\n  constructor(\n    public readonly text: string,\n    public readonly begin: ChemBracketBegin,\n    nodeIn: ChemNode\n  ) {\n    super();\n    this.nodes[0] = nodeIn;\n  }\n\n  charge?: ChemCharge = undefined;\n\n  n: ChemK = new ChemK(1);\n\n  bond?: ChemBond;\n\n  nodes: ChemNodeOptPair = [undefined, undefined];\n\n  // this.bond = null\n  override walk(visitor: Visitor) {\n    visitor.bracketEnd?.(this);\n  }\n\n  get nodeIn() {\n    return this.nodes[0];\n  }\n\n  get color(): string | undefined {\n    return this.begin.color;\n  }\n}\n\nexport const getBracketsContent = (\n  begin: ChemBracketBegin,\n  commands: ChemObj[]\n): ChemObj[] => {\n  const { end } = begin;\n  let start = 0;\n  while (start < commands.length && commands[start] !== begin) start++;\n  let stop = start;\n  while (stop < commands.length && commands[stop] !== end) stop++;\n  return commands.slice(start + 1, stop);\n};\n","import { CoeffPosOrAngle, isLeftCoeffA } from \"../types/CoeffPos\";\nimport { Double } from \"../types\";\nimport { romanNum } from \"../utils/romanNum\";\n\nexport class ChemCharge {\n  get isLeft(): boolean {\n    // ⁺N\n    return isLeftCoeffA(this.pos);\n  }\n\n  constructor(\n    public readonly text: string, // Text description, for example: '2+'\n    public readonly value: Double, // number value, for example: 2\n    public readonly pos: CoeffPosOrAngle = \"RT\", // relative position of charge from $pos()\n    public readonly isRound: boolean = false // A sign of drawing a charge inside a circle\n  ) {}\n}\n\nconst leftSigned = /(^|(^[-+]))\\d+$/;\nconst rightSigned = /^\\d+[-+]$/;\nconst minuses = new Set([\"-\", \"--\", \"---\"]);\nconst pluses = new Set([\"+\", \"++\", \"+++\"]);\n\n/**\n * Create charge object from text description\n * Особенностью любого текстового описания заряда в том, что при компиляции происходят попытки,\n * начиная с одного символа и увеличивая количество символов до тех пор, пока это валидное выражение.\n * То есть, не может быть такого, что двухсимвольное описание валидно, а односимвольное - нет.\n */\nexport const createCharge = (\n  chargeDescr: string,\n  pos: CoeffPosOrAngle = \"RT\"\n): ChemCharge | undefined => {\n  if (chargeDescr === \"\") return undefined;\n  const text = chargeDescr // Replace similar characters\n    .replace(\"–\", \"-\") // \\u2013\n    .replace(\"−\", \"-\"); // \\u2212\n  // One or more minuses:\tO^--\n  if (minuses.has(text)) return new ChemCharge(text, -text.length, pos);\n  // One or more pluses: Zn^++\n  if (pluses.has(text)) return new ChemCharge(text, text.length, pos);\n  // A number with a plus or minus front: S^+6, O^-2\n  if (leftSigned.test(text)) return new ChemCharge(text, +text, pos);\n  // A number with plus or minus behind: Ca^2+, PO4^3-\n  if (rightSigned.test(text))\n    return new ChemCharge(text, +`${text.slice(-1)}${text.slice(0, -1)}`, pos);\n  if (text === \"+o\") return new ChemCharge(\"+\", 1.0, pos, true);\n  if (text === \"-o\") return new ChemCharge(\"-\", -1.0, pos, true);\n  const v = romanNum[text];\n  if (v) return new ChemCharge(text.toUpperCase(), v, pos);\n  return undefined;\n};\n","import { ChemSubObj } from \"./ChemSubObj\";\nimport { Visitor } from \"./Visitor\";\n\nexport class ChemComma extends ChemSubObj {\n  override walk(visitor: Visitor) {\n    visitor.comma?.(this);\n  }\n}\n\nexport const instChemComma: ChemComma = new ChemComma();\n","import { ChemSubObj } from \"./ChemSubObj\";\nimport { Visitor } from \"./Visitor\";\n\nexport class ChemComment extends ChemSubObj {\n  constructor(public readonly text: string) {\n    super();\n  }\n\n  override walk(visitor: Visitor) {\n    visitor.comment?.(this);\n  }\n}\n","import { ChemSubObj } from \"./ChemSubObj\";\nimport { Visitor } from \"./Visitor\";\n\n/**\n * Abstract component\n * For example: {R}-OH\n * Created by PeterWin on 29.04.2017.\n */\nexport class ChemCustom extends ChemSubObj {\n  constructor(public readonly text: string) {\n    super();\n  }\n\n  override walk(visitor: Visitor) {\n    visitor.custom?.(this);\n  }\n}\n","import { LangParams, Lang } from \"../lang\";\n\nexport class ChemError extends Error {\n  readonly msgId: string;\n\n  readonly params?: LangParams;\n\n  constructor(msgId: string, params?: LangParams) {\n    super(Lang.tr(msgId, params));\n    this.msgId = msgId;\n    this.params = params;\n  }\n\n  getMessage(locale?: string): string {\n    return Lang.tr(this.msgId, this.params, locale);\n  }\n}\n\nexport const getErrorMessage = (err: Error, locale?: string): string => {\n  if (err instanceof ChemError) {\n    if (!locale) return err.getMessage();\n    const oldLang = Lang.curLang;\n    Lang.curLang = locale;\n    const msg = err.getMessage(locale);\n    Lang.curLang = oldLang;\n    return msg;\n  }\n  return err.message;\n};\n","import { SrcMapItem } from \"../compiler/sourceMap/SrcMapItem\";\nimport { Double } from \"../types\";\nimport { ChemObj } from \"./ChemObj\";\nimport { Visitor } from \"./Visitor\";\nimport { ChemAgent } from \"./ChemAgent\";\nimport { getErrorMessage } from \"./ChemError\";\nimport { calcMass } from \"../inspectors/calcMass\";\nimport { makeTextFormula } from \"../inspectors/makeTextFormula\";\nimport { rulesHtml } from \"../textRules/rulesHtml\";\nimport { isTextFormula } from \"../inspectors/isTextFormula\";\nimport { getSrcItemsForObject } from \"../compiler/sourceMap\";\n\nexport class ChemExpr extends ChemObj {\n  error?: Error;\n\n  // Source description\n  src0: string = \"\";\n\n  // Description after preprocessing\n  src: string = \"\";\n\n  // Entities: reagents and operations\n  entities: ChemObj[] = [];\n\n  srcMap?: SrcMapItem[];\n\n  // Check for success. If false, then an error.\n  isOk(): boolean {\n    return !this.error;\n  }\n\n  // Extended error message. Empty string, if not error\n  getMessage(locale?: string): string {\n    const { error } = this;\n    return error ? getErrorMessage(error, locale) : \"\";\n  }\n\n  override walk(visitor: Visitor) {\n    for (const entity of this.entities) {\n      visitor.entityPre?.(entity);\n      if (visitor.isStop) return;\n      entity.walk(visitor);\n      if (visitor.isStop) return;\n      visitor.entityPost?.(entity);\n      if (visitor.isStop) return;\n    }\n  }\n\n  getAgents(): ChemAgent[] {\n    // Правильно было бы использовать walk.\n    // Но этот вариант работает быстрее, т.к. walk обходит все подчиненные объекты.\n    // А здесь просто цикл по сущностям верхего уровня, которых обычно не более 10.\n    const result = this.entities.filter(\n      (entity: ChemObj) => entity instanceof ChemAgent\n    );\n    return result as ChemAgent[];\n  }\n\n  findMapItems(target: ChemObj): SrcMapItem[] {\n    return getSrcItemsForObject(target, this.srcMap);\n  }\n\n  srcMapItemText(item: SrcMapItem): string {\n    return this.src.slice(item.begin, item.end);\n  }\n\n  /**\n   * Если выражение состоит более чем из одного агента (а это не редкость),\n   * то считать его общую массу через calcMass не имеет смысла.\n   * Данная функция считает массу каждого агента отдельно.\n   * @param applyK Если false, то не учитываются коэффициенты перед агентами.\n   */\n  mass(applyK: boolean = true): Double[] {\n    return this.getAgents().map((it) => calcMass(it, applyK));\n  }\n\n  /**\n   * This method has been added for compatibility with previous versions.\n   * It is recommended to explicitly use function makeTextFormula.\n   * @deprecated\n   */\n  html(): string {\n    return makeTextFormula(this, rulesHtml);\n  }\n\n  /**\n   * This method has been added for compatibility with previous versions.\n   * It is recommended to explicitly use function isTextFormula.\n   * @deprecated\n   */\n  isLinear(): boolean {\n    return isTextFormula(this);\n  }\n\n  static createWithError(error: Error, src: string) {\n    const expr = new ChemExpr();\n    expr.error = error;\n    expr.src0 = src;\n    expr.src = src;\n    return expr;\n  }\n}\n","// Chemical Coefficient.\n// Can be number or string (abstract coefficient: C'n'H'2n+2')\nimport { Double } from \"../types\";\nimport { toa } from \"../math\";\nimport { CoeffPos } from \"../types/CoeffPos\";\n\nexport class ChemK {\n  readonly num: Double;\n\n  readonly text: string;\n\n  pos?: CoeffPos;\n\n  color?: string;\n\n  constructor(n: Double, pos?: CoeffPos);\n\n  constructor(text: string, pos?: CoeffPos);\n\n  constructor(k: number | string, pos?: CoeffPos) {\n    if (typeof k === \"number\") {\n      this.num = k;\n      this.text = \"\";\n    } else {\n      this.text = k;\n      this.num = NaN;\n    }\n    this.pos = pos;\n  }\n\n  static readonly one = new ChemK(1);\n\n  // Na2S.  Is specified for Na and not for S\n  isSpecified() {\n    return !!this.text || (this.num !== 1 && !Number.isNaN(this.num));\n  }\n\n  isNumber() {\n    return !Number.isNaN(this.num);\n  }\n\n  isAbstract() {\n    return !this.isNumber();\n  }\n\n  isInt(): boolean {\n    // eslint-disable-next-line no-bitwise\n    return this.num === ~~this.num;\n  }\n\n  equals(k: ChemK | string | number): boolean {\n    if (typeof k === \"number\" && this.isNumber()) {\n      return this.num === k;\n    }\n    if (typeof k === \"string\" && !this.isNumber()) {\n      return this.text === k;\n    }\n    if (k instanceof ChemK) {\n      return this.text ? this.text === k.text : this.num === k.num;\n    }\n    return false;\n  }\n\n  toString() {\n    return this.isNumber() ? toa(this.num) : this.text;\n  }\n}\n","/* eslint-disable max-classes-per-file */\nimport { ChemObj } from \"./ChemObj\";\nimport { Visitor } from \"./Visitor\";\nimport { ChemK } from \"./ChemK\";\nimport { ChemNodeOptPair } from \"./ChemNode\";\n/**\n * В версиях до 1.1 включительно умножитель действует только начиная с символа умножения\n * Например, CuSO4*5H2O. Здесь один умножитель.\n * Проблема начинается, когда появляется коэффициент перед агентом.\n * Вот пример уравнения: https://ru.wikipedia.org/wiki/%D0%A1%D1%83%D0%BB%D1%8C%D1%84%D0%B0%D1%82_%D0%B6%D0%B5%D0%BB%D0%B5%D0%B7%D0%B0(III)-%D0%B0%D0%BC%D0%BC%D0%BE%D0%BD%D0%B8%D1%8F\n * Fe2(SO4)3 + (NH4)2SO4 + 24H2O \"0^oC\"-> 2NH4Fe(SO4)2*12H2O\"|v\"\n * Здесь коэффициент 2 относится ко всему последнему агенту.\n * Проблема в том, что невозможно указать коэффициент для первого множителя.\n * Пример - формула ржавчины: https://de.wikipedia.org/wiki/Rost\n *  x FeᴵᴵO · y Fe₂ᴵᴵᴵO₃ · z H₂O\n * Таким образом, есть двусмысленность.\n * Что означает первый коэффициент: общий или только для первого множителя?\n * Принято решение, что первый коэффициент действует на весь агент.\n * А если нужно использовать коэффициент только для первого множителя, нужно использовать скобки\n * ('x'Fe(ii)O*'y'Fe(iii)2O3*'z'H2O)\n * Это значит, что внутри скобок может встречаться коэффициент.\n * Такая возможность появляется только начиная с версии 1.2!\n */\n\n// Начало конструкции, умножающей последующее содержимое на указанный коэффициент\n// Кроме того, является мостиком, т.е. образует новую подцепь\n// example: CuSO4*5H2O\n// isFirst для коэффициента, который стоит первым внутри скобок (2FeO*3H2O)\nexport class ChemMul extends ChemObj {\n  // если соседние узлы внутри скобок, то они здесь не заполняются.\n  // Н.р для \"Ca(OH)2*3Mg(OH)2\" после компиляции nodes=[undefined, \"Mg\"]\n  nodes: ChemNodeOptPair = [undefined, undefined];\n\n  constructor(\n    public readonly n: ChemK,\n    public readonly isFirst: boolean,\n    public readonly color?: string\n  ) {\n    super();\n  }\n\n  override walk(visitor: Visitor) {\n    visitor.mul?.(this);\n  }\n}\n\n// Конец множителя.\n// Не участвует в выводе.\n// Предназначен для вычислительных алгоритмов, использующих стек, чтобы выполнить pop\nexport class ChemMulEnd extends ChemObj {\n  constructor(public readonly begin: ChemMul) {\n    super();\n  }\n\n  override walk(visitor: Visitor) {\n    visitor.mulEnd?.(this);\n  }\n}\n","import { Int } from \"../types\";\nimport { Point } from \"../math/Point\";\nimport { ChemCharge } from \"./ChemCharge\";\nimport { ChemChargeOwner } from \"./ChemChargeOwner\";\nimport { ChemObj } from \"./ChemObj\";\nimport { ChemNodeItem } from \"./ChemNodeItem\";\nimport { ChemBond } from \"./ChemBond\";\nimport { Visitor } from \"./Visitor\";\n\n/**\n * Priority table for different items\n * 1 = comment\n * 2 = abstract item\n * 3 = H element\n * 4 = radicals and all elements (except C and H)\n * 5 = C element\n * 6 = item with bCenter flag\n */\nconst enum ItemPriority {\n  NA,\n  Comment,\n  Abstract,\n  Hydrogen,\n  Default,\n  Carbon,\n  Explicit,\n}\n\nexport class ChemNode extends ChemObj implements ChemChargeOwner {\n  constructor(pt?: Point) {\n    super();\n    this.pt = (pt ?? Point.zero).clone();\n  }\n\n  pt: Point;\n\n  charge?: ChemCharge = undefined;\n\n  items: ChemNodeItem[] = [];\n\n  index: Int = -1; // index of node in CAgent.nodes array\n\n  chain: Int = 0; // chain number\n\n  subChain: Int = 0;\n\n  autoMode = false;\n\n  bonds: Set<ChemBond> = new Set();\n\n  fixed = false;\n\n  color?: string;\n\n  atomColor?: string;\n\n  bCenter = false; // Признак центрального узла для центрирования агентов в выражении\n\n  override walk(visitor: Visitor) {\n    visitor.nodePre?.(this);\n    if (visitor.isStop) return;\n    for (const it of this.items) {\n      it.walk(visitor);\n      if (visitor.isStop) return;\n    }\n    visitor.nodePost?.(this);\n  }\n\n  addBond(bond: ChemBond) {\n    this.bonds.add(bond);\n  }\n\n  getCenterItem(): ChemNodeItem | null {\n    let curPriority = ItemPriority.NA;\n    let maxPriority = ItemPriority.NA;\n    let foundItem: ChemNodeItem | null = null;\n    this.walk({\n      itemPre() {\n        curPriority = ItemPriority.NA;\n      },\n      comment() {\n        curPriority = ItemPriority.Comment;\n      },\n      custom() {\n        curPriority = ItemPriority.Abstract;\n      },\n      radical() {\n        curPriority = ItemPriority.Default;\n      },\n      atom(obj) {\n        switch (obj.id) {\n          case \"H\":\n          case \"D\":\n          case \"T\":\n            curPriority = ItemPriority.Hydrogen;\n            break;\n          case \"C\":\n            curPriority = ItemPriority.Carbon;\n            break;\n          default:\n            curPriority = ItemPriority.Default;\n            break;\n        }\n      },\n      itemPost(obj) {\n        if (obj.bCenter) {\n          curPriority = ItemPriority.Explicit;\n        }\n        if (curPriority > maxPriority) {\n          maxPriority = curPriority;\n          foundItem = obj;\n        }\n      },\n    });\n    return foundItem;\n  }\n}\n\nexport type ChemNodeOpt = ChemNode | undefined;\nexport type ChemNodeOptPair = [ChemNodeOpt, ChemNodeOpt];\n","import { Double, Int } from \"../types\";\nimport { ChemObj } from \"./ChemObj\";\nimport { ChemSubObj } from \"./ChemSubObj\";\nimport { ChemK } from \"./ChemK\";\nimport { Visitor } from \"./Visitor\";\nimport { ChemCharge } from \"./ChemCharge\";\n\nexport interface LewisDot {\n  angle?: number;\n  pos?: number; // [0;7] 0:Lb, 1:Br, 2:Bl, 3:Rb, 4:Rt, 5:Tl, 6:Tr, 7:Lt\n  color?: string;\n  margin?: number;\n}\n\nexport class ChemNodeItem extends ChemObj {\n  constructor(public readonly obj: ChemSubObj, public n: ChemK = ChemK.one) {\n    super();\n  }\n\n  charge?: ChemCharge;\n\n  // Special mass.\n  // If specified, then ignore mass of sub object\n  mass?: Double;\n\n  atomNum?: Int | \"\"; // признак вывода атомного номера (для ядерных реакций).\n\n  color?: string; // общий цвет\n\n  atomColor?: string; // цвет атомов\n\n  bCenter?: boolean; // признак приоритетности элемента, задаваемый при помощи обратного апострофа: H3C`O|\n\n  dots?: LewisDot[];\n  // this.dashes = [];\n\n  override walk(visitor: Visitor) {\n    visitor.itemPre?.(this);\n    if (!visitor.isStop) this.obj.walk(visitor);\n    if (!visitor.isStop) visitor.itemPost?.(this);\n  }\n}\n","/**\n * Base class for all chemical objects\n * Supports information about the position of the object in the source description (usually after the preprocessor)\n * Created by PeterWin on 29.05.2022.\n */\nimport { Visitor } from \"./Visitor\";\n\nexport abstract class ChemObj {\n  abstract walk<T extends Visitor>(visitor: T): void;\n\n  walkExt<T extends Visitor>(visitor: T): T {\n    this.walk(visitor);\n    return visitor;\n  }\n}\n","import { ChemObj } from \"./ChemObj\";\nimport { Visitor } from \"./Visitor\";\nimport { ChemComment } from \"./ChemComment\";\n\n// Операция в химическом выражении\n// div - is divide expression by parts. =, -> are dividers. + is not divider\n\nexport class ChemOp extends ChemObj {\n  constructor(\n    public readonly srcText: string,\n    public readonly dstText: string,\n    public readonly div: boolean\n  ) {\n    super();\n  }\n\n  commentPre?: ChemComment;\n\n  commentPost?: ChemComment;\n\n  color?: string;\n\n  override walk(visitor: Visitor) {\n    visitor.operation?.(this);\n  }\n}\n","import { ChemSubObj } from \"./ChemSubObj\";\nimport { Visitor } from \"./Visitor\";\nimport { ElementId } from \"../types/ElementId\";\nimport { Int } from \"../types\";\nimport { ElemList } from \"./ElemList\";\n\nlet radicals: Record<string, ChemRadical> | null = null;\n\ntype DescrRec = [ElementId, Int];\ntype DescrItem = [string[], DescrRec[]];\nconst descriptions: DescrItem[] = [\n  [\n    [\"Me\"],\n    [\n      [\"C\", 1],\n      [\"H\", 3],\n    ],\n  ],\n  [\n    [\"Et\"],\n    [\n      [\"C\", 2],\n      [\"H\", 5],\n    ],\n  ],\n  [\n    [\"Ph\"],\n    [\n      [\"C\", 6],\n      [\"H\", 5],\n    ],\n  ],\n  [\n    [\"Pr\", \"n-Pr\", \"Pr-n\"],\n    [\n      [\"C\", 3],\n      [\"H\", 7],\n    ],\n  ],\n  [\n    [\"iPr\", \"i-Pr\", \"Pr-i\"],\n    [\n      [\"C\", 3],\n      [\"H\", 7],\n    ],\n  ],\n  [\n    [\"Bu\", \"nBu\", \"n-Bu\", \"Bu-n\"],\n    [\n      [\"C\", 4],\n      [\"H\", 9],\n    ],\n  ],\n  // tert-butyl\n  [\n    [\"t-Bu\", \"Bu-t\", \"tBu\"],\n    [\n      [\"C\", 4],\n      [\"H\", 9],\n    ],\n  ],\n  [\n    [\"i-Bu\", \"Bu-i\", \"iBu\"],\n    [\n      [\"C\", 4],\n      [\"H\", 9],\n    ],\n  ],\n  // sec-butyl\n  [\n    [\"s-Bu\", \"Bu-s\", \"sBu\"],\n    [\n      [\"C\", 4],\n      [\"H\", 9],\n    ],\n  ],\n  [\n    [\"Ac\"],\n    [\n      [\"C\", 1],\n      [\"H\", 3],\n      [\"C\", 1],\n      [\"O\", 1],\n    ],\n  ],\n  [\n    [\"CoA\"],\n    [\n      [\"C\", 21],\n      [\"H\", 35],\n      [\"N\", 7],\n      [\"O\", 16],\n      [\"P\", 3],\n    ],\n  ], // https://en.wikipedia.org/wiki/Coenzyme_A\n  [\n    [\"Tf\"],\n    [\n      [\"C\", 1],\n      [\"F\", 3],\n      [\"S\", 1],\n      [\"O\", 2],\n    ],\n  ], // TfOH = CF3SO3H, Tf = CF3SO2 https://en.wikipedia.org/wiki/Trifluoromethylsulfonyl\n  // MsOH https://en.wikipedia.org/wiki/Methanesulfonic_acid\n];\n\nexport class ChemRadical extends ChemSubObj {\n  constructor(public readonly label: string, public readonly items: ElemList) {\n    super();\n  }\n\n  override walk(visitor: Visitor) {\n    visitor.radical?.(this);\n  }\n\n  static get dict(): Record<string, ChemRadical> {\n    if (radicals) return radicals;\n    const newDict: Record<string, ChemRadical> = {};\n    descriptions.forEach((descr) => {\n      const [left, right] = descr;\n      const elemList = new ElemList();\n      right.forEach(([id, n]) => elemList.addElemById(id, n));\n      left.forEach((it) => {\n        newDict[it] = new ChemRadical(it, elemList);\n      });\n    });\n    radicals = newDict;\n    return newDict;\n  }\n}\n","/**\n * Subordinate object for the node element\n * Created by PeterWin on 29.05.2022.\n */\nimport { ChemObj } from \"./ChemObj\";\n\nexport abstract class ChemSubObj extends ChemObj {}\n","/**\n * Elements list\n * Each element is record {id, elem, n}\n * For abstract  elem is null\n * Created by PeterWin on 29.04.2017.\n */\nimport { ElemRecord } from \"./ElemRecord\";\nimport { Double } from \"../types\";\nimport { ElementId, IsotopeId } from \"../types/ElementId\";\nimport { makeChargeText } from \"./makeChargeText\";\nimport { ChemAtom } from \"./ChemAtom\";\nimport { findElement } from \"./PeriodicTable\";\nimport { ChemRadical } from \"./ChemRadical\";\n\nexport class ElemList {\n  readonly list: ElemRecord[] = [];\n\n  charge: Double = 0.0;\n\n  toString() {\n    let result: string = this.list.reduce(\n      (acc, elemRec) => `${acc}${elemRec}`,\n      \"\"\n    );\n    const chargeText = makeChargeText(this.charge);\n    if (chargeText !== \"\") {\n      result += `^${chargeText}`;\n    }\n    return result;\n  }\n\n  findAtom(atom?: ChemAtom): ElemRecord | undefined {\n    return atom ? this.list.find((it) => it.elem === atom) : undefined;\n  }\n\n  // Example: list.findById(\"He\")\n  findById(id: ElementId | IsotopeId): ElemRecord | undefined {\n    return this.findAtom(findElement(id));\n  }\n\n  findCustom(id: string): ElemRecord | undefined {\n    return this.list.find((it) => !it.elem && it.id === id);\n  }\n\n  findKey(key: string): ElemRecord | undefined {\n    return this.list.find((it) => it.key === key);\n  }\n\n  findRec(rec?: ElemRecord): ElemRecord | undefined {\n    if (!rec) return undefined;\n    return rec.elem ? this.findAtom(rec.elem) : this.findCustom(rec.id);\n  }\n\n  private addElemRec(rec: ElemRecord): this {\n    const foundRec = this.findRec(rec);\n    if (!foundRec) {\n      this.list.push(rec);\n    } else {\n      foundRec.n += rec.n;\n    }\n    return this;\n  }\n\n  addElemById(id: string, n: Double = 1.0): this {\n    return this.addElemRec(new ElemRecord(id, n, false));\n  }\n\n  addAtom(atom: ChemAtom, n: Double = 1.0): this {\n    return this.addElemRec(new ElemRecord(atom, n));\n  }\n\n  addElem(elem: ElemRecord, n: Double = 1.0): this {\n    return this.addElemRec(new ElemRecord(elem, n));\n  }\n\n  addCustom(text: string, n: Double = 1.0): this {\n    return this.addElemRec(new ElemRecord(text, n, true));\n  }\n\n  addList(srcList: ElemList): this {\n    srcList.list.forEach((it) => this.addElem(it));\n    this.charge += srcList.charge;\n    return this;\n  }\n\n  addRadical(radical?: ChemRadical): this {\n    return radical ? this.addList(radical.items) : this;\n  }\n\n  scale(k: Double) {\n    if (k !== 1.0) {\n      this.charge *= k;\n      this.list.forEach((it) => {\n        // eslint-disable-next-line no-param-reassign\n        it.n *= k;\n      });\n    }\n  }\n\n  // sort by Hill system\n  sortByHill(): this {\n    this.list.sort((a: ElemRecord, b: ElemRecord): number => {\n      const aid: string = a.id;\n      const bid: string = b.id;\n      if (!a.elem && !b.elem) return aid.localeCompare(bid);\n      if (!a.elem) return 1;\n      if (!b.elem) return -1;\n      if (aid === bid) return 0;\n      if (aid === \"C\") return -1;\n      if (bid === \"C\") return 1;\n      if (aid === \"H\") return -1;\n      if (bid === \"H\") return 1;\n      return aid.localeCompare(bid);\n    });\n    return this;\n  }\n}\n","import { Double } from \"../types\";\nimport { ChemAtom } from \"./ChemAtom\";\nimport { findElement } from \"./PeriodicTable\";\nimport { k2s } from \"./k2s\";\n\nexport class ElemRecord {\n  readonly id: string;\n\n  readonly elem?: ChemAtom;\n\n  n: Double;\n\n  constructor(id: string);\n\n  constructor(id: string, n: Double, isCustom: boolean);\n\n  constructor(atom: ChemAtom);\n\n  constructor(atom: ChemAtom, n: Double);\n\n  constructor(src: ElemRecord);\n\n  constructor(src: ElemRecord, n: Double);\n\n  constructor(\n    a: string | ChemAtom | ElemRecord,\n    n: Double = 1.0,\n    isCustom: boolean = false\n  ) {\n    if (typeof a === \"string\") {\n      this.id = a;\n      this.elem = isCustom ? undefined : findElement(a);\n      this.n = n;\n    } else if (a instanceof ChemAtom) {\n      this.id = a.id;\n      this.elem = a;\n      this.n = n;\n    } else {\n      this.id = a.id;\n      this.elem = a.elem;\n      this.n = n * a.n;\n    }\n  }\n\n  get key(): string {\n    return this.elem ? this.id : `{${this.id}}`;\n  }\n\n  toString() {\n    return `${this.key}${k2s(this.n)}`;\n  }\n}\n","import { ChemAtom } from \"./ChemAtom\";\nimport { Double, Int } from \"../types\";\nimport { ElementId, IsotopeId } from \"../types/ElementId\";\n\ntype ElementMap = Record<ElementId, ChemAtom>;\nlet elementsCache: readonly ChemAtom[] | null = null;\nlet dictCache: ElementMap | null = null;\nlet isotopesCache: readonly ChemAtom[] | null = null;\nlet isotopeDictCache: Record<IsotopeId, ChemAtom> | null = null;\n\nexport const findElement = (id: string): ChemAtom | undefined =>\n  PeriodicTable.dict[id as ElementId] ||\n  PeriodicTable.isotopesDict[id as IsotopeId];\n\nexport const PeriodicTable = Object.freeze({\n  get elements(): readonly ChemAtom[] {\n    if (elementsCache) return elementsCache;\n    const list = Object.freeze(\n      (Object.keys(massMap) as ElementId[]).map(\n        (id, index) =>\n          new ChemAtom(index + 1, id, massMap[id][0], {\n            epsilonMass: massMap[id][1],\n          })\n      )\n    );\n    elementsCache = list;\n    return list;\n  },\n  get dict(): ElementMap {\n    if (dictCache) return dictCache;\n    const map = {} as ElementMap;\n    this.elements.forEach((elem) => {\n      map[elem.id as ElementId] = elem;\n    });\n    const finalMap = Object.freeze(map);\n    dictCache = finalMap;\n    return finalMap;\n  },\n  get isotopes(): readonly ChemAtom[] {\n    if (isotopesCache) return isotopesCache;\n    const list = Object.freeze(\n      isotopesDef.map(\n        ([n, id, mass, stable]) => new ChemAtom(n, id, mass, { stable })\n      )\n    );\n    isotopesCache = list;\n    return list;\n  },\n  get isotopesDict(): Record<IsotopeId, ChemAtom> {\n    if (isotopeDictCache) return isotopeDictCache;\n    const map = {} as Record<IsotopeId, ChemAtom>;\n    this.isotopes.forEach((elem) => {\n      map[elem.id as IsotopeId] = elem;\n    });\n    const finalMap = Object.freeze(map);\n    isotopeDictCache = finalMap;\n    return finalMap;\n  },\n});\n\n// Main source:  Table 1 / Abridged standard atomic weight\n// from https://www.degruyter.com/document/doi/10.1515/pac-2019-0603/html\n// and for Elements without stable isotopes: Table 2 from https://iupac.qmul.ac.uk/AtWt/\nconst massMap: Record<ElementId, [Double, Double] | [Double]> = {\n  H: [1.008, 0.0002],\n  He: [4.0026, 0.0001],\n  Li: [6.94, 0.06],\n  Be: [9.0122, 0.0001],\n  B: [10.81, 0.02],\n  C: [12.011, 0.002],\n  N: [14.007, 0.001],\n  O: [15.999, 0.001],\n  F: [18.998, 0.001],\n  Ne: [20.18, 0.001],\n  Na: [22.99, 0.001],\n  Mg: [24.305, 0.002],\n  Al: [26.982, 0.001],\n  Si: [28.085, 0.001],\n  P: [30.974, 0.001],\n  S: [32.06, 0.02],\n  Cl: [35.45, 0.01],\n  Ar: [39.95, 0.16],\n  K: [39.098, 0.001],\n  Ca: [40.078, 0.004],\n  Sc: [44.956, 0.001],\n  Ti: [47.867, 0.001],\n  V: [50.942, 0.001],\n  Cr: [51.996, 0.001],\n  Mn: [54.938, 0.001],\n  Fe: [55.845, 0.002],\n  Co: [58.933, 0.001],\n  Ni: [58.693, 0.001],\n  Cu: [63.546, 0.003],\n  Zn: [65.38, 0.02],\n  Ga: [69.723, 0.001],\n  Ge: [72.63, 0.008],\n  As: [74.922, 0.001],\n  Se: [78.971, 0.008],\n  Br: [79.904, 0.003],\n  Kr: [83.798, 0.002],\n  Rb: [85.468, 0.001],\n  Sr: [87.62, 0.01],\n  Y: [88.906, 0.001],\n  Zr: [91.224, 0.002],\n  Nb: [92.906, 0.001],\n  Mo: [95.95, 0.01],\n  Tc: [97],\n  Ru: [101.07, 0.02],\n  Rh: [102.91, 0.01],\n  Pd: [106.42, 0.01],\n  Ag: [107.87, 0.01],\n  Cd: [112.41, 0.01],\n  In: [114.82, 0.01],\n  Sn: [118.71, 0.01],\n  Sb: [121.76, 0.01],\n  Te: [127.6, 0.03],\n  I: [126.9, 0.01],\n  Xe: [131.29, 0.01],\n  Cs: [132.91, 0.01],\n  Ba: [137.33, 0.01],\n  La: [138.91, 0.01],\n  Ce: [140.12, 0.01],\n  Pr: [140.91, 0.01],\n  Nd: [144.24, 0.01],\n  Pm: [145],\n  Sm: [150.36, 0.02],\n  Eu: [151.96, 0.01],\n  Gd: [157.25, 0.03],\n  Tb: [158.93, 0.01],\n  Dy: [162.5, 0.01],\n  Ho: [164.93, 0.01],\n  Er: [167.26, 0.01],\n  Tm: [168.93, 0.01],\n  Yb: [173.05, 0.02],\n  Lu: [174.97, 0.01],\n  Hf: [178.49, 0.01],\n  Ta: [180.95, 0.01],\n  W: [183.84, 0.01],\n  Re: [186.21, 0.01],\n  Os: [190.23, 0.03],\n  Ir: [192.22, 0.01],\n  Pt: [195.08, 0.02],\n  Au: [196.97, 0.01],\n  Hg: [200.59, 0.01],\n  Tl: [204.38, 0.01],\n  Pb: [207.2, 1.1],\n  Bi: [208.98, 0.01],\n  Po: [209],\n  At: [210],\n  Rn: [222],\n  Fr: [223],\n  Ra: [226],\n  Ac: [227],\n  Th: [232.04, 0.01],\n  Pa: [231.04, 0.01],\n  U: [238.03, 0.01],\n  Np: [237],\n  Pu: [244],\n  Am: [243],\n  Cm: [247],\n  Bk: [247],\n  Cf: [251],\n  Es: [252],\n  Fm: [257],\n  Md: [258],\n  No: [259],\n  Lr: [262],\n  Rf: [267],\n  Db: [270],\n  Sg: [269],\n  Bh: [270],\n  Hs: [270],\n  Mt: [278],\n  Ds: [281],\n  Rg: [281],\n  Cn: [285],\n  Nh: [286],\n  Fl: [289],\n  Mc: [289],\n  Lv: [293],\n  Ts: [294],\n  Og: [294],\n};\n\nconst isotopesDef: [Int, IsotopeId, Double, boolean][] = [\n  [1, \"D\", 2.014101777844, true],\n  [1, \"T\", 3.01604928132, false],\n];\n","import { cmp } from \"../utils/cmp\";\nimport { getItemForced } from \"../utils/getItemForced\";\nimport { ifDef } from \"../utils/ifDef\";\nimport { Point } from \"../math/Point\";\nimport { ChemAgent } from \"./ChemAgent\";\nimport { ChemBond } from \"./ChemBond\";\nimport { ChemNode } from \"./ChemNode\";\n\nexport interface Cycle {\n  nodes: ChemNode[];\n  bonds: ChemBond[];\n  center?: Point;\n}\n\nexport const getCycleCenter = (cy: Cycle): Point => {\n  if (cy.center) return cy.center;\n  const L = cy.nodes.length;\n  const center =\n    L === 0\n      ? new Point()\n      : cy.nodes\n          .reduce((sum, node) => sum.iadd(node.pt), new Point())\n          .times(1 / L);\n  // eslint-disable-next-line no-param-reassign\n  cy.center = center;\n  return center;\n};\n\nconst vectorSign = (p: Point, q: Point): -1 | 0 | 1 => {\n  const d = p.x * q.y - p.y * q.x;\n  if (d === 0) return 0;\n  return d < 0 ? -1 : 1;\n};\n\n/**\n * @param cycle\n * @param bond\n * @returns -1 for CCW and 1 for CW or 0 if undefined\n */\nexport const calcBondSign = (cycle: Cycle, bond: ChemBond): -1 | 0 | 1 => {\n  const a = bond.nodes[0]?.pt;\n  const b = bond.nodes[1]?.pt;\n  if (!a || !b) return 0;\n  const c = getCycleCenter(cycle);\n  return vectorSign(b.minus(a), c.minus(a));\n};\n\nexport const bondSideSign = (bond: ChemBond, side: 0 | 1): -1 | 0 | 1 => {\n  const node = bond.nodes[side];\n  if (!node || !bond.dir) return 0;\n  const nearBonds = Array.from(node.bonds).filter(\n    (b) => b !== bond && b.isVisible() && b.dir\n  );\n  if (nearBonds.length !== 1) return 0;\n  return vectorSign(bond.dir, nearBonds[0]!.dir!);\n};\n\nexport class StructAnalyzer {\n  isInit: boolean = false;\n\n  cycles: Cycle[] = [];\n\n  bondsMap: Record<number, Cycle[]> = {};\n\n  constructor(public readonly agent: ChemAgent) {}\n\n  analyze() {\n    if (this.isInit) return;\n    this.isInit = true;\n    interface NodeDef {\n      node: ChemNode;\n      order: number;\n    }\n    const { nodes, bonds } = this.agent;\n    if (bonds.length < 3) return;\n    const NA = nodes.length * 2;\n    const nodesMap: NodeDef[] = nodes.map((node) => ({ node, order: NA }));\n\n    const unwindCycle = (start: NodeDef, usedNodes: Set<number>): Cycle => {\n      // Набор usedNodes предотвращает переходы в ответвления. И ограничивает поиск.\n      const queue: NodeDef[] = [start];\n      const cycle: Cycle = { nodes: [], bonds: [] };\n      let lastBond: ChemBond | undefined;\n      const nodesSet = new Set<ChemNode>();\n      for (;;) {\n        const curND = queue.shift();\n        if (!curND) break;\n        nodesSet.add(curND.node);\n        // eslint-disable-next-line\n        curND.node.bonds.forEach((bond) => {\r\n          const nextNode = bond.other(curND.node);\n          if (nextNode) {\n            const i = nextNode.index!;\n            const nextND = nodesMap[i]!;\n            if (usedNodes.has(i)) {\n              if (curND.order + 1 === nextND.order) {\n                queue.push(nextND);\n                cycle.bonds.push(bond);\n              } else if (curND.order === nextND.order) {\n                lastBond = bond;\n              }\n            }\n          }\n        });\n      }\n      if (lastBond) cycle.bonds.push(lastBond);\n      cycle.nodes = Array.from(nodesSet);\n      cycle.nodes.sort((a, b) => cmp(a.index!, b.index!));\n      cycle.bonds.sort((a, b) => cmp(a.index!, b.index!));\n      return cycle;\n    };\n\n    const createCycle = (n1: NodeDef, n2: NodeDef): Cycle | undefined => {\n      if (n2.order > n1.order) throw new Error(\"Invalid order\");\n      // Необходимо выполнить сканирование в обратном порядке, чтобы найти начало цикла\n      // Это гарантировано будет один узел.\n      const queue: NodeDef[] = [n1];\n      // Для циклов с нечетным числом узлов на стыке будет два узла с одинаковым порядком\n      if (n2.order === n1.order) queue.push(n2);\n      const usedNodes = new Set<number>();\n      for (;;) {\n        const curND = queue.shift();\n        if (!curND) break;\n        const i = curND.node.index!;\n        if (usedNodes.has(i)) {\n          // Найдено начало цикла\n          // Теперь нужно собрать все узлы и связи цикла. И избавиться от боковых ответвлений.\n          return unwindCycle(curND, usedNodes);\n        }\n        usedNodes.add(i);\n        curND.node.bonds.forEach((bond) => {\n          const nextNode = bond.other(curND.node);\n          if (nextNode) {\n            const nextND = nodesMap[nextNode.index!]!;\n            if (nextND.order + 1 === curND.order) {\n              queue.push(nextND);\n            }\n          }\n        });\n      }\n      return undefined;\n    };\n\n    const scan = (start: NodeDef) => {\n      if (start.order !== NA) return;\n      // eslint-disable-next-line no-param-reassign\n      start.order = 0;\n      const queue: NodeDef[] = [start];\n      const cyBonds = new Set<number>();\n      for (;;) {\n        const curND = queue.shift();\n        if (!curND) break;\n        curND.node.bonds.forEach((bond) => {\n          const nextNode = bond.other(curND.node);\n          if (nextNode) {\n            const nextND = nodesMap[nextNode.index]!;\n            const nextOrder = nextND.order;\n            if (nextOrder === NA) {\n              // Этот узел еще не вставал в очередь\n              nextND.order = curND.order + 1;\n              queue.push(nextND);\n            } else if (nextOrder >= curND.order) {\n              // Цикл создается если порядок след. узла не меньше, чем порядок предыдущего\n              if (!cyBonds.has(bond.index!)) {\n                // Необходимо предотвратить повторную обработку цикла.\n                // Актуально для циклов с нечетным числом узлов.\n                cyBonds.add(bond.index!);\n                const c = createCycle(nextND, curND);\n                if (c) this.cycles.push(c);\n              }\n            }\n          }\n        });\n      }\n    };\n    // Необходимо пройти по всем узлам, т.к. не гарантируется, что все узлы агента в одной цепи.\n    // Поэтому сканирование не обязательно обходит все узлы.\n    nodesMap.forEach((nodeDef) => scan(nodeDef));\n\n    this.cycles.forEach((cy) => {\n      cy.bonds.forEach((bond) => {\n        const { index } = bond;\n        if (typeof index === \"number\") {\n          const list = getItemForced(this.bondsMap, index, []);\n          list.push(cy);\n        }\n      });\n    });\n  }\n\n  findCyclesForBond(bond: ChemBond): Cycle[] {\n    this.analyze();\n    return ifDef(bond.index, (i) => this.bondsMap[i]) ?? [];\n  }\n\n  calcBondSign(bond: ChemBond): -1 | 0 | 1 {\n    const c0 = this.findCyclesForBond(bond)[0];\n    if (c0) return calcBondSign(c0, bond);\n    const sFwd = bondSideSign(bond, 1);\n    const sBkw = bondSideSign(bond, 0);\n    if ((sFwd === -1 && sBkw !== -1) || (sFwd === 0 && sBkw === 1)) return -1;\n    if ((sFwd === 1 && sBkw !== 1) || (sFwd === 0 && sBkw === -1)) return 1;\n    return 0;\n  }\n}\n","import { ChemObj } from \"./ChemObj\";\nimport { ChemComment } from \"./ChemComment\";\nimport { ChemCustom } from \"./ChemCustom\";\nimport { Visitor } from \"./Visitor\";\n\nexport const isEmptyNode = (node: ChemObj): boolean =>\n  !node.walkExt({\n    isStop: false,\n    atom() {\n      this.isStop = true;\n    },\n    radical() {\n      this.isStop = true;\n    },\n    custom(obj: ChemCustom) {\n      this.isStop = !!obj.text;\n    },\n    comment(obj: ChemComment) {\n      this.isStop = !!obj.text;\n    },\n  } as Visitor).isStop;\n","import { ChemNode } from \"./ChemNode\";\nimport { isEmptyNode } from \"./isEmptyNode\";\n\nexport const isNodeHidden = (node: ChemNode): boolean =>\n  node.autoMode || isEmptyNode(node);\n","import { ChemBracketBegin, getBracketsContent } from \"./ChemBracket\";\nimport { ChemObj } from \"./ChemObj\";\nimport { isTextFormula } from \"../inspectors/isTextFormula\";\n\n/**\n * Если внутри скобок все элементы текстовые,\n * например Ca(OH)2 или даже K3[Fe(CN)6]\n * то для вывода скобок гораздо лучше использовать текущий шрифт.\n * @param begin\n * @param commands\n */\nexport const isTextBrackets = (\n  begin: ChemBracketBegin,\n  commands: ChemObj[]\n): boolean =>\n  !getBracketsContent(begin, commands).find((cmd) => !isTextFormula(cmd));\n\nexport const isTextBracketsCached = (\n  begin: ChemBracketBegin,\n  commands: ChemObj[]\n): boolean => {\n  if (begin.isText !== undefined) {\n    return begin.isText;\n  }\n  const result = isTextBrackets(begin, commands);\n  // eslint-disable-next-line no-param-reassign\n  begin.isText = result;\n  return result;\n};\n","import { Double } from \"../types\";\nimport { toa } from \"../math\";\n\nexport const k2s = (k: Double): string => (k === 1.0 ? \"\" : toa(k));\n","import { Double } from \"../types\";\nimport { is0, toa } from \"../math\";\n\nexport const makeChargeText = (value: Double): string => {\n  if (is0(value)) {\n    return \"\";\n  }\n  const absCharge = Math.abs(value);\n  let text = absCharge === 1.0 ? \"\" : toa(absCharge);\n  text += value < 0 ? \"-\" : \"+\";\n  return text;\n};\n","/**\n * Свойства для отрисовки графической формулы\n * Могут быть использованы многократно\n * Created by PeterWin on 13.05.2017.\n */\n\nimport { LocalFont, TextStyle } from \"./AbstractSurface\";\nimport { getFontHeight } from \"./utils/fontFaceProps\";\nimport { ChemStyleId } from \"./ChemStyleId\";\n\nexport interface TextProps {\n  font: LocalFont;\n  style: TextStyle;\n}\n\nexport class ChemImgProps {\n  stdStyle: TextProps;\n\n  styles: Partial<Record<ChemStyleId, TextProps | undefined>> = {};\n\n  line: number; // Длина 2D-химической связи (от центра до центра)\n\n  horizLine: number; // Длина 1D-химической связи (от края до края)\n\n  lineWidth: number; // Толщина обычной линии. Если 0, значит минимальная толщина (обычно 1px).\n\n  thickWidth = 0; // Толщина толстой линии\n\n  chiralWidth = 0; // Макс. толщина хиральной связи w/d\n\n  lineSpace2 = 0; // Отступ между двойными линиями (между краями ##..##)\n\n  lineSpace2x = 0; // Для пересекающейся двойной связи\n\n  lineSpace3 = 0; // Отсуп между тройными линиями\n\n  subKY = 0.5; // Разница между низом подстрочного символа и низом объекта В долях xHeight подстрочного символа!\n\n  bracketSubKY = 0.7; // Аналогично subKY, но для скобок\n\n  supKY = 0.5; // Разница между верхом надстрочного символа и верхом объекта В долях xHeight символа!\n\n  bracketSupKY = 0.7; // Аналогично supKY, но для скобок\n\n  hatch = 0; // абсолютное расстояние между штрихами в изображении связи типа /d (z<0) -- see getHatch()\n\n  dash = 0; // Длина штриха линии типа S:\n\n  arrowL = 0; // длина стрелки\n\n  arrowD = 0; // ширина половинки стрелки\n\n  opSpace = 0; // Расстояние по оси X между агентом и операцией: H2 + O2\n\n  agentKSpace = 0; // гориз отступ коэффициента агента\n\n  mulChar = \"\\u00b7\";\n\n  mulRadius = 0.1; // Радиус операции * для аддуктов относительно высоты шрифта для стиля \"multiplier\". Если 0, то используется mulChar\n\n  kw = 40; // Коэффициент для вычисления lineWidth = ceil(line/kw)\n\n  flDblAlign = true; // Смещение двойной связи к центру, если возможно.\n\n  nodeMargin = -1; // Отступ химической связи для узла с текстом\n\n  bracketWidth = 0; // Ширина скобки\n\n  bracketSpace = 0; // Шаг между соседними скобками )( или ][ или )[\n\n  useTextBrackets: boolean = true;\n\n  electronDotD = 0; // Диаметр точки для структур Льюиса\n\n  constructor(\n    stdStyle: TextProps,\n    line: number = 0,\n    hline: number = 0,\n    width: number = 0\n  ) {\n    this.stdStyle = stdStyle;\n    if (!this.stdStyle.style.fill) this.stdStyle.style.fill = \"black\";\n    this.line = line;\n    this.horizLine = hline;\n    this.lineWidth = width;\n  }\n\n  // Функция вызывается после заполнения части свойств для автоматического заполнения остальных свойств\n  init() {\n    // Длина связи вычисляется из высоты стандартного шрифта\n    const me = this;\n    me.line = me.line || getFontHeight(me.stdStyle.font.getFontFace()) * 1.6;\n    const { line } = me;\n\n    // Ширина линии определяется по длине связи с использованием коэффициента\n    me.lineWidth = me.lineWidth || Math.ceil(line / me.kw);\n    const { lineWidth } = me;\n\n    // Длина мягкой связи (по оси Х) вычисляется из ширины знака + (потому что минус может быть слишком короткий)\n    me.horizLine = me.horizLine || me.stdStyle.font.getTextWidth(\"+\");\n\n    me.thickWidth = me.thickWidth || lineWidth * 4;\n    me.chiralWidth = me.chiralWidth || lineWidth * 5;\n    me.hatch = me.hatch || lineWidth * 2;\n    me.dash = me.dash || lineWidth * 3;\n    me.lineSpace2 = me.lineSpace2 || lineWidth * 2;\n    me.lineSpace2x = me.lineSpace2x || lineWidth * 3;\n    me.lineSpace3 = me.lineSpace3 || lineWidth * 2;\n    me.arrowL = me.arrowL || line / 5;\n    me.arrowD = me.arrowD || line / 9;\n    me.opSpace = me.opSpace || line / 4;\n    me.agentKSpace = me.agentKSpace || lineWidth * 2;\n\n    me.bracketWidth = me.bracketWidth || lineWidth * 4;\n    me.bracketSpace = me.bracketSpace || lineWidth * 2;\n    me.electronDotD = me.electronDotD || lineWidth * 3;\n\n    if (me.nodeMargin < 0) me.nodeMargin = me.lineWidth || 1;\n  }\n\n  getStyle(styleName: ChemStyleId): TextProps {\n    return this.styles[styleName] || this.stdStyle;\n  }\n\n  getStyleColored(styleName: ChemStyleId, color?: string): TextProps {\n    const style = this.getStyle(styleName);\n    if (!color || style.style.fill === color) {\n      return style;\n    }\n    return {\n      ...style,\n      style: { ...style.style, fill: color },\n    };\n  }\n\n  // Стили, требующие уменьшения.\n  static getIndexStyles(): ChemStyleId[] {\n    return [\n      \"atomNumber\",\n      \"bracketCharge\",\n      \"bracketCount\",\n      \"itemCount\",\n      \"itemMass\",\n      \"nodeCharge\",\n      \"oxidationState\",\n    ];\n  }\n}\n","import { Point } from \"../../math/Point\";\nimport { AbstractSurface, LocalFont, TextStyle } from \"../AbstractSurface\";\nimport { CommonFontFace } from \"../CommonFontFace\";\nimport { WebFontProps } from \"./WebFontProps\";\n\nexport class HtmlCanvasLocalFont implements LocalFont {\n  private context: CanvasRenderingContext2D;\n\n  private props: WebFontProps;\n\n  constructor(context: CanvasRenderingContext2D, props: WebFontProps) {\n    this.context = context;\n    this.props = props;\n  }\n\n  getFontFace(): CommonFontFace {\n    return this.props.fontFace;\n  }\n\n  getTextWidth(textLine: string): number {\n    this.context.font = this.props.canvasFont;\n    const m = this.context.measureText(textLine);\n    return m.width;\n  }\n\n  drawLine(\n    surface: AbstractSurface,\n    org: Point,\n    textLine: string,\n    style: TextStyle\n  ) {\n    this.context.font = this.props.canvasFont;\n    this.context.fillStyle = style.fill;\n    this.context.fillText(textLine, org.x, org.y);\n  }\n}\n","import { Point } from \"../../math/Point\";\nimport {\n  AbstractSurface,\n  LocalFont,\n  LocalFontProps,\n  PathStyle,\n} from \"../AbstractSurface\";\nimport { PathSeg, PathVisitor } from \"../path\";\nimport { tracePath } from \"../utils/tracePath\";\nimport { WebFontCache } from \"./WebFontCache\";\nimport { HtmlCanvasLocalFont } from \"./HtmlCanvasLocalFont\";\nimport { Matrix2x3 } from \"../../math/Matrix2x3\";\n\nexport class HtmlCanvasSurface implements AbstractSurface {\n  private domElement: HTMLCanvasElement;\n\n  private size: Point;\n\n  private htmlContext: CanvasRenderingContext2D;\n\n  private fontPropsCache: WebFontCache;\n\n  private fontCache: Record<string, LocalFont> = {};\n\n  getCanvas() {\n    return this.domElement;\n  }\n\n  getCtx() {\n    return this.htmlContext;\n  }\n\n  constructor(domElement: HTMLCanvasElement, fontPropsCache?: WebFontCache) {\n    this.domElement = domElement;\n    const ctx = domElement.getContext(\"2d\");\n    if (!ctx) throw Error(\"2d context is not supported\");\n    this.htmlContext = ctx;\n    this.size = new Point();\n    this.fontPropsCache = fontPropsCache ?? new WebFontCache();\n  }\n\n  getFont(props: LocalFontProps): LocalFont {\n    const webProps = this.fontPropsCache.getWebProps(props);\n    let font = this.fontCache[webProps.hash];\n    if (font) return font;\n    font = new HtmlCanvasLocalFont(this.getCtx(), webProps);\n    this.fontCache[webProps.hash] = font;\n    return font;\n  }\n\n  applyStyle(style: PathStyle, org?: Point | Matrix2x3) {\n    const { htmlContext } = this;\n    if (org) {\n      if (org instanceof Point) {\n        htmlContext.translate(org.x, org.y);\n      } else if (org instanceof Matrix2x3) {\n        const { a, b, c, d, e, f } = org;\n        htmlContext.transform(a, b, c, d, e, f);\n      }\n    }\n    htmlContext.beginPath();\n    htmlContext.fillStyle = style.fill ?? \"transparent\";\n    htmlContext.strokeStyle = style.stroke ?? \"transparent\";\n    htmlContext.lineWidth = style.strokeWidth ?? 1;\n  }\n\n  drawPath(\n    org: Point | Matrix2x3,\n    segments: PathSeg[],\n    style: PathStyle\n  ): void {\n    const { htmlContext } = this;\n    htmlContext.save();\n    this.applyStyle(style, org);\n\n    const visitor: PathVisitor = {\n      onM(p: Point) {\n        htmlContext.moveTo(p.x, p.y);\n      },\n      onL(p: Point) {\n        htmlContext.lineTo(p.x, p.y);\n      },\n      onQ(cp: Point, p: Point) {\n        htmlContext.quadraticCurveTo(cp.x, cp.y, p.x, p.y);\n      },\n      onC(cp1: Point, cp2: Point, p: Point) {\n        htmlContext.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, p.x, p.y);\n      },\n      onA(r, xRot, largeArc, sweep, pt) {\n        // Точного соответствия нет. Нужно комбинировать arcTo и трансформации\n        htmlContext.lineTo(pt.x, pt.y);\n      },\n    };\n    tracePath(segments, visitor);\n    if (style.fill) htmlContext.fill();\n    if (style.stroke) htmlContext.stroke();\n    htmlContext.restore();\n  }\n\n  drawEllipse(\n    offset: Point,\n    center: Point,\n    radius: Point,\n    style: PathStyle\n  ): void {\n    const { htmlContext } = this;\n    htmlContext.save();\n    this.applyStyle(style, offset);\n    htmlContext.ellipse(\n      center.x,\n      center.y,\n      radius.x,\n      radius.y,\n      0,\n      0,\n      2 * Math.PI\n    );\n    if (style.fill) htmlContext.fill();\n    if (style.stroke) htmlContext.stroke();\n    htmlContext.restore();\n  }\n\n  setSize(size: Point) {\n    this.size = size;\n    this.domElement.width = size.x;\n    this.domElement.height = size.y;\n  }\n}\n","import { Point } from \"../../math/Point\";\nimport { AbstractSurface, LocalFont, TextStyle } from \"../AbstractSurface\";\nimport { CommonFontFace } from \"../CommonFontFace\";\nimport { WebFontProps } from \"./WebFontProps\";\nimport { SvgWebSurface } from \"./SvgWebSurface\";\nimport { drawTag } from \"../../utils/xml/drawTag\";\nimport { escapeXml } from \"../../utils/xml/escapeXml\";\nimport { XmlAttrs } from \"../../utils/xml/xmlTypes\";\nimport { toa } from \"../../math\";\nimport { scaleFontFace } from \"../utils/scaleFontFace\";\nimport { makeCanvasFontProp } from \"./browserUtils/makeWebFontProps\";\n\nexport class SvgWebLocalFont implements LocalFont {\n  private canvas: HTMLCanvasElement;\n\n  constructor(private webFontProps: WebFontProps) {\n    this.canvas = document.createElement(\"canvas\");\n  }\n\n  createScaled(scale: number): LocalFont {\n    const newProps = { ...this.webFontProps };\n    newProps.cssHeight *= scale;\n    newProps.fontFace = scaleFontFace(newProps.fontFace, scale);\n    newProps.canvasFont = makeCanvasFontProp(newProps);\n    return new SvgWebLocalFont(newProps);\n  }\n\n  getFontFace(): CommonFontFace {\n    return this.webFontProps.fontFace;\n  }\n\n  getTextWidth(textLine: string): number {\n    const ctx = this.canvas.getContext(\"2d\");\n    if (!ctx) throw Error(\"Canvas don't supported\");\n    ctx.font = this.webFontProps.canvasFont;\n    return ctx.measureText(textLine).width;\n  }\n\n  drawLine(\n    surface: AbstractSurface,\n    org: Point,\n    textLine: string,\n    style: TextStyle\n  ): void {\n    if (surface instanceof SvgWebSurface) {\n      const { fontFace, cssHeight, bold, italic } = this.webFontProps;\n      const attrs: XmlAttrs = {\n        x: toa(org.x),\n        y: toa(org.y),\n        fill: style.fill,\n        \"font-family\": fontFace.fontFamily,\n        \"font-size\": `${cssHeight}px`,\n      };\n      if (bold) attrs[\"font-weight\"] = \"bold\";\n      if (italic) attrs[\"font-style\"] = \"italic\";\n      const code = `${drawTag(\"text\", attrs)}${escapeXml(textLine)}</text>`;\n      surface.addFigure(code);\n    } else {\n      throw new Error(\"Expected SvgWebSurface\");\n    }\n  }\n}\n","import { LocalFontProps, LocalFont } from \"../AbstractSurface\";\nimport { SvgSurface } from \"../svg/SvgSurface\";\nimport { WebFontCache } from \"./WebFontCache\";\nimport { SvgWebLocalFont } from \"./SvgWebLocalFont\";\n\nexport class SvgWebSurface extends SvgSurface {\n  private fontPropsCache: WebFontCache;\n\n  private fontCache: Record<string, LocalFont> = {};\n\n  constructor(fontPropsCache?: WebFontCache) {\n    super();\n    this.fontPropsCache = fontPropsCache ?? new WebFontCache();\n  }\n\n  getFont(props: LocalFontProps): LocalFont {\n    const webProps = this.fontPropsCache.getWebProps(props);\n    const font = this.fontCache[webProps.hash];\n    if (font) return font;\n    const svgLocFont = new SvgWebLocalFont(webProps);\n    this.fontCache[webProps.hash] = svgLocFont;\n    return svgLocFont;\n  }\n}\n","import { LocalFontProps } from \"../AbstractSurface\";\nimport { WebFontProps } from \"./WebFontProps\";\nimport { createLocalFontHash } from \"../utils/createLocalFontHash\";\nimport { makeWebFontProps } from \"./browserUtils/makeWebFontProps\";\n\nexport class WebFontCache {\n  private cache: Record<string, WebFontProps> = {};\n\n  getWebProps(props: LocalFontProps): WebFontProps {\n    const hash = createLocalFontHash(props);\n    let webProps = this.cache[hash];\n    if (webProps) {\n      return webProps;\n    }\n    webProps = makeWebFontProps(props);\n    this.cache[hash] = webProps;\n    return webProps;\n  }\n}\n","import { FontWeight } from \"../../FontTypes\";\nimport { LocalFontProps } from \"../../AbstractSurface\";\nimport { BBoxIndex, FontFaceBBox } from \"../../CommonFontFace\";\nimport { webFontWeight } from \"./webFontWeight\";\nimport { isBold } from \"../../utils/fontWeightValue\";\nimport { traceBox } from \"./traceBox\";\nimport { WebFontProps } from \"../WebFontProps\";\nimport { createLocalFontHash } from \"../../utils/createLocalFontHash\";\n\nexport const makeCanvasFontProp = (props: {\n  fontFamily: string;\n  cssHeight: number;\n  italic: boolean;\n  bold: boolean;\n}): string => {\n  const { fontFamily, cssHeight, bold, italic } = props;\n  const fontStyleChunks = [`${cssHeight}px`, fontFamily];\n  if (bold) fontStyleChunks.unshift(\"bold\");\n  if (italic) fontStyleChunks.unshift(\"italic\");\n  return fontStyleChunks.join(\" \");\n};\n\n/**\n * For browser only\n * @param props\n * @returns\n */\nexport const makeWebFontProps = (props: LocalFontProps): WebFontProps => {\n  const fontFamily = props.family;\n  const fontWeight: FontWeight = webFontWeight(props.weight);\n  const italic: boolean = props.style === \"italic\" || props.style === \"oblique\";\n  const cssHeight = Math.round(props.height);\n  const vOffset = Math.round(cssHeight / 2);\n  const testHeight = cssHeight + 2 * vOffset;\n  const testWidth = Math.round(cssHeight / 2);\n  const baseline = vOffset + cssHeight;\n\n  const bold = isBold(fontWeight);\n  const canvasFont = makeCanvasFontProp({\n    fontFamily,\n    cssHeight,\n    bold,\n    italic,\n  });\n\n  // This code can throw exception, if run in Node or old browser.\n  const canvas = document.createElement(\"canvas\");\n  canvas.height = testHeight;\n  canvas.width = testWidth;\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) throw Error(\"Canvas is not supported\");\n  ctx.fillStyle = \"#FFF\";\n  ctx.textBaseline = \"alphabetic\";\n  ctx.font = canvasFont;\n  const m = ctx.measureText(\"[lj\");\n  const mZ = ctx.measureText(\"Z\");\n  const mz = ctx.measureText(\"z\");\n\n  const trace = (letter: string, toBottom: boolean): number => {\n    ctx.clearRect(0, 0, testWidth, testHeight);\n    ctx.fillText(letter, 0, baseline);\n    const info = ctx.getImageData(0, 0, testWidth, testHeight);\n    if (!info) throw Error(\"Cant access to image data\");\n    const best = traceBox(info.data, testWidth, testHeight, toBottom);\n    return best || (toBottom ? 0 : testHeight - 1);\n  };\n  const xHeight = mZ.actualBoundingBoxAscent ?? baseline - trace(\"Z\", true);\n  const capHeight = mz.actualBoundingBoxAscent ?? baseline - trace(\"z\", true);\n  const ascent = m.actualBoundingBoxAscent ?? baseline - trace(\"l\", true);\n  const descent = m.actualBoundingBoxDescent\n    ? -m.actualBoundingBoxDescent\n    : baseline - trace(\"j\", false);\n  const bbox: FontFaceBBox = [0, 0, 0, 0];\n  bbox[BBoxIndex.bottom] = m.fontBoundingBoxDescent\n    ? -m.fontBoundingBoxDescent\n    : descent;\n  bbox[BBoxIndex.top] = m.fontBoundingBoxAscent ?? Math.max(xHeight, ascent);\n\n  canvas.remove();\n\n  return {\n    hash: createLocalFontHash(props),\n    fontFace: {\n      fontFamily,\n      fontWeight,\n      fontStyle: italic ? \"italic\" : \"normal\",\n      xHeight,\n      capHeight,\n      descent,\n      ascent,\n      bbox,\n    },\n    canvasFont,\n    fontFamily,\n    cssHeight,\n    italic,\n    bold,\n  };\n};\n","type Int = number;\nexport const traceBox = (\n  pixels: Uint8ClampedArray,\n  width: Int,\n  height: Int,\n  toBottom: boolean\n) => {\n  const [start, finish, step] = toBottom\n    ? [0, height, 1]\n    : [height - 1, -1, -1];\n  let best: Int | null = null;\n  for (let x = 0; x < width; x++) {\n    for (let y = start; y !== finish; y += step) {\n      const offset = (y * width + x) * 4 + 3;\n      if (pixels[offset]! > 128) {\n        if (best !== null) {\n          if (toBottom) {\n            if (y > best) return best;\n          } else if (y < best) return best;\n        }\n        best = y;\n        break;\n      }\n    }\n  }\n  return best;\n};\n","import { FontWeight } from \"../../FontTypes\";\nimport { fontWeightValue } from \"../../utils/fontWeightValue\";\n\nexport const webFontWeight = (weight?: string): FontWeight => {\n  if (!weight || weight === \"all\") {\n    return \"normal\";\n  }\n  const first: string = weight.split(\",\")[0]!.trim();\n  if (first === \"normal\" || first === \"bold\") {\n    return first;\n  }\n  return String(fontWeightValue(first as FontWeight)) as FontWeight;\n};\n","import { ChemImgProps, TextProps } from \"../ChemImgProps\";\nimport { rulesHtml } from \"../../textRules/rulesHtml\";\nimport { createRulesList } from \"../utils/createRulesList\";\nimport { AbstractSurface, LocalFontProps } from \"../AbstractSurface\";\nimport { FontStretch, FontStyle, FontWeight } from \"../FontTypes\";\nimport { ChemStyleId } from \"../ChemStyleId\";\n\nlet rulesList: [ChemStyleId, string][] | undefined;\n\nconst doc = typeof window === \"undefined\" ? undefined : window.document;\n\ntype FnComputedStyle = (element: Element) => CSSStyleDeclaration;\nconst findComputedStyle: FnComputedStyle =\n  doc?.defaultView?.getComputedStyle ||\n  // @ts-ignore\n  ((element: Element) => element.currentStyle);\n\nexport const createBrowserChemImgProps = (\n  owner: Element,\n  surface: AbstractSurface\n): ChemImgProps => {\n  // Система доступа к откомпилированным свойствам DOM-объектов. Используется отрисовщиком\n  const span = document.createElement(\"span\");\n  const createStyle = (htmlCode: string): TextProps | undefined => {\n    span.innerHTML = htmlCode;\n    const elem = htmlCode[0] === \"<\" ? span.firstChild : span;\n    if (!(elem instanceof Element)) return undefined;\n    const cssStyle = findComputedStyle(elem);\n    if (!cssStyle) return undefined;\n    const fontProps: LocalFontProps = {\n      family: cssStyle.fontFamily,\n      height: +cssStyle.fontSize.slice(0, -2),\n      weight: cssStyle.fontWeight as FontWeight,\n      style: cssStyle.fontStyle as FontStyle,\n      stretch: cssStyle.fontStretch as FontStretch,\n    };\n    return {\n      font: surface.getFont(fontProps),\n      style: { fill: cssStyle.color },\n    };\n  };\n  try {\n    owner.appendChild(span);\n    const stdStyle = createStyle(\"A\");\n    if (!stdStyle) throw Error(\"Can't access to CSS properties\");\n    const props = new ChemImgProps(stdStyle);\n    rulesList = rulesList || createRulesList(rulesHtml);\n    rulesList.forEach(([name, code]) => {\n      const curStyle = createStyle(code);\n      if (curStyle) props.styles[name] = curStyle;\n    });\n    props.init();\n    return props;\n  } finally {\n    span.remove();\n  }\n};\n","import { Rect, updateRect } from \"../../math/Rect\";\nimport { Point } from \"../../math/Point\";\nimport { AbstractSurface, PathStyle } from \"../AbstractSurface\";\nimport { PathSeg, PathSegPt } from \"../path\";\nimport { Figure } from \"./Figure\";\n\nexport class FigBSpline extends Figure {\n  // Создать фигуру B-сплайна.\n  // Список точек должен иметь три фиктивные точки, которые не выдны при выводе.\n  // Одна в начала, две в конце. Для их вычисления можно использовать FigBSpline.extendsPoints\n  // фиктивные точки: points[0], points[n-1], points[n-2]\n  constructor(\n    public readonly points: Point[],\n    public readonly style: PathStyle,\n    public readonly segmentLength: number,\n    public readonly bDashed: boolean\n  ) {\n    super();\n  }\n\n  update(): void {\n    this.bounds =\n      this.points\n        .slice(1, -2)\n        .reduce(\n          (rect: Rect | undefined, p: Point) => updateRect(p, rect),\n          undefined\n        ) ?? new Rect();\n  }\n\n  draw(offset: Point, surface: AbstractSurface): void {\n    const segs: PathSeg[] = [];\n    const { points } = this;\n    const n = points.length;\n    const L = n - 3;\n    if (L < 1) return;\n    const bCycled = points[1]!.equals(points[L]!); // Сплайн циклический, если совпадают крайние видимые точки\n\n    // Вычислить длину каждой видимой грани и их сумму\n    let sumLen = 0;\n    const edgesLen = [0]; // длины видимых кусков\n    for (let i = 1; i < L; i++) {\n      const len = points[i]!.dist(points[i + 1]!);\n      sumLen += len;\n      edgesLen[i] = len;\n    }\n    let nSegs = Math.floor(sumLen / this.segmentLength + 0.5); // Количество сегментов\n    if (this.bDashed) {\n      // Для прерывистой линии нужно скорректировать количество сегментов\n      // число сегментов должно быть нечётным для разомкнутой кривой и чётной для зацикленной\n      // eslint-disable-next-line no-bitwise\n      if (nSegs & 1) {\n        // нечётное число сегментов не годится для цикла\n        if (bCycled) nSegs++;\n      } else if (!bCycled) {\n        // Чётное число не годится для разомкнутой кривой\n        nSegs++;\n      }\n    }\n    // скорректировать длину сегмента\n    const segmentLength = sumLen / nSegs;\n    // Теперь движемся одновременно по сегментам и по граням\n    let i = 0;\n    let len = 0;\n    let curEdge = 0;\n    let newEdge = 1;\n    let a3 = Point.zero;\n    let a2 = Point.zero;\n    let a1 = Point.zero;\n    let a0 = Point.zero;\n    let edgeK = 0;\n    for (; ; i++) {\n      if (newEdge !== curEdge) {\n        if (newEdge >= L) break;\n        // Переход на новое ребро. Пересчёт коэффициентов\n        curEdge = newEdge;\n        edgeK = 1 / edgesLen[curEdge]!;\n\n        a3 = points[curEdge]!.times(3);\n        a3.isub(points[curEdge - 1]!);\n        a3.iadd(points[curEdge + 1]!.times(-3));\n        a3.iadd(points[curEdge + 2]!);\n        a3.scale(1 / 6);\n\n        a2 = points[curEdge]!.times(-2);\n        a2.iadd(points[curEdge - 1]!)\n          .iadd(points[curEdge + 1]!)\n          .scale(0.5);\n\n        a1 = points[curEdge + 1]!.minus(points[curEdge - 1]!).scale(0.5);\n\n        a0 = points[curEdge]!.times(4);\n        a0.iadd(points[curEdge - 1]!)\n          .iadd(points[curEdge + 1]!)\n          .scale(1 / 6);\n      }\n      const t = len * edgeK;\n      const pt = a3.times(t).iadd(a2).scale(t).iadd(a1).scale(t).iadd(a0);\n      // eslint-disable-next-line no-bitwise\n      segs.push({ cmd: (this.bDashed && i & 1) || i === 0 ? \"M\" : \"L\", pt });\n\n      len += segmentLength;\n      // вохможно, переход на новое ребро\n      while (len >= edgesLen[newEdge]!) {\n        len -= edgesLen[newEdge]!;\n        newEdge++;\n      }\n    }\n    if (bCycled) {\n      segs.push(\n        !this.bDashed\n          ? { cmd: \"Z\" }\n          : { cmd: \"L\", pt: (segs[0] as PathSegPt).pt }\n      );\n    } else {\n      segs.push({ cmd: \"L\", pt: points[newEdge]! }); // Последний сегмент\n    }\n    surface.drawPath(offset.plus(this.org), segs, this.style);\n  }\n\n  /**\n   * Добавить фиктивные (не рисуемые) точки.\n   * режиме цикла:\n   *  - проверяется совпадение первой и последней точки. Если не совпадают, то добавляется.\n   *  - для фиктивных точек тоже используются существующие точки\n   * Для незамкнутого сплайна фиктивные точки строятся на продолжении крайних сегментов\n   * @param srcPoints\n   * @param bCyclic\n   */\n  static extendsPoints(\n    srcPoints: Point[],\n    bCyclic: boolean\n  ): Point[] | undefined {\n    const n = srcPoints.length;\n    if (n < 3) return undefined;\n    const first = srcPoints[0]!;\n    const second = srcPoints[1]!;\n    const last = srcPoints[n - 1]!;\n    const preLast = srcPoints[n - 2]!;\n    if (bCyclic) {\n      const dstPoints = [...srcPoints];\n      let newLast = last;\n      if (first.equals(last)) {\n        // Последовательность уже замкнута. Конечная точка отступает назад\n        newLast = preLast;\n      } else {\n        // // Добавляем в конец точку (используемую при выводе), совпадающую с первой\n        dstPoints.push(first);\n      }\n      // Добавить три фиктивные точки: две назад, одна вперёд\n      dstPoints.push(second);\n      dstPoints.push(srcPoints[2]!);\n      dstPoints.unshift(newLast);\n      return dstPoints;\n    }\n    const firstStep = second.minus(first);\n    const lastStep = last.minus(preLast);\n    const e = last.plus(lastStep);\n    return [first.minus(firstStep), ...srcPoints, e, e.plus(lastStep)];\n  }\n}\n","import { Point } from \"../../math/Point\";\nimport { Rect } from \"../../math/Rect\";\nimport { AbstractSurface, PathStyle } from \"../AbstractSurface\";\nimport { Figure } from \"./Figure\";\n\nexport class FigEllipse extends Figure {\n  constructor(\n    center: Point,\n    public readonly radius: Point,\n    public readonly style: PathStyle\n  ) {\n    super();\n    this.org = center;\n    this.bounds = new Rect(radius.neg(), radius);\n  }\n\n  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-empty-function\n  update(): void {}\n\n  draw(offset: Point, surface: AbstractSurface): void {\n    surface.drawEllipse(offset, this.org, this.radius, this.style);\n  }\n}\n","import { Point } from \"../../math/Point\";\nimport { Rect } from \"../../math/Rect\";\nimport { AbstractSurface } from \"../AbstractSurface\";\nimport { Figure } from \"./Figure\";\n\nexport class FigFrame extends Figure {\n  figures: Figure[] = [];\n\n  label?: string;\n\n  addFigure(fig: Figure, update?: boolean) {\n    this.figures.push(fig);\n    if (update) this.updateFigure(fig);\n  }\n\n  insertFigure(pos: number, fig: Figure, update?: boolean) {\n    this.figures.splice(pos, 0, fig);\n    if (update) this.updateFigure(fig);\n  }\n\n  updateFigure(fig: Figure) {\n    this.bounds.unite(fig.getRelativeBounds());\n  }\n\n  update(): void {\n    this.bounds =\n      this.figures.reduce((acc: Rect | undefined, fig: Figure) => {\n        const figBounds = fig.getRelativeBounds();\n        if (!acc) {\n          return figBounds;\n        }\n        acc.unite(figBounds);\n        return acc;\n      }, undefined) ?? new Rect();\n  }\n\n  draw(offset: Point, surface: AbstractSurface): void {\n    const org = offset.plus(this.org);\n    this.figures.forEach((fig) => fig.draw(org, surface));\n  }\n}\n","import { is0 } from \"../../math\";\nimport { Rect } from \"../../math/Rect\";\nimport { Point } from \"../../math/Point\";\nimport { AbstractSurface, PathStyle } from \"../AbstractSurface\";\nimport { PathSeg } from \"../path\";\nimport { Figure } from \"./Figure\";\n\n/**\n *      b\n *    ######  bWidth\n *\n *     ####\n *\n *      ##  aWidth\n *      a\n * Отдельная фигура позволит менять алгоритм вывода, в зависимости от поверхности.\n * Т.к. в старых реализациях не удалось обеспечить качественное изображение при малых размерах.\n */\n\nexport class FigHashTrapezoid extends Figure {\n  constructor(\n    public readonly a: Point,\n    public readonly aWidth: number,\n    public readonly b: Point,\n    public readonly bWidth: number,\n    public readonly color: string,\n    public readonly lineWidth: number,\n    public readonly hatch: number\n  ) {\n    super();\n  }\n\n  update(): void {\n    const { a, aWidth, b, bWidth } = this;\n    const { dL, dR } = calcTrapezoidDir(a, b);\n    const { aL, aR, bL, bR } = calcTrapezoidPoints(\n      a,\n      aWidth,\n      b,\n      bWidth,\n      dL,\n      dR\n    );\n    this.bounds = new Rect(aL, aR);\n    this.bounds.updatePoint(bL);\n    this.bounds.updatePoint(bR);\n  }\n\n  draw(offset: Point, surface: AbstractSurface): void {\n    // Пока еще нет специальных функций поверхности для вывода полосатого треугольника\n    const { a, b, aWidth, bWidth, color, lineWidth, hatch } = this;\n    const { segs, style } = makeHashTrapezoidPath(\n      a,\n      aWidth,\n      b,\n      bWidth,\n      lineWidth,\n      hatch,\n      color\n    );\n    if (segs.length > 0) {\n      surface.drawPath(this.org.plus(offset), segs, style);\n    }\n  }\n}\n\ninterface TrapezoidDir {\n  dir: Point; // vector from a to b\n  dirLen: number; // length\n  dir1: Point; // unit vector from a to b\n  dL: Point; // unit vector from a to left\n  dR: Point; // unit vector from a to right\n}\n\nconst calcTrapezoidDir = (a: Point, b: Point): TrapezoidDir => {\n  const dir = b.minus(a);\n  const dirLen = dir.length();\n  const dir1 = is0(dirLen) ? Point.zero : dir.times(1 / dirLen);\n  const dL = dir1.transpon(true);\n  const dR = dir1.transpon();\n  return { dir, dirLen, dir1, dL, dR };\n};\n\nconst calcTrapezoidPoints = (\n  a: Point,\n  aWidth: number,\n  b: Point,\n  bWidth: number,\n  dL: Point,\n  dR: Point\n) => {\n  const aw2 = aWidth / 2;\n  const bw2 = bWidth / 2;\n  return {\n    aL: a.plus(dL.times(aw2)),\n    aR: a.plus(dR.times(aw2)),\n    bL: b.plus(dL.times(bw2)),\n    bR: b.plus(dR.times(bw2)),\n  };\n};\n\nexport const makeHashTrapezoidPath = (\n  src: Point,\n  srcWidth: number,\n  dst: Point,\n  dstWidth: number,\n  lineWidth: number,\n  hatch: number,\n  color: string\n) => {\n  // Алгоритм, дающий качественное изображение на больших размерах. Использует заливку.\n  // Нужно разделить ось на нечетное количество равных отрезков.\n  // Ширина полоски равна расстоянию между полосками и не меньше lineWidth\n  // Полоски создаются закрашенными трапециями.\n  const segs: PathSeg[] = [];\n  const style: PathStyle = { fill: color };\n\n  const maxW = dstWidth / 2;\n  const minW = srcWidth / 2;\n  const dW = maxW - minW;\n  const { dir, dir1, dirLen, dL, dR } = calcTrapezoidDir(src, dst);\n  if (dirLen >= lineWidth) {\n    const hatchLen = dirLen - lineWidth;\n    const desiredStep = lineWidth + hatch;\n    const stripCount = Math.floor(hatchLen / desiredStep);\n    const dStep = dir1.times(lineWidth);\n    for (let i = 0; i <= stripCount; i++) {\n      const t1 = i / stripCount;\n      const p0 = src.plus(dir.times(t1));\n      const p1 = p0.plus(dStep);\n      const w1 = minW + (i * dW) / stripCount;\n      const w2 = minW + ((i + 1) * dW) / stripCount;\n      const p0L = p0.plus(dL.times(w1));\n      const p0R = p0.plus(dR.times(w1));\n      const p1L = p1.plus(dL.times(w2));\n      const p1R = p1.plus(dR.times(w2));\n      segs.push({ cmd: \"M\", pt: p0L });\n      segs.push({ cmd: \"L\", pt: p1L });\n      segs.push({ cmd: \"L\", pt: p1R });\n      segs.push({ cmd: \"L\", pt: p0R });\n    }\n  }\n  return { segs, style };\n};\n","import { ifDef } from \"../../utils/ifDef\";\nimport { Point } from \"../../math/Point\";\nimport { Rect, updateRect } from \"../../math/Rect\";\nimport { AbstractSurface, PathStyle } from \"../AbstractSurface\";\nimport { PathSeg } from \"../path\";\nimport { tracePath } from \"../utils/tracePath\";\nimport { Figure } from \"./Figure\";\n\nexport class FigPath extends Figure {\n  constructor(public segs: PathSeg[], public style: PathStyle) {\n    super();\n  }\n\n  update() {\n    let rc: Rect | undefined;\n    tracePath(this.segs, {\n      onM(p) {\n        rc = updateRect(p, rc);\n      },\n      onL(p) {\n        rc = updateRect(p, rc);\n      },\n      onC(cp1, cp2, p) {\n        rc = updateRect(p, rc);\n        rc.updatePoint(cp1);\n        rc.updatePoint(cp2);\n      },\n      onQ(cp, p) {\n        rc = updateRect(p, rc);\n        rc.updatePoint(cp);\n      },\n      onA(r, xRot, largeArc, sweep, pt) {\n        rc = updateRect(pt, rc);\n      },\n    });\n    this.bounds = rc ?? new Rect();\n    ifDef(this.style.strokeWidth, (it) => {\n      this.bounds.grow(it / 2);\n    });\n  }\n\n  draw(offset: Point, surface: AbstractSurface): void {\n    surface.drawPath(offset.plus(this.org), this.segs, this.style);\n  }\n}\n\nexport const createLine = (a: Point, b: Point, style: PathStyle): FigPath =>\n  new FigPath(\n    [\n      { cmd: \"M\", pt: a },\n      { cmd: \"L\", pt: b },\n    ],\n    style\n  );\n","import { Point } from \"../../math/Point\";\nimport { Rect } from \"../../math/Rect\";\nimport { AbstractSurface, PathStyle } from \"../AbstractSurface\";\nimport { drawRect } from \"./drawRect\";\nimport { Figure } from \"./Figure\";\n\nexport class FigRect extends Figure {\n  readonly radius?: Point;\n\n  constructor(rect: Rect, public readonly style: PathStyle, radius?: Point) {\n    super();\n    this.bounds = rect.clone();\n    this.radius = radius;\n  }\n\n  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-empty-function\n  update(): void {}\n\n  draw(offset: Point, surface: AbstractSurface): void {\n    drawRect(\n      surface,\n      offset.plus(this.org),\n      this.bounds,\n      this.style,\n      this.radius\n    );\n  }\n}\n","import { Point } from \"../../math/Point\";\nimport { AbstractSurface, LocalFont, TextStyle } from \"../AbstractSurface\";\nimport { Figure } from \"./Figure\";\nimport { getBaseline, getFontHeight } from \"../utils/fontFaceProps\";\n\nexport class FigText extends Figure {\n  constructor(\n    public readonly text: string,\n    public readonly font: LocalFont,\n    public readonly style: TextStyle\n  ) {\n    super();\n    const ff = font.getFontFace();\n    const height = getFontHeight(ff);\n    const baseLine = getBaseline(ff);\n    this.bounds.A.y = -baseLine;\n    this.bounds.B.y = height - baseLine;\n    this.bounds.B.x = font.getTextWidth(text);\n  }\n\n  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-empty-function\n  update(): void {}\n\n  draw(offset: Point, surface: AbstractSurface): void {\n    this.font.drawLine(surface, offset.plus(this.org), this.text, this.style);\n  }\n}\n","import { Point } from \"../../math/Point\";\nimport { Rect } from \"../../math/Rect\";\nimport { AbstractSurface } from \"../AbstractSurface\";\n\nexport abstract class Figure {\n  bounds: Rect;\n\n  org: Point;\n\n  constructor() {\n    this.bounds = new Rect();\n    this.org = new Point();\n  }\n\n  abstract update(): void;\n\n  abstract draw(offset: Point, surface: AbstractSurface): void;\n\n  getRelativeBounds(): Rect {\n    const rc = this.bounds.clone();\n    rc.move(this.org);\n    return rc;\n  }\n}\n","import { Point } from \"../../math/Point\";\nimport { Rect } from \"../../math/Rect\";\nimport { AbstractSurface, PathStyle } from \"../AbstractSurface\";\nimport { PathSeg } from \"../path\";\n\nexport const drawRect = (\n  surface: AbstractSurface,\n  offset: Point,\n  rect: Rect,\n  style: PathStyle,\n  radius?: Point\n) => {\n  if (surface.drawRect) {\n    surface.drawRect(offset, rect, style, radius);\n  } else {\n    const segs: PathSeg[] = [\n      { cmd: \"M\", pt: rect.A },\n      { cmd: \"H\", x: rect.B.x },\n      { cmd: \"V\", y: rect.B.y },\n      { cmd: \"H\", x: rect.A.x },\n      { cmd: \"Z\" },\n    ];\n    surface.drawPath(offset, segs, style);\n  }\n};\n","import { AbstractSurface } from \"../AbstractSurface\";\nimport { FigFrame } from \"./FigFrame\";\n\nexport const renderTopFrame = (frame: FigFrame, surface: AbstractSurface) => {\n  surface.setSize(frame.bounds.size);\n  frame.draw(frame.bounds.A.neg(), surface);\n};\n","import { PathSeg, PathSegPt } from \"../../path\";\nimport { Rect } from \"../../../math/Rect\";\nimport { RubberFigure } from \"./RubberFigure\";\nimport { SrcData } from \"./scalePath\";\nimport { Point } from \"../../../math/Point\";\nimport { tracePath } from \"../../utils/tracePath\";\n\nexport const openBrace: RubberFigure = {\n  draw(desiredRect: Rect): PathSeg[] {\n    return drawTriple(desiredRect, leftTop, leftMid, leftBottom, 3, 11);\n  },\n};\n\nexport const closeBrace: RubberFigure = {\n  draw(desiredRect: Rect): PathSeg[] {\n    return drawTriple(desiredRect, rightTop, rightMid, rightBottom, 11, 3);\n  },\n};\n\n// Данный алгоритм дает более качественное изображение, чем scalePath для символов {}\n// Но его можно еще улучшить, если сделать резиновые точки соединения,\n// а сами фигуры оставлять пропорциональными по высоте и ширине.\nconst drawTriple = (\n  desiredRect: Rect,\n  top: SrcData,\n  mid: SrcData,\n  bot: SrcData,\n  topConn: number,\n  botConn: number\n): PathSeg[] => {\n  const segs: PathSeg[] = [];\n  // Проверка стыковки\n  const topCa: Point = (top.segs[0] as PathSegPt).pt; // 210, 2545 | 769, 2545\n  const topCb: Point = (top.segs[top.segs.length - 2] as PathSegPt).pt; // 0, 2545 | 559, 2545\n  if (topCa.y !== topCb.y) return segs;\n  const midCa: Point = (mid.segs[topConn] as PathSegPt).pt; // 637, 0 | 0, 4687\n  const midCb: Point = (mid.segs[topConn + 1] as PathSegPt).pt; // 427, 0 | 210, 4687\n  if (midCa.y !== midCb.y) return segs;\n  const midCc: Point = (mid.segs[botConn] as PathSegPt).pt; // (427, 4687) | 210, 0\n  // const midCd: Point = (mid.segs[botConn + 1] as PathSegPt).pt; // (637, 4687) | (0, 0)\n  const botCc: Point = (bot.segs[0] as PathSegPt).pt; // 0, 0 | 769, 2545\n  // const botCd: Point = (bot.segs[bot.segs.length - 2] as PathSegPt).pt; // 210, 0 | 559, 2545\n\n  const rect = new Rect();\n  const build = (src: PathSeg[], start: number, stop: number, delta: Point) => {\n    const cvt = (p: Point): Point => {\n      const res = p.plus(delta);\n      if (res.isZero()) {\n        rect.A.setPt(res);\n        rect.B.setPt(res);\n      } else {\n        rect.A.mini(res);\n        rect.B.maxi(res);\n      }\n      return res;\n    };\n    const step = 1; // ccw ? -1 : 1;\n    let i = start;\n    while (i !== stop) {\n      if (i < 0) i = src.length - 1;\n      else if (i === src.length) i = 0;\n      const cur = src[i]!;\n      i += step;\n      switch (cur.cmd) {\n        case \"M\":\n          segs.push({ cmd: segs.length === 0 ? \"M\" : \"L\", pt: cvt(cur.pt) });\n          break;\n        case \"L\":\n          segs.push({ cmd: \"L\", pt: cvt(cur.pt) });\n          break;\n        case \"Q\":\n          segs.push({ cmd: \"Q\", pt: cvt(cur.pt), cp: cvt(cur.cp) });\n          break;\n        case \"C\":\n          segs.push({\n            cmd: \"C\",\n            pt: cvt(cur.pt),\n            cp1: cvt(cur.cp1),\n            cp2: cvt(cur.cp2),\n          });\n          break;\n        default:\n          break;\n      }\n    }\n  };\n  build(top.segs, 0, top.segs.length - 1, new Point(midCa.x - topCa.x, 0));\n  build(mid.segs, topConn + 1, botConn, new Point(0, top.height));\n  build(\n    bot.segs,\n    0,\n    bot.segs.length - 1,\n    new Point(midCc.x - botCc.x, top.height + mid.height)\n  );\n  build(mid.segs, botConn + 1, topConn, new Point(0, top.height));\n  // scale\n  const kx = desiredRect.width / rect.width;\n  const ky = desiredRect.height / rect.height;\n  const scale = (pt: Point) => {\n    pt.set((pt.x - rect.left) * kx, pt.y * ky);\n  };\n  tracePath(segs, {\n    onM(p) {\n      scale(p);\n    },\n    onL(p) {\n      scale(p);\n    },\n    onC(p, cp1, cp2) {\n      scale(p);\n      scale(cp1);\n      scale(cp2);\n    },\n    onQ(cp, p) {\n      scale(cp);\n      scale(p);\n    },\n    onA(): void {\n      throw new Error(\"Function not implemented.\");\n    },\n  });\n\n  segs.push({ cmd: \"Z\" });\n\n  return segs;\n};\n\n// #7-0 -connect with middle\nconst leftBottom: SrcData = {\n  width: 769,\n  height: 2545,\n  segs: [\n    { cmd: \"M\", pt: new Point(0, 0) },\n    { cmd: \"L\", pt: new Point(0, 801) },\n    { cmd: \"Q\", pt: new Point(177.5, 2052.5), cp: new Point(0, 1632) },\n    { cmd: \"Q\", pt: new Point(769, 2545), cp: new Point(355, 2473) },\n    { cmd: \"L\", pt: new Point(769, 2450) },\n    { cmd: \"Q\", pt: new Point(343, 1986), cp: new Point(476, 2381) },\n    { cmd: \"Q\", pt: new Point(210, 767), cp: new Point(210, 1591) },\n    { cmd: \"L\", pt: new Point(210, 0) },\n    { cmd: \"Z\" },\n  ],\n};\n\n// #3,4 - connect with top\n// #11,12 - connect with bottom\nconst leftMid: SrcData = {\n  width: 637,\n  height: 4687,\n  segs: [\n    { cmd: \"M\", pt: new Point(209, 2331) },\n    { cmd: \"Q\", pt: new Point(485.5, 2020), cp: new Point(350, 2271) },\n    { cmd: \"Q\", pt: new Point(637, 1185), cp: new Point(621, 1769) },\n    { cmd: \"L\", pt: new Point(637, 0) }, // 3\n    { cmd: \"L\", pt: new Point(427, 0) }, // 4\n    { cmd: \"L\", pt: new Point(427, 1359) },\n    { cmd: \"Q\", pt: new Point(315, 2041), cp: new Point(427, 1811) },\n    { cmd: \"Q\", pt: new Point(0, 2279), cp: new Point(203, 2271) },\n    { cmd: \"L\", pt: new Point(0, 2399) },\n    { cmd: \"Q\", pt: new Point(313, 2638), cp: new Point(199, 2407) },\n    { cmd: \"Q\", pt: new Point(427, 3328), cp: new Point(427, 2869) },\n    { cmd: \"L\", pt: new Point(427, 4687) }, // 11\n    { cmd: \"L\", pt: new Point(637, 4687) }, // 12\n    { cmd: \"L\", pt: new Point(637, 3502) },\n    { cmd: \"Q\", pt: new Point(494.5, 2680), cp: new Point(637, 2945) },\n    { cmd: \"Q\", pt: new Point(209, 2356), cp: new Point(352, 2415) },\n    { cmd: \"Z\" },\n  ],\n};\n\n// #7-0 -connect with middle\nconst leftTop: SrcData = {\n  width: 769,\n  height: 2545,\n  segs: [\n    { cmd: \"M\", pt: new Point(210, 2545) },\n    { cmd: \"L\", pt: new Point(210, 1778) },\n    { cmd: \"Q\", pt: new Point(343, 559), cp: new Point(210, 954) },\n    { cmd: \"Q\", pt: new Point(769, 95), cp: new Point(476, 164) },\n    { cmd: \"L\", pt: new Point(769, 0) },\n    { cmd: \"Q\", pt: new Point(177.5, 492.5), cp: new Point(355, 72) },\n    { cmd: \"Q\", pt: new Point(0, 1744), cp: new Point(0, 913) },\n    { cmd: \"L\", pt: new Point(0, 2545) },\n    { cmd: \"Z\" },\n  ],\n};\n\nconst rightBottom: SrcData = {\n  width: 769,\n  height: 2545,\n  segs: [\n    { cmd: \"M\", pt: new Point(559, 0) },\n    { cmd: \"L\", pt: new Point(559, 767) },\n    { cmd: \"Q\", pt: new Point(426, 1986), cp: new Point(559, 1591) },\n    { cmd: \"Q\", pt: new Point(0, 2450), cp: new Point(293, 2381) },\n    { cmd: \"L\", pt: new Point(0, 2545) },\n    { cmd: \"Q\", pt: new Point(591.5, 2052.5), cp: new Point(414, 2473) },\n    { cmd: \"Q\", pt: new Point(769, 801), cp: new Point(769, 1632) },\n    { cmd: \"L\", pt: new Point(769, 0) },\n    { cmd: \"Z\" },\n  ],\n};\n\nconst rightMid: SrcData = {\n  width: 637,\n  height: 4687,\n  segs: [\n    { cmd: \"M\", pt: new Point(428, 2356) },\n    { cmd: \"Q\", pt: new Point(142.5, 2680), cp: new Point(285, 2415) },\n    { cmd: \"Q\", pt: new Point(0, 3502), cp: new Point(0, 2945) },\n    { cmd: \"L\", pt: new Point(0, 4687) }, // 3\n    { cmd: \"L\", pt: new Point(210, 4687) }, // 4\n    { cmd: \"L\", pt: new Point(210, 3328) },\n    { cmd: \"Q\", pt: new Point(324, 2638), cp: new Point(210, 2869) },\n    { cmd: \"Q\", pt: new Point(637, 2399), cp: new Point(438, 2407) },\n    { cmd: \"L\", pt: new Point(637, 2279) },\n    { cmd: \"Q\", pt: new Point(322, 2041), cp: new Point(434, 2271) },\n    { cmd: \"Q\", pt: new Point(210, 1359), cp: new Point(210, 1811) },\n    { cmd: \"L\", pt: new Point(210, 0) }, // 11\n    { cmd: \"L\", pt: new Point(0, 0) }, // 12\n    { cmd: \"L\", pt: new Point(0, 1185) },\n    { cmd: \"Q\", pt: new Point(151.5, 2020), cp: new Point(16, 1769) },\n    { cmd: \"Q\", pt: new Point(428, 2331), cp: new Point(287, 2271) },\n    { cmd: \"Z\" },\n  ],\n};\n\nconst rightTop: SrcData = {\n  width: 769,\n  height: 2545,\n  segs: [\n    { cmd: \"M\", pt: new Point(769, 2545) },\n    { cmd: \"L\", pt: new Point(769, 1744) },\n    { cmd: \"Q\", pt: new Point(591.5, 492.5), cp: new Point(769, 913) },\n    { cmd: \"Q\", pt: new Point(0, 0), cp: new Point(414, 72) },\n    { cmd: \"L\", pt: new Point(0, 95) },\n    { cmd: \"Q\", pt: new Point(426, 559), cp: new Point(293, 164) },\n    { cmd: \"Q\", pt: new Point(559, 1778), cp: new Point(559, 954) },\n    { cmd: \"L\", pt: new Point(559, 2545) },\n    { cmd: \"Z\" },\n  ],\n};\n","import { PathSeg } from \"../../path\";\nimport { Rect } from \"../../../math/Rect\";\nimport { Point } from \"../../../math/Point\";\nimport { RubberFigure } from \"./RubberFigure\";\nimport { scalePath, SrcData } from \"./scalePath\";\n\nconst data: SrcData = {\n  width: 559,\n  height: 1870,\n  segs: [\n    { cmd: \"M\", pt: new Point(0, 1870) },\n    { cmd: \"Q\", pt: new Point(277.5, 1819), cp: new Point(170, 1870) },\n    { cmd: \"Q\", pt: new Point(445, 1663.5), cp: new Point(385, 1768) },\n    { cmd: \"Q\", pt: new Point(532, 1392), cp: new Point(505, 1559) },\n    { cmd: \"Q\", pt: new Point(559, 939), cp: new Point(559, 1225) },\n    { cmd: \"Q\", pt: new Point(532.5, 486.5), cp: new Point(559, 655) },\n    { cmd: \"Q\", pt: new Point(446, 212), cp: new Point(506, 318) },\n    { cmd: \"Q\", pt: new Point(278, 53), cp: new Point(386, 106) },\n    { cmd: \"Q\", pt: new Point(0, 0), cp: new Point(170, 0) },\n    { cmd: \"L\", pt: new Point(0, 82) },\n    { cmd: \"Q\", pt: new Point(124, 94), cp: new Point(70, 82) },\n    { cmd: \"Q\", pt: new Point(228, 148), cp: new Point(185, 108) },\n    { cmd: \"Q\", pt: new Point(306, 271), cp: new Point(276, 192) },\n    { cmd: \"Q\", pt: new Point(358, 515), cp: new Point(341, 363) },\n    { cmd: \"Q\", pt: new Point(376, 931), cp: new Point(376, 676) },\n    { cmd: \"Q\", pt: new Point(361, 1313.5), cp: new Point(376, 1156) },\n    { cmd: \"Q\", pt: new Point(311, 1571), cp: new Point(346, 1471) },\n    { cmd: \"Q\", pt: new Point(241, 1702), cp: new Point(283, 1655) },\n    { cmd: \"Q\", pt: new Point(153, 1764), cp: new Point(204, 1743) },\n    { cmd: \"Q\", pt: new Point(0, 1788), cp: new Point(94, 1788) },\n    { cmd: \"Z\" },\n  ],\n};\n\nexport const closeBracket: RubberFigure = {\n  draw(desiredRect: Rect): PathSeg[] {\n    return scalePath(desiredRect, data);\n  },\n};\n","import { ChemImgProps } from \"../../ChemImgProps\";\nimport { Rect } from \"../../../math/Rect\";\nimport { PathStyle } from \"../../AbstractSurface\";\nimport { FigPath } from \"../FigPath\";\nimport { Figure } from \"../Figure\";\nimport { RubberFigure } from \"./RubberFigure\";\n\n/**\n * реализация интерфейса RubberFigure может поменяться. Её следует воспринимать как чёрный ящик.\n * На вход подается желаемый размер.\n * Фактический размер следует брать из фигуры (поле bounds)\n */\nexport const drawRubberFigure = (\n  rubberFig: RubberFigure,\n  desiredRect: Rect,\n  style: PathStyle,\n  imgProps: ChemImgProps\n): Figure => {\n  const fig = new FigPath(rubberFig.draw(desiredRect, imgProps), style);\n  fig.update();\n  return fig;\n};\n","import { closeBracket } from \"./closeBracket\";\nimport { openBracket } from \"./openBracket\";\nimport { openSquareBracket, closeSquareBracket } from \"./squareBrackets\";\nimport { RubberFigure } from \"./RubberFigure\";\nimport { closeBrace, openBrace } from \"./braces\";\n\nconst dict: Record<string, RubberFigure> = {\n  \"[\": openSquareBracket,\n  \"]\": closeSquareBracket,\n  \"(\": openBracket,\n  \")\": closeBracket,\n  \"{\": openBrace,\n  \"}\": closeBrace,\n};\n\nexport const getRubberBracket = (\n  isOpen: boolean,\n  text: string\n): RubberFigure => {\n  const rubberFig = dict[text];\n  if (rubberFig) return rubberFig;\n  return isOpen ? openSquareBracket : closeSquareBracket;\n};\n","import { Point } from \"../../../math/Point\";\nimport { Rect } from \"../../../math/Rect\";\nimport { PathSeg } from \"../../path\";\nimport { RubberFigure } from \"./RubberFigure\";\nimport { scalePath, SrcData } from \"./scalePath\";\n\nconst data: SrcData = {\n  width: 559,\n  height: 1870,\n  segs: [\n    { cmd: \"M\", pt: new Point(559, 0) },\n    { cmd: \"Q\", pt: new Point(281.5, 51), cp: new Point(389, 0) },\n    { cmd: \"Q\", pt: new Point(114, 206.5), cp: new Point(174, 102) },\n    { cmd: \"Q\", pt: new Point(27, 478), cp: new Point(54, 311) },\n    { cmd: \"Q\", pt: new Point(0, 931), cp: new Point(0, 645) },\n    { cmd: \"Q\", pt: new Point(26.5, 1383.5), cp: new Point(0, 1215) },\n    { cmd: \"Q\", pt: new Point(113, 1658), cp: new Point(53, 1552) },\n    { cmd: \"Q\", pt: new Point(281, 1817), cp: new Point(173, 1764) },\n    { cmd: \"Q\", pt: new Point(559, 1870), cp: new Point(389, 1870) },\n    { cmd: \"L\", pt: new Point(559, 1788) },\n    { cmd: \"Q\", pt: new Point(435, 1776), cp: new Point(489, 1788) },\n    { cmd: \"Q\", pt: new Point(331, 1722), cp: new Point(374, 1762) },\n    { cmd: \"Q\", pt: new Point(253, 1599), cp: new Point(283, 1678) },\n    { cmd: \"Q\", pt: new Point(201, 1355), cp: new Point(218, 1507) },\n    { cmd: \"Q\", pt: new Point(183, 939), cp: new Point(183, 1194) },\n    { cmd: \"Q\", pt: new Point(198, 556.5), cp: new Point(183, 714) },\n    { cmd: \"Q\", pt: new Point(248, 299), cp: new Point(213, 399) },\n    { cmd: \"Q\", pt: new Point(318, 168), cp: new Point(276, 215) },\n    { cmd: \"Q\", pt: new Point(406, 106), cp: new Point(355, 127) },\n    { cmd: \"Q\", pt: new Point(559, 82), cp: new Point(465, 82) },\n    { cmd: \"Z\" },\n  ],\n};\n\nexport const openBracket: RubberFigure = {\n  draw(desiredRect: Rect): PathSeg[] {\n    return scalePath(desiredRect, data);\n  },\n};\n","import { Point } from \"../../../math/Point\";\nimport { Rect } from \"../../../math/Rect\";\nimport { tracePath } from \"../../utils/tracePath\";\nimport { PathSeg } from \"../../path\";\n\nexport interface SrcData {\n  width: number;\n  height: number;\n  segs: PathSeg[];\n}\n\nexport const scalePath = (desiredRect: Rect, data: SrcData): PathSeg[] => {\n  const res: PathSeg[] = [];\n  // p -- data\n  // res -- desiredRect\n  const cvt = (p: Point) =>\n    new Point(\n      (p.x * desiredRect.width) / data.width,\n      (p.y * desiredRect.height) / data.height\n    );\n  tracePath(data.segs, {\n    onM(p: Point): void {\n      res.push({ cmd: \"M\", pt: cvt(p) });\n    },\n    onL(p: Point): void {\n      res.push({ cmd: \"L\", pt: cvt(p) });\n    },\n    onC(cp1: Point, cp2: Point, p: Point): void {\n      res.push({ cmd: \"C\", pt: cvt(p), cp1: cvt(cp1), cp2: cvt(cp2) });\n    },\n    onQ(cp: Point, p: Point): void {\n      res.push({ cmd: \"Q\", pt: cvt(p), cp: cvt(cp) });\n    },\n    onA(): void {\n      throw new Error(\"Function not implemented.\");\n    },\n  });\n  return res;\n};\n","import { Point } from \"../../../math/Point\";\nimport { Rect } from \"../../../math/Rect\";\nimport { PathSeg } from \"../../path\";\nimport { RubberFigure } from \"./RubberFigure\";\n\nconst width = 446;\nconst thickH = 82;\nconst thickV = 176;\n\nexport const openSquareBracket: RubberFigure = {\n  draw(desiredRect: Rect): PathSeg[] {\n    const scale = desiredRect.width / width;\n    const sWidth = width * scale;\n    const sHeight = desiredRect.height;\n    const sThickH = thickH * scale;\n    const sThickV = thickV * scale;\n    return [\n      { cmd: \"M\", pt: new Point(sWidth, 0) },\n      { cmd: \"H\", x: 0 },\n      { cmd: \"V\", y: sHeight },\n      { cmd: \"H\", x: sWidth },\n      { cmd: \"V\", y: sHeight - sThickH },\n      { cmd: \"H\", x: sThickV },\n      { cmd: \"V\", y: sThickH },\n      { cmd: \"H\", x: sWidth },\n      { cmd: \"Z\" },\n    ];\n  },\n};\n\nexport const closeSquareBracket: RubberFigure = {\n  draw(desiredRect: Rect): PathSeg[] {\n    const scale = desiredRect.width / width;\n    const sWidth = width * scale;\n    const sHeight = desiredRect.height;\n    const sThickH = thickH * scale;\n    const sThickV = thickV * scale;\n    return [\n      { cmd: \"M\", pt: new Point() },\n      { cmd: \"H\", x: sWidth },\n      { cmd: \"V\", y: sHeight },\n      { cmd: \"H\", x: 0 },\n      { cmd: \"V\", y: sHeight - sThickH },\n      { cmd: \"H\", x: sWidth - sThickV },\n      { cmd: \"V\", y: sThickH },\n      { cmd: \"H\", x: 0 },\n      { cmd: \"Z\" },\n    ];\n  },\n};\n","import { Point } from \"../../math/Point\";\nimport { Rect } from \"../../math/Rect\";\nimport {\n  AbstractSurface,\n  LocalFont,\n  LocalFontProps,\n  PathStyle,\n} from \"../AbstractSurface\";\nimport { buildSvgText } from \"./svgUtils/buildSvgText\";\nimport { SvgExportOptions } from \"./SvgExportOptions\";\nimport { drawTag } from \"../../utils/xml/drawTag\";\nimport { toa } from \"../../math\";\nimport { PathSeg } from \"../path\";\nimport { pathToString } from \"../utils/pathToString\";\nimport { XmlAttrs } from \"../../utils/xml/xmlTypes\";\nimport { Matrix2x3 } from \"../../math/Matrix2x3\";\n\nconst pathAttrs = (style: PathStyle, org?: Point | Matrix2x3) => {\n  const { stroke, strokeWidth, join, cap } = style;\n  const attrs: XmlAttrs = {};\n  attrs.fill = style.fill ?? \"none\";\n  if (stroke) {\n    attrs.stroke = stroke;\n  }\n  if (strokeWidth) attrs[\"stroke-width\"] = toa(strokeWidth);\n  if (join) attrs[\"stroke-linecap\"] = join;\n  if (cap) attrs[\"stroke-linecap\"] = cap;\n  if (org) {\n    if (org instanceof Point && !org.isZero()) {\n      attrs.transform = `translate(${toa(org.x)},${toa(org.y)})`;\n    } else if (org instanceof Matrix2x3) {\n      attrs.transform = `matrix(${org.repr()})`;\n    }\n  }\n  return attrs;\n};\n\n/**\n * SvgSurface can be used for Node and Browser.\n * But it is recommended to use different font systems for each of the platforms.\n */\nexport abstract class SvgSurface implements AbstractSurface {\n  abstract getFont(props: LocalFontProps): LocalFont;\n\n  // Parent overrides\n\n  setSize(size: Point) {\n    this.size = size.clone();\n    this.clear();\n  }\n\n  drawPath(org: Point | Matrix2x3, path: PathSeg[], style: PathStyle): void {\n    const attrs: XmlAttrs = { d: pathToString(path), ...pathAttrs(style, org) };\n    this.addFigure(drawTag(\"path\", attrs, true));\n  }\n\n  drawRect(offset: Point, rect: Rect, style: PathStyle, radius?: Point) {\n    const attrs: XmlAttrs = {\n      x: toa(rect.left),\n      y: toa(rect.top),\n      width: toa(rect.width),\n      height: toa(rect.height),\n      ...pathAttrs(style, offset),\n    };\n    if (radius) {\n      attrs.rx = toa(radius.x);\n      attrs.ry = toa(radius.y);\n    }\n    this.addFigure(drawTag(\"rect\", attrs, true));\n  }\n\n  drawEllipse(\n    offset: Point,\n    center: Point,\n    radius: Point,\n    style: PathStyle\n  ): void {\n    const attrs: XmlAttrs = {\n      ...pathAttrs(style, offset),\n      cx: toa(center.x),\n      cy: toa(center.y),\n      rx: toa(radius.x),\n      ry: toa(radius.y),\n    };\n    this.addFigure(`${drawTag(\"ellipse\", attrs, true)}`);\n  }\n\n  // Svg specific\n\n  addFigure(xmlCode: string) {\n    this.body.push(xmlCode);\n  }\n\n  addDef(id: string, value: string) {\n    this.defs[id] = value;\n  }\n\n  exportText(options?: SvgExportOptions): string {\n    return buildSvgText(this.size, this.defs, this.body, options ?? {});\n  }\n\n  clear() {\n    this.defs = {};\n    this.body.length = 0;\n  }\n\n  private size: Point = new Point();\n\n  defs: Record<string, string> = {};\n\n  body: string[] = [];\n}\n","import { SvgExportOptions } from \"./SvgExportOptions\";\n\n/**\n * This options can be useful for non-standalone SVG creating\n */\nexport const standaloneExportOptions: SvgExportOptions = Object.freeze({\n  xml: {\n    version: \"1.0\",\n    encoding: \"UTF-8\",\n    standalone: \"no\",\n  },\n  doctype: `svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"`,\n  svg: {\n    xmlns: \"http://www.w3.org/2000/svg\",\n    version: \"1.1\",\n    baseProfile: \"full\",\n    \"xmlns:xlink\": \"http://www.w3.org/1999/xlink\",\n    \"xmlns:ev\": \"http://www.w3.org/2001/xml-events\",\n  },\n});\n","import { Point } from \"../../../math/Point\";\nimport { XmlAttrs } from \"../../../utils/xml/xmlTypes\";\nimport { SvgExportOptions } from \"../SvgExportOptions\";\nimport { drawTag } from \"../../../utils/xml/drawTag\";\nimport { getVersionStr } from \"../../../getVersion\";\n\nexport const buildSvgText = (\n  size: Point,\n  defs: Record<string, string>,\n  body: string[],\n  options: SvgExportOptions\n): string => {\n  let result = \"\";\n  const { xml, doctype, svg } = options;\n  if (xml) {\n    result += `${drawTag(\"?xml\", xml, true).replace(\"/>\", \"?>\")}\\n`;\n  }\n  if (doctype) {\n    result += `<!DOCTYPE ${doctype}>\\n`;\n  }\n  const rootAttrs: XmlAttrs = {\n    viewBox: `0 0 ${size.x} ${size.y}`,\n    ...svg,\n  };\n  if (options.width) rootAttrs.width = options.width;\n  if (options.height) rootAttrs.height = options.height;\n  if (!(\"xmlns\" in rootAttrs)) {\n    rootAttrs.xmlns = \"http://www.w3.org/2000/svg\";\n  }\n  result += `${drawTag(\"svg\", rootAttrs)}\\n`;\n  if (!options.excludeVerInfo) {\n    result += `  <!-- Generated by CharChem v.${getVersionStr()} -->\\n`;\n  }\n  const defsList = Object.keys(defs);\n  if (defsList.length > 0) {\n    result += `  <defs>\\n`;\n    defsList.forEach((key: string) => {\n      result += `    ${defs[key]}\\n`;\n    });\n    result += `  </defs>\\n`;\n  }\n  body.forEach((s) => {\n    result += `  ${s}\\n`;\n  });\n  result += `</svg>`;\n  return result;\n};\n","import { LocalFontProps } from \"../AbstractSurface\";\nimport { fontWeightValue } from \"./fontWeightValue\";\n\nexport const createLocalFontHash = (props: LocalFontProps): string => {\n  let hash = `family:${props.family};height:${props.height};`;\n  if (props.weight) {\n    const v = fontWeightValue(props.weight);\n    if (v !== 400) hash += `weight:${v};`;\n  }\n  if (props.style && props.style !== \"normal\") hash += `style:${props.style};`;\n  if (props.stretch && props.stretch !== \"normal\")\n    hash += `stretch:${props.stretch};`;\n  return hash;\n};\n","import { RulesHtml } from \"../../textRules/rulesHtml\";\nimport { ChemK } from \"../../core/ChemK\";\nimport { ChemCharge } from \"../../core/ChemCharge\";\nimport { ChemStyleId } from \"../ChemStyleId\";\nimport { ChemImgProps } from \"../ChemImgProps\";\n\nexport const createRulesList = (rules: RulesHtml) => {\n  const k = new ChemK(9);\n  const list: [ChemStyleId, string][] = [\n    [\"agentK\", rules.agentK(k)],\n    [\"comment\", rules.comment(\"A\")],\n    [\"custom\", rules.custom(\"A\")],\n    [\"itemCount\", rules.itemCount(k)],\n    [\"itemMass\", rules.itemMass(9)],\n    [\"nodeCharge\", rules.nodeCharge(new ChemCharge(\"9\", 9))],\n    [\"bracketCharge\", rules.bracketCharge(new ChemCharge(\"9\", 9))],\n    [\"bracketCount\", rules.bracketCount(k)],\n  ];\n  // Не вошедшие в список стили, которые являются индексами, считаются такими же как коэффициент элемента\n  const used = new Set<ChemStyleId>(list.map(([id]) => id));\n  ChemImgProps.getIndexStyles().forEach((styleId) => {\n    if (!used.has(styleId)) list.push([styleId, rules.itemCount(k)]);\n  });\n  return list;\n};\n","import { CommonFontFace } from \"../CommonFontFace\";\n\nexport const getBaseline = ({ ascent }: CommonFontFace): number => ascent;\n\nexport const getFontHeight = ({ ascent, descent }: CommonFontFace): number =>\n  ascent - descent;\n","import { FontWeight } from \"../FontTypes\";\n// see https://www.w3.org/TR/2008/REC-CSS2-20080411/fonts.html#propdef-font-weight\n// except bolder and lighter\n\nexport const fontWeightValue = (weight: FontWeight): number => {\n  const value = +weight;\n  if (!Number.isNaN(value)) return value;\n  if (weight === \"bold\") return 700;\n  return 400;\n};\n\nexport const isBold = (weight?: FontWeight): boolean =>\n  !!weight && fontWeightValue(weight) >= 700;\n","import { PathSeg } from \"../path\";\nimport { Point } from \"../../math/Point\";\nimport { toa } from \"../../math\";\n\nexport const pathToString = (segments: PathSeg[]): string =>\n  segments\n    .map((seg) => {\n      const { cmd } = seg;\n      let dstSeg: string = seg.rel ? cmd.toLowerCase() : cmd;\n      const addPoint = (p: Point) => {\n        if (dstSeg.length !== 1) dstSeg += \" \";\n        dstSeg += `${toa(p.x)} ${toa(p.y)}`;\n      };\n      switch (cmd) {\n        case \"M\":\n        case \"L\":\n        case \"T\":\n          addPoint(seg.pt);\n          break;\n        case \"H\":\n          dstSeg += toa(seg.x);\n          break;\n        case \"V\":\n          dstSeg += toa(seg.y);\n          break;\n        case \"C\":\n          addPoint(seg.cp1);\n          addPoint(seg.cp2);\n          addPoint(seg.pt);\n          break;\n        case \"S\":\n          addPoint(seg.cp2);\n          addPoint(seg.pt);\n          break;\n        case \"Q\":\n          addPoint(seg.cp);\n          addPoint(seg.pt);\n          break;\n        case \"A\":\n          addPoint(seg.r);\n          dstSeg += ` ${toa(seg.xRot)} ${seg.largeArc} ${seg.sweep}`;\n          addPoint(seg.pt);\n          break;\n        default:\n          break;\n      }\n      return dstSeg;\n    })\n    .join(\"\");\n","import { CommonFontFace, FontFaceBBox } from \"../CommonFontFace\";\n\nexport const scaleFontFace = (\n  src: CommonFontFace,\n  scale: number\n): CommonFontFace => {\n  const dst: CommonFontFace = { ...src };\n\n  dst.ascent *= scale;\n  dst.descent *= scale;\n  dst.capHeight *= scale;\n  dst.xHeight *= scale;\n  const { bbox } = src;\n  if (bbox) dst.bbox = bbox.map((v) => v * scale) as FontFaceBBox;\n\n  return dst;\n};\n","import { Point } from \"../../math/Point\";\nimport { PathSeg, PathVisitor } from \"../path\";\n\nexport const tracePath = (segments: PathSeg[], visitor: PathVisitor) => {\n  let p0 = new Point();\n  let prev = p0.clone();\n  let cpPrev = p0.clone();\n  const getPoint = (rel: boolean | undefined, p: Point): Point =>\n    rel ? prev.plus(p) : p;\n  const update = (p: Point, cp?: Point) => {\n    prev = p;\n    cpPrev = cp ?? p;\n  };\n  const calcCP = () => prev.times(2).minus(cpPrev);\n\n  segments.forEach((seg, i) => {\n    const { cmd } = seg;\n    if (cmd === \"Z\") {\n      (visitor.onZ ?? visitor.onL)(p0);\n      update(p0);\n    } else if (cmd === \"M\") {\n      const curPoint = getPoint(seg.rel, seg.pt);\n      visitor.onM(curPoint);\n      if (i === 0) p0 = curPoint;\n      update(curPoint);\n    } else if (cmd === \"L\") {\n      const curPoint = getPoint(seg.rel, seg.pt);\n      visitor.onL(curPoint);\n      update(curPoint);\n    } else if (cmd === \"H\") {\n      const curPoint = new Point(seg.rel ? prev.x + seg.x : seg.x, prev.y);\n      (visitor.onH ?? visitor.onL)(curPoint);\n      update(curPoint);\n    } else if (cmd === \"V\") {\n      const curPoint = new Point(prev.x, seg.rel ? prev.y + seg.y : seg.y);\n      (visitor.onV ?? visitor.onL)(curPoint);\n      update(curPoint);\n    } else if (cmd === \"C\") {\n      const cp1 = getPoint(seg.rel, seg.cp1);\n      const cp2 = getPoint(seg.rel, seg.cp2);\n      const dstPoint = getPoint(seg.rel, seg.pt);\n      visitor.onC(cp1, cp2, dstPoint);\n      update(dstPoint, cp2);\n    } else if (cmd === \"S\") {\n      const cp1 = calcCP();\n      const cp2 = getPoint(seg.rel, seg.cp2);\n      const dstPoint = getPoint(seg.rel, seg.pt);\n      visitor.onC(cp1, cp2, dstPoint);\n      update(dstPoint, cp2);\n    } else if (cmd === \"Q\") {\n      const cp = getPoint(seg.rel, seg.cp);\n      const pt = getPoint(seg.rel, seg.pt);\n      visitor.onQ(cp, pt);\n      update(pt, cp);\n    } else if (cmd === \"T\") {\n      const cp = calcCP();\n      const pt = getPoint(seg.rel, seg.pt);\n      visitor.onQ(cp, pt);\n      update(pt, cp);\n    } else if (cmd === \"A\") {\n      const pt = getPoint(seg.rel, seg.pt);\n      visitor.onA(seg.r, seg.xRot, seg.largeArc, seg.sweep, pt);\n      update(pt);\n    }\n  });\n};\n","import { Int } from \"../types\";\nimport { compile } from \"../compiler/compile\";\nimport { SrcMapItem } from \"../compiler/sourceMap/SrcMapItem\";\nimport { ChemAgent } from \"../core/ChemAgent\";\nimport { ChemExpr } from \"../core/ChemExpr\";\nimport { Lang, LangParams } from \"../lang\";\nimport { isSuitableForEquation } from \"./isSuitableForEquation\";\nimport { calcAbsMCD, Rational } from \"../math/Rational\";\nimport { ElemList } from \"../core/ElemList\";\nimport { makeElemList } from \"../inspectors/makeElemList\";\nimport { ifDef } from \"../utils/ifDef\";\nimport { equationDict } from \"./equationDict\";\nimport { ChemError } from \"../core/ChemError\";\nimport { checkElementsMatching } from \"./checkElementsMatching\";\nimport { makeCoeffEnumerator } from \"./coeffEnumerators\";\nimport { makeSourceWithNewCoeffs } from \"./makeSourceWithNewCoeffs\";\n\nexport type ChemEquationState = \"NotSolved\" | \"Error\" | \"Solved\";\n\nlet dictReady = false;\n\ninterface SolveRef {\n  srcCol: Int;\n  k: Rational;\n}\n\ninterface SolveItem {\n  dstCol: Int;\n  refs: SolveRef[];\n}\nconst newSolveItem = (dstCol: Int) => ({ dstCol, refs: [] });\n\nexport class ChemEquation {\n  private state: ChemEquationState = \"NotSolved\";\n\n  private msgId?: string;\n\n  private params?: LangParams;\n\n  private agents: ChemAgent[] = [];\n\n  private expr?: ChemExpr;\n\n  private nCols: number = 0;\n\n  private M: Rational[][] = []; // Матрица линейных уравнений\n\n  K: Rational[] = [];\n\n  private solves: SolveItem[] = []; // Набор записей типа A = 2B + C\n\n  private srcMap: SrcMapItem[] = [];\n\n  constructor() {\n    if (!dictReady) {\n      Lang.addDict(equationDict);\n      dictReady = true;\n    }\n    this.clear();\n  }\n\n  getSolves(): SolveItem[] {\n    return this.solves;\n  }\n\n  getExpr(): ChemExpr | undefined {\n    return this.expr;\n  }\n\n  protected setState(\n    state: ChemEquationState,\n    msgId?: string,\n    params?: LangParams\n  ): void {\n    this.state = state;\n    this.msgId = msgId ?? (state === \"NotSolved\" ? \"Not solved\" : undefined);\n    this.params = params;\n  }\n\n  getMessage(langId?: string): string {\n    return (\n      ifDef(this.msgId, (msgId) => Lang.tr(msgId, this.params, langId)) ?? \"\"\n    );\n  }\n\n  isSolved(): boolean {\n    return this.state === \"Solved\";\n  }\n\n  makeError(): Error {\n    return new ChemError(this.msgId || this.state, this.params);\n  }\n\n  clear() {\n    this.setState(\"NotSolved\");\n    this.agents = [];\n    this.expr = undefined;\n    this.M = [];\n    this.solves = [];\n    this.srcMap = [];\n  }\n\n  initBySrc(formula: string): void {\n    const expr = compile(formula, { srcMap: true });\n    this.initByExpr(expr, expr.srcMap ?? []);\n  }\n\n  initByExpr(expr: ChemExpr, srcMap: SrcMapItem[]): void {\n    this.clear();\n    if (!expr) {\n      return this.setState(\"Error\", \"Invalid expression\");\n    }\n    const { error } = expr;\n    if (error) {\n      if (error instanceof ChemError) {\n        return this.setState(\"Error\", error.msgId, error.params);\n      }\n      return this.setState(\"Error\", error.message);\n    }\n    this.expr = expr;\n    this.srcMap = srcMap;\n\n    const res = isSuitableForEquation(expr);\n    if (res) {\n      return this.setState(\"Error\", res.msgId);\n    }\n\n    this.agents = expr.getAgents();\n\n    const parts: ElemList[] = [];\n    this.agents.forEach((agent) => {\n      const { part } = agent;\n      const list = parts[part] || new ElemList();\n      list.addList(makeElemList(agent, true));\n      parts[part] = list;\n    });\n    const leftPart = parts[0];\n    const rightPart = parts[1];\n    if (!leftPart || !rightPart || parts.length !== 2) {\n      return this.setState(\"Error\", \"No separating operation\");\n    }\n    const elemRes = checkElementsMatching([leftPart, rightPart]);\n    if (elemRes) {\n      return this.setState(\"Error\", elemRes[0], elemRes[1]);\n    }\n\n    // Число колонок равно количеству агентов\n    this.nCols = this.agents.length;\n    this.K = this.agents.map(() => new Rational());\n    // Количество строк матрицы равно числу элементов в уравнении\n    this.M = leftPart.list.map(() => []);\n    // Индексация элементов\n    const elemIndex = leftPart.list.reduce(\n      (acc, rec, i) => ({ ...acc, [rec.id]: i }),\n      {} as Record<string, number>\n    );\n\n    this.agents.forEach((agent) => {\n      // массив коэффициентов для столбца\n      const col = this.M.map((row) => {\n        const k = new Rational();\n        row.push(k);\n        return k;\n      });\n      // Получить список элементоа для агента\n      const list = makeElemList(agent, true);\n      list.list.forEach((rec) => {\n        const c: number = rec.n * (agent.part === 1 ? -1 : 1);\n        ifDef(elemIndex[rec.id], (index) => {\n          ifDef(col[index], (k) => k.set(c));\n        });\n      });\n    });\n    return this.setState(\"NotSolved\");\n  }\n\n  getMatrix(): Rational[][] {\n    return this.M;\n  }\n\n  getMatrixStr(): string[] {\n    return this.M.map((row) => row.join(\" \"));\n  }\n\n  //---------------------------------------------------------\n  // Решение уравнения (вызов шагов до получения результата)\n  solve() {\n    while (this.state === \"NotSolved\") {\n      this.calcStep();\n    }\n  }\n\n  // Выполнение одного шага\n  calcStep(): void {\n    // Шаг может выполняться только в состоянии объекта-балансера, когда решение не найдено (и нет ошибок)\n    if (this.state !== \"NotSolved\") return;\n    // Если остался только один неизвестный коэффициент, уравнение можно считать решенным\n    if (this.solves.length === this.nCols - 1) {\n      this.simpleSolve();\n      return;\n    }\n    const { nRow, nCols } = this.findRowForAction();\n    if (nRow >= 0) {\n      if (nCols) {\n        this.onSimpleSolve(nRow, nCols[0], nCols[1]);\n      } else {\n        // Если найдена пустая строка, то удалить её\n        this.deleteMatrixRow(nRow);\n      }\n      return;\n    }\n    // Другой вариант - попытаться объединить две строки\n    if (this.try2RowsUnit()) return;\n\n    // Если других вариантов нет - пробуем решить перебором\n    if (!this.searchKoeffs()) {\n      this.setState(\"Error\", \"Balance is not found\");\n    }\n  }\n\n  deleteMatrixRow(rowIndex: Int) {\n    this.M.splice(rowIndex, 1);\n  }\n\n  // Найдено простое решение, когда один коэффициент выражается через другой\n  onSimpleSolve(rowIndex: Int, k0Index: Int, k1Index: Int) {\n    // Выразить один коэффициент через другой. Нр  2A - 3C = 0 =>  2A = 3C => A = 3/2C\n    const srcRow = this.M[rowIndex]!;\n    // Множитель, через который K[k0] выражается через K[k1]\n    const k: Rational = srcRow[k1Index]!.negx().divi(srcRow[k0Index]!);\n    // Отмечаем, что решение найдено для коэффициента агента #k0\n    const solveItem: SolveItem = newSolveItem(k0Index);\n    // И он равен коэффициенту агента #k1 с соотв. множителем\n    solveItem.refs.push({ srcCol: k1Index, k });\n    this.solves.unshift(solveItem);\n    this.deleteMatrixRow(rowIndex);\n\n    // Теперь нужно заменить в матрице все k0 на k1\n    //   A + B = C + D    =>    A B -C -D\n    //  3/2C + B = C + D  =>    0 B (3/2-1)C -D\n    // То есть, M1 = M1 + M0*m\n    // Затем M0 = 0\n    this.M.forEach((row) => {\n      row[k1Index]!.addi(row[k0Index]!.mulx(k));\n      row[k0Index]!.set(0);\n    });\n  }\n\n  findRowForAction(): { nRow: Int; nCols?: [Int, Int] } {\n    let nCols: [Int, Int] | undefined;\n    const nRow = this.M.findIndex((row) => {\n      const filledNdx: Int[] = row.reduce(\n        (acc, k, j) => (k.isZero() ? acc : [...acc, j]),\n        [] as Int[]\n      );\n      if (filledNdx.length === 0) return true; // Пустая строка\n      if (filledNdx.length === 2) {\n        const col0: Int = filledNdx[0]!;\n        const col1: Int = filledNdx[1]!;\n        if (row[col0]?.sign() !== row[col1]?.sign()) {\n          // строка, где ровно два коэффициента с разными знаками\n          nCols = [col0, col1];\n          return true;\n        }\n      }\n      return false;\n    });\n    return { nRow, nCols };\n  }\n\n  // Решить уравнение, приняв последний коэффициент за 1\n  // void IChemBalance::simpleSolve() {\n  simpleSolve() {\n    // обнуляем результирующие коэффициенты\n    this.K.forEach((k) => k.set(0));\n\n    // Берём оставшиеся неизвестные коэффициенты (обфычно один)\n    const unknownIndexes = this.getUnknownIndices();\n\n    // Заполняем их единицами\n    unknownIndexes.forEach((i) => this.K[i]?.set(1));\n\n    this.calcSolves();\n\n    // Привести все коэффициенты к общему знаменателю\n    this.optimizeKoeffs();\n\n    // Проверки\n    if (!this.checkKoeffs() || !this.checkBalance()) {\n      this.setState(\"Error\", \"Balance is not found\");\n    } else {\n      this.finalSolve();\n    }\n  }\n\n  finalSolve() {\n    // Переключить состояние на Решенное\n    this.setState(\"Solved\", \"\");\n\n    // Заполнить коэффициенты агентов\n    const { expr, K, agents, srcMap } = this;\n    if (expr) {\n      const numCoeffs = K.map(({ x }) => x);\n      const newSrc = makeSourceWithNewCoeffs(\n        numCoeffs,\n        agents,\n        expr.src,\n        srcMap\n      );\n      this.expr = compile(newSrc, { srcMap: true });\n    }\n  }\n\n  /**\n   * Вернуть индексы неизвестных коэффициентов\n   */\n  getUnknownIndices(): Int[] {\n    // вспомогательный массив, куда записываются найденны индексы. Значение 0 - соотв. ненайденному\n    const found: Int[] = new Array(this.nCols);\n    found.fill(0);\n    const notFound: Int[] = [];\n    this.solves.forEach((si) => {\n      found[si.dstCol] = 1;\n    });\n    // Теперь собираем список ненайденных\n    for (let j = 0; j !== this.nCols; j++) {\n      if (!found[j]) notFound.push(j);\n    }\n    return notFound;\n  }\n\n  calcSolves() {\n    // Теперь вычисляем найденные решения\n    this.solves.forEach(({ dstCol, refs }) => {\n      // выражение типа A = 2B + 3C\n      this.K[dstCol]?.set(0);\n      refs.forEach((ref) => {\n        this.K[dstCol]?.addi(ref.k.mulx(this.K[ref.srcCol]!));\n      });\n    });\n  }\n\n  optimizeKoeffs() {\n    // Ищем общий знаменатель\n    const comm: Int = this.K.reduce((acc, { y: k }) => {\n      const nod = calcAbsMCD(acc, k);\n      return Math.max(acc, (acc * k) / nod);\n    }, 1);\n    // Теперь переходим к целым коэффициентам. на y больше не обращаем внимания.\n    const ki: Int[] = this.K.map((r) => {\n      const m = comm / r.y;\n      return r.x * m;\n    });\n    let maxX: Int = ki.reduce((acc, it) => Math.max(acc, it), 0);\n\n    // иногда возможна ситуация, когда все коэффициенты имеют общий делитель...\n    // (возможно, алгоритм был бы эффективнее, если начинать об большего d и уменьшать до 2)\n    let d = 2;\n    /* eslint no-loop-func: \"off\" */\n    while (d <= maxX) {\n      // Пробуем разделить все коэффициенты на минимальный делитель d\n      const inv = ki.findIndex((v) => v % d !== 0);\n      if (inv >= 0) {\n        // если хоть один из коэффициентов не разделился без остатка на d, переходим к сдедующему значению d\n        d++;\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n      // если все коэффициэнты делятся, делим их и maxX\n      maxX /= d;\n      ki.forEach((value, j) => {\n        ki[j] = value / d;\n      });\n      // следующая итерация происходит с тем же d\n    }\n    // Заполнить полученными целыми значениями массив m_K\n    this.K = ki.map((value) => new Rational(value));\n  }\n\n  // Проверка коэффициентов\n  checkKoeffs(): boolean {\n    return !this.K.find((k) => k.x <= 0);\n  }\n\n  // Проверка баланса\n  checkBalance(): boolean {\n    const balance: Record<string, Int> = {};\n    this.agents.forEach((agent, j) => {\n      makeElemList(agent, true).list.forEach(({ id, n }) => {\n        let count = n;\n        if (agent.part > 0) count = -count;\n        count *= this.K[j]?.x ?? 0;\n        if (!balance[id]) {\n          balance[id] = count;\n        } else {\n          balance[id] += count;\n        }\n      });\n    });\n    // Теперь если есть хоть один ненулевой элемент, значит ошибка\n    return Object.values(balance).findIndex((v) => v !== 0) < 0;\n  }\n\n  try2RowsUnit(): boolean {\n    const { nCols, M } = this;\n    const end = M.length;\n    if (end < 2) {\n      return false;\n    }\n    let it0: Int;\n    let it1: Int;\n    let colNdx: Int = 0;\n    for (it0 = 0; ; ++it0) {\n      it1 = it0 + 1; // Вторая строка следующая за первой\n      if (it1 === end) {\n        // Если конец матрицы, значит не нашлось подходящих для объединения строк\n        return false;\n      }\n      const row0: Rational[] = this.M[it0]!;\n      // Цикл: вторая строка смещается до конца матрицы\n      for (; it1 !== end; ++it1) {\n        const row1 = this.M[it1]!;\n        for (colNdx = 0; colNdx !== nCols; colNdx++) {\n          if (!row0[colNdx]?.isZero() && !row1[colNdx]?.isZero()) break;\n        }\n        if (colNdx !== nCols) break;\n      }\n      if (it1 !== end) break; // найдены две строки it0 и it1, которые объединяются по колонке colNdx\n    }\n    const row0 = M[it0]!;\n    const row1 = M[it1]!;\n    const mul0 = new Rational(-1).divi(row0[colNdx]!);\n    const mul1 = new Rational(-1).divi(row1[colNdx]!);\n    // Сформировать решение из первой строки\n    // colNdx - индекс столбца, для которого формируется решение\n    const sitem: SolveItem = newSolveItem(colNdx);\n    row0.forEach((k, i) => {\n      if (i !== colNdx && !k.isZero()) {\n        // Добавляем слагаемое, если оно ненулевое\n        sitem.refs.push({\n          srcCol: i,\n          k: k.mulx(mul0),\n        });\n      }\n    });\n    if (sitem.refs.length === 0)\n      // Это значит, что в первой строке все остальные колонки, кроме j-й, пусты\n      return false;\n    this.solves.unshift(sitem);\n\n    // Вторая строка комбинируется с первой по принципу row1[i] = row0[i]*mul0 + row1[i]*mul1\n    // 2A -3B -4C   mul0=-1/2  A = 3/2B + 4/2C\n    // 3A -2B -4D   mul1=-1/3  A = 2/3B + 4/3D => 11/6B + 2C + 4/3D\n    for (let i = 0; i !== nCols; i++) {\n      row1[i] = row0[i]!.mulx(mul0).subi(row1[i]!.mulx(mul1));\n    }\n    // Удаляем первую строку из матрицы\n    this.deleteMatrixRow(it0);\n    it1--;\n\n    // Если в матрице остаётся более одной строки, значит нужно подставить только что высчитанный коэффициент\n    this.M.forEach((row, it) => {\n      if (it !== it1) {\n        const k = row[colNdx]!.copy();\n        row[colNdx]!.set(0);\n        sitem.refs.forEach((ref) => row[ref.srcCol]!.addi(k.mulx(ref.k)));\n      }\n    });\n\n    return true;\n  }\n\n  searchKoeffs(): boolean {\n    const unknownIndices = this.getUnknownIndices();\n    // N - количество переменных\n    const N = unknownIndices.length;\n    // MaxL - максимальное значение переменной\n    const MaxL = 30;\n    const gen = makeCoeffEnumerator(N, MaxL);\n    if (gen) {\n      for (const vars of gen) {\n        if (this.testKoeffs(unknownIndices, vars)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  testKoeffs(unknownIndexes: Int[], variants: Int[]): boolean {\n    unknownIndexes.forEach((uIndex, pos) => {\n      this.K[uIndex]?.set(variants[pos]!);\n    });\n    this.calcSolves();\n    if (!this.checkKoeffs()) return false;\n    this.optimizeKoeffs();\n    if (!this.checkBalance()) return false;\n    this.finalSolve();\n    return true;\n  }\n}\n","import { LangParams } from \"../lang\";\nimport { ElemList } from \"../core/ElemList\";\n\n/* eslint no-bitwise: \"off\" */\n\nexport const checkElementsMatching = (\n  parts: [ElemList, ElemList]\n): [string, LangParams | undefined] | undefined => {\n  for (let j = 0; j !== 2; j++) {\n    const first = parts[j];\n    const second = parts[j ^ 1];\n    if (!first || !second) {\n      return [\"Invalid expression\", undefined];\n    }\n    for (const elem of first.list) {\n      if (!second.findRec(elem)) {\n        // Не найден элемент\n        const partId = `${j === 0 ? \"right\" : \"left\"}|part`;\n        return [\"[E] is missing in [S] part\", { E: elem.id, S: partId }];\n      }\n    }\n  }\n  return undefined;\n};\n","import { Int } from \"../types\";\n\n/* eslint no-bitwise: \"off\" */\n\nexport const makeCoeffEnumerator = (\n  dimesion: Int,\n  level: Int\n): Generator<Int[]> => {\n  if (dimesion === 2) return coeffEnumerator2d(level);\n  if (dimesion === 3) return coeffEnumerator3d(level);\n  return coeffEnumeratorNd(dimesion, level);\n};\n\nexport function* coeffEnumerator2d(level: Int) {\n  for (let x0 = 1; x0 <= level; x0++) {\n    for (let y = 1, x = x0; x > 0; y++, x--) {\n      yield [y, x];\n    }\n  }\n  for (let y0 = 2; y0 <= level; y0++) {\n    for (let x = level, y = y0; y <= level; y++, x--) {\n      yield [y, x];\n    }\n  }\n}\n\nexport function* coeffEnumerator3d(level: Int): Generator<Int[]> {\n  yield [1, 1, 1];\n  // Перемещение по x\n  for (let x0 = 2; x0 <= level; x0++) {\n    let x = x0;\n    let y = 1;\n    let z = 1;\n    // фронтальная плоскость XY\n    for (; x > 1; x--, y++) yield [z, y, x];\n    // левая плоскость YZ, x=1\n    for (; y > 1; z++, y--) yield [z, y, x];\n    // верхняя плоскость XZ\n    for (; z > 1; z--, x++) yield [z, y, x];\n  }\n  // по Y\n  const c = Math.floor((level - 2) / 2) + 2;\n  for (let y0 = 2; y0 < level; y0++) {\n    if (y0 === c) {\n      for (const v of coeffEnumerator3d(level - 2)) {\n        yield v.map((i) => i + 1);\n      }\n    }\n    let x = level;\n    let y = y0;\n    let z = 1;\n    for (; y < level; y++, x--) yield [z, y, x];\n    for (; x > 1; z++, x--) yield [z, y, x];\n    for (; z < level; z++, y--) yield [z, y, x];\n    for (; y > 1; x++, y--) yield [z, y, x];\n    for (; x < level; x++, z--) yield [z, y, x];\n    for (; z > 1; z--, y++) yield [z, y, x];\n  }\n  // по Z\n  for (let z0 = 1; z0 < level; z0++) {\n    let x = level;\n    let y = level;\n    let z = z0;\n    for (; z < level; x--, z++) yield [z, y, x];\n    for (; x < level; x++, y--) yield [z, y, x];\n    for (; y < level; z--, y++) yield [z, y, x];\n  }\n\n  if (level > 1) {\n    yield [level, level, level];\n  }\n}\n\n/**\n * Перебор выполняется только для высокоуровневых выриантов,\n * а вложенные части раскрываются при помощи перебора более низкого порядка\n * @param dimension\n * @param maxLevel\n */\nexport function* coeffEnumeratorNd(\n  dimension: Int,\n  maxLevel: Int\n): Generator<Int[]> {\n  const vars = new Array<Int>(dimension);\n  vars.fill(1);\n  yield [...vars];\n  const maxMask = 1 << dimension;\n  for (let level = 2; level <= maxLevel; level++) {\n    // перебор верхнеуровневых вариантов\n    for (let mask = 1; mask !== maxMask; mask++) {\n      const subLevelNdx: Int[] = [];\n      vars.fill(1);\n      for (let col = 0; col < dimension; col++) {\n        const test = 1 << col;\n        if ((mask & test) === 0) {\n          subLevelNdx.push(col);\n        } else {\n          vars[col] = level;\n        }\n      }\n      const sn = subLevelNdx.length;\n      if (level > 2 && sn > 0) {\n        // Перебор вложенной части\n        const gen = makeCoeffEnumerator(sn, level - 1);\n        for (const subVals of gen) {\n          subVals.forEach((v, j) => {\n            vars[subLevelNdx[j]!] = v;\n          });\n          yield [...vars];\n        }\n      } else {\n        yield [...vars];\n      }\n    }\n  }\n}\n","export const equationDict = {\n  ru: {\n    \"[E] is missing in [S] part\":\n      \"Отсутствует элемент [E] в [S#] части уравнения\",\n    \"left|part\": \"левой\",\n    \"right|part\": \"правой\",\n    \"Equation not specified\": \"Уравнение не задано\",\n    \"No separating operation\":\n      \"Требуется одна операция, разделяющая левую и правую часть уравнения\",\n    \"No solution\": \"Не удалось найти решение\",\n    \"Cant balance expression with abstract coefficients\":\n      \"Невозможно балансировать уравнение с абстрактными коэффициентами\",\n    \"Cant balance expression with non-integer coefficients\":\n      \"Невозможно балансировать уравнение с дробными коэффициентами\",\n    \"Cant balance expression with mineral series\":\n      \"Невозможно балансировать неопределенные формулы минералов\",\n    \"Invalid expression\": \"Неподходящее выражение\",\n  },\n  en: {\n    \"[E] is missing in [S] part\":\n      \"Element [E] is missing on the [S#] side of the equation.\",\n    \"left|part\": \"left\",\n    \"right|part\": \"right\",\n    \"Equation not specified\": \"The equation is not specified\",\n    \"No separating operation\":\n      \"Requires a single operation, separating the left and right side of the equation\",\n    \"No solution\": \"Could not find a solution\",\n    \"Cant balance expression with abstract coefficients\":\n      \"Can't balance expression with abstract coefficients\",\n    \"Cant balance expression with non-integer coefficients\":\n      \"Can't balance expression with non-integer coefficients\",\n    \"Cant balance expression with mineral series\":\n      \"Can't balance expression with mineral series\",\n    \"Invalid expression\": \"Неподходящее выражение\",\n  },\n};\n","import { ChemMul } from \"../core/ChemMul\";\nimport { ChemExpr } from \"../core/ChemExpr\";\nimport { ChemNodeItem } from \"../core/ChemNodeItem\";\n\ntype NegativeResult = {\n  reason: \"abstract\" | \"float\";\n  msgId: string;\n};\n\nconst msgAbs = \"Cant balance expression with abstract coefficients\";\n\n/**\n *  Нельзя искать баланс для уравнений, имеющий абстрактные или не целочисленные коэффициенты\n * При этом, нас интересуют коэффициенты при элементах, но не важны коэффициенты агентов\n * @param expr\n */\nexport const isSuitableForEquation = (\n  expr: ChemExpr\n): NegativeResult | undefined =>\n  expr.walkExt({\n    isStop: false as boolean,\n    result: undefined as NegativeResult | undefined,\n    itemPre({ n }: ChemNodeItem) {\n      if (!n.isNumber()) {\n        this.result = {\n          reason: \"abstract\",\n          msgId: msgAbs,\n        };\n      } else if (!n.isInt()) {\n        this.result = {\n          reason: \"float\",\n          msgId: \"Cant balance expression with non-integer coefficients\",\n        };\n      }\n      this.isStop = !!this.result;\n    },\n    mul({ n }: ChemMul) {\n      if (!n.isNumber()) {\n        this.result = {\n          reason: \"abstract\",\n          msgId: msgAbs,\n        };\n      }\n    },\n    comma() {\n      this.result = {\n        reason: \"abstract\",\n        msgId: \"Cant balance expression with mineral series\",\n      };\n    },\n  }).result;\n","import { Int } from \"../types\";\nimport { ChemAgent } from \"../core/ChemAgent\";\nimport { SrcMapItem, getSrcItemsForObject } from \"../compiler/sourceMap\";\n\nexport const makeSourceWithNewCoeffs = (\n  coeffs: Int[],\n  agents: ChemAgent[],\n  oldSrc: string,\n  srcMap: SrcMapItem[]\n): string => {\n  const chunks: string[] = [];\n  let prevPos = 0;\n  agents.forEach((agent, agentIndex) => {\n    const agentItems = getSrcItemsForObject(agent, srcMap);\n    const itemsCount = agentItems.length;\n    // Нужно учитывать возможные неудачные результаты\n    if (itemsCount) {\n      const leftPos = agentItems[0]!.begin;\n      // const rightPos = agentItems[itemsCount-1]!.end;\n      // Текст левее агента\n      chunks.push(oldSrc.slice(prevPos, leftPos));\n      prevPos = leftPos;\n      // Текст нового коэффициента\n      const k = coeffs[agentIndex];\n      if (k !== undefined && k !== 1) {\n        chunks.push(String(k));\n      }\n      // текст агента без коэффициента\n      if (itemsCount > 1 && agentItems[0]!.part === \"agentK\") {\n        prevPos = agentItems[1]!.begin;\n      }\n    }\n  });\n  chunks.push(oldSrc.slice(prevPos));\n  return chunks.join(\"\").trim();\n};\n","import version from \"./version\";\n\nexport const getVersion = () => version as [number, number, number];\n\nexport const getVersionStr = (): string => getVersion().join(\".\");\n","import { Double } from \"../types\";\nimport { ChemObj } from \"../core/ChemObj\";\n\n/**\n * Вычисление заряда объекта.\n * Используется для объектов от узла и выше.\n * При наличии абстрактных коэффициентов возвращается NaN\n */\nexport const calcCharge = (chemObj: ChemObj): Double => {\n  const stack: Double[] | [Double] = [0.0];\n  const push = () => {\n    stack.unshift(0.0);\n  };\n\n  const pop = (calc: () => Double) => {\n    const value: Double = stack[0]! * calc();\n    stack.shift();\n    stack[0] += value;\n  };\n\n  chemObj.walk({\n    agentPre() {\n      push();\n    },\n    agentPost(obj) {\n      pop(() => obj.n.num);\n    },\n    bracketBegin() {\n      push();\n    },\n    bracketEnd(obj) {\n      const { charge } = obj;\n      if (charge) {\n        stack[0] = charge.value;\n      }\n      pop(() => obj.n.num);\n    },\n\n    // TODO: Пока нет поддержки множителей\n\n    nodePost(obj) {\n      // Ниже уровня узла заряд не проверяем\n      const { charge } = obj;\n      if (charge) {\n        stack[0] += charge.value;\n      }\n    },\n  });\n  return stack[0]!;\n};\n","import { Double } from \"../types\";\nimport { ChemObj } from \"../core/ChemObj\";\nimport { ifDef } from \"../utils/ifDef\";\n/**\n * Вычисление массы указанного химического объекта.\n * @param chemObj Любой химический объект (выражение, агент, узел и т.п.)\n * @param applyAgentK Если указать false, то игнорируются коэффициенты агентов.\n *\n * Примечание 1. Рекомендуется использовать функцию isAbstract прежде чем вызывать calcMass.\n * Т.к. если в состав объекта входят абстрактные элементы, то результат непредсказуем.\n * Никакого исключения при этом не генерируется.\n * Например, для выражения {R}-OH мы получим сумму масс O и H\n *\n * Примечание 2. Эта функция не слишком полезна для выражений с несколькими агентами.\n * Поэтому для выражений ChemExpr рекомендуется использовать метод mass.\n */\nexport const calcMass = (\n  chemObj: ChemObj,\n  applyAgentK: boolean = true\n): Double => {\n  const stack: Double[] | [Double] = [0.0];\n  const push = () => {\n    stack.unshift(0.0);\n  };\n  const pop = (calc: () => Double) => {\n    const value: Double = stack[0]! * calc();\n    stack.shift();\n    stack[0]! += value;\n  };\n\n  chemObj.walk({\n    agentPre() {\n      push();\n    },\n\n    agentPost(obj) {\n      pop(() => (applyAgentK ? obj.n.num : 1.0));\n    },\n\n    mul() {\n      push();\n    },\n    mulEnd(obj) {\n      pop(() => obj.begin.n.num);\n    },\n\n    bracketBegin() {\n      push();\n    },\n    bracketEnd(obj) {\n      pop(() => obj.n.num);\n    },\n\n    nodePre() {\n      push();\n    },\n    nodePost() {\n      pop(() => 1.0);\n    },\n\n    itemPre() {\n      push();\n    },\n    itemPost(obj) {\n      // явно указанная масса $M() более приоритетна, чем вычисленная\n      ifDef(obj.mass, (mass) => {\n        stack[0] = mass;\n      });\n      pop(() => obj.n.num);\n    },\n\n    atom(obj) {\n      stack[0] += obj.mass;\n    },\n\n    radical(obj) {\n      obj.items.list.forEach((listItem) => {\n        stack[0] += listItem.n * (listItem.elem?.mass ?? 0.0);\n      });\n    },\n  });\n  return stack[0]!;\n};\n","import { ChemObj } from \"../core/ChemObj\";\nimport { ChemK } from \"../core/ChemK\";\nimport { Visitor } from \"../core/Visitor\";\nimport { ChemAgent } from \"../core/ChemAgent\";\nimport { ChemNodeItem } from \"../core/ChemNodeItem\";\nimport { ChemBracketEnd } from \"../core/ChemBracket\";\nimport { ChemMul } from \"../core/ChemMul\";\nimport { ChemCustom } from \"../core/ChemCustom\";\n\n/**\n * Является ли указанное выражение абстрактным.\n * Это происходит при следующих условиях:\n * - Наличие абстрактного элемента: {R}-OH\n * - Наличие нечисловых коэффициентов: C'n'H'2n+2'\n * - Запятая: (Ca,Mg)SO4\n */\nexport const isAbstract = (chemObj: ChemObj): boolean => {\n  const visitor = new IsAbstractVisitor(true);\n  chemObj.walk(visitor);\n  return visitor.isStop;\n};\n\nexport const isAbstractCoeffs = (chemObj: ChemObj): boolean => {\n  const visitor = new IsAbstractVisitor(false);\n  chemObj.walk(visitor);\n  return visitor.isStop;\n};\n\nconst isAbsK = (k?: ChemK): boolean => (k ? !k.isNumber() : false);\n\nclass IsAbstractVisitor implements Visitor {\n  isStop: boolean = false;\n\n  constructor(private useItems: boolean) {}\n\n  agentPre(obj: ChemAgent) {\n    this.isStop = isAbsK(obj.n);\n  }\n\n  itemPre(obj: ChemNodeItem) {\n    this.isStop = isAbsK(obj.n);\n  }\n\n  bracketEnd(obj: ChemBracketEnd) {\n    this.isStop = isAbsK(obj.n);\n  }\n\n  mul(obj: ChemMul) {\n    this.isStop = isAbsK(obj.n);\n  }\n\n  custom(obj: ChemCustom) {\n    // Наличие пустых узлов не делает формулу абстрактной, т.к. они нужны для фиктивных элементов\n    if (this.useItems && obj.text) {\n      this.isStop = true;\n    }\n  }\n\n  comma() {\n    if (this.useItems) {\n      this.isStop = true;\n    }\n  }\n}\n","import { ChemObj } from \"../core/ChemObj\";\n\nexport const isTextFormula = (chemObj: ChemObj): boolean => {\n  const visitor = chemObj.walkExt({\n    isStop: false as boolean,\n    bond(obj) {\n      this.isStop = !obj.isText;\n    },\n    itemPre(obj) {\n      this.isStop = !!obj.dots;\n    },\n    bracketBegin(obj) {\n      // If the $padding function is used, it means graphic mode\n      this.isStop = !!obj.padding;\n    },\n  });\n  return !visitor.isStop;\n};\n","import { Int } from \"../types\";\nimport { ChemObj } from \"../core/ChemObj\";\n\nexport const locateAtomNumber = (item: ChemObj): Int | undefined => {\n  let num: number | undefined;\n  item.walk({\n    atom(obj) {\n      num = obj.n;\n    },\n  });\n  return num;\n};\n","import { ChemExpr } from \"../core/ChemExpr\";\nimport { compile } from \"../compiler/compile\";\nimport { ChemObj } from \"../core/ChemObj\";\nimport { makeElemList } from \"./makeElemList\";\nimport { isAbstractCoeffs } from \"./isAbstract\";\n\nexport const makeBruttoKey = (src: ChemObj | string): string => {\n  let obj: ChemObj;\n  if (typeof src === \"string\") {\n    const expr = compile(src);\n    if (!expr.isOk()) return \"\";\n    obj = expr;\n  } else {\n    if (src instanceof ChemExpr && !src.isOk()) {\n      return \"\";\n    }\n    obj = src;\n  }\n  // Если в формуле есть абстрактные элементы, это приемлемо.\n  // Но если есть абстрактные коэффициенты, тогда вычислить нельзя.\n  if (isAbstractCoeffs(obj)) return \"\";\n\n  const elemList = makeElemList(obj);\n  elemList.sortByHill();\n  return String(elemList);\n};\n","import { Double } from \"../types\";\nimport { ChemObj } from \"../core/ChemObj\";\nimport { ElemList } from \"../core/ElemList\";\n/**\n * Generate a list of elements from an expression.\n * Does not make sense for expressions that have more than one agent.\n */\nexport const makeElemList = (\n  chemObj: ChemObj,\n  ignoreAgentK: boolean = false\n): ElemList => {\n  const stack: ElemList[] = [new ElemList()];\n  const push = () => {\n    stack.unshift(new ElemList());\n  };\n  const pop = (k: Double) => {\n    const list = stack.shift()!;\n    list.scale(k);\n    stack[0]!.addList(list);\n  };\n\n  chemObj.walk({\n    agentPre() {\n      push();\n    },\n    agentPost(obj) {\n      pop(ignoreAgentK ? 1 : obj.n.num);\n    },\n\n    nodePost(obj) {\n      stack[0]!.charge += obj.charge?.value ?? 0.0;\n    },\n\n    bracketBegin() {\n      push();\n    },\n    bracketEnd(obj) {\n      const { charge } = obj;\n      if (charge) {\n        stack[0]!.charge = charge.value;\n      }\n      pop(obj.n.num);\n    },\n\n    mul() {\n      push();\n    },\n    mulEnd(obj) {\n      pop(obj.begin.n.num);\n    },\n\n    itemPre() {\n      push();\n    },\n    itemPost(obj) {\n      pop(obj.n.num);\n    },\n    atom(obj) {\n      stack[0]!.addAtom(obj);\n    },\n    custom(obj) {\n      stack[0]!.addCustom(obj.text);\n    },\n    radical(obj) {\n      stack[0]!.addRadical(obj);\n    },\n  });\n  return stack[0]!;\n};\n","import { ChemBond } from \"../core/ChemBond\";\nimport { ChemObj } from \"../core/ChemObj\";\nimport { RulesBase } from \"../textRules/RulesBase\";\nimport { ChemCharge } from \"../core/ChemCharge\";\nimport { ifDef } from \"../utils/ifDef\";\nimport { compile } from \"../compiler/compile\";\nimport { rulesText } from \"../textRules/rulesText\";\nimport { locateAtomNumber } from \"./locateAtomNumber\";\n\ninterface Chunk {\n  text: string;\n  color?: string;\n}\n\nclass StackItem {\n  l2r: boolean = true;\n\n  chunks: Chunk[] = [];\n\n  add(chunk: Chunk) {\n    if (this.l2r) {\n      this.chunks.push(chunk);\n    } else {\n      this.chunks.unshift(chunk);\n    }\n  }\n}\n\n/**\n * Сформировать текстовое представление химической формулы.\n * Не все формулы могут быть представлены в виде текста.\n * Поэтому перед вызовом этой функции нужно использовать isTextFormula\n */\nexport const makeTextFormula = (\n  chemObj: ChemObj,\n  rules: RulesBase = rulesText\n): string => {\n  const stack: StackItem[] = [new StackItem()];\n  let itemColor: string | undefined;\n  let atomColor: string | undefined;\n\n  const push = () => {\n    stack.unshift(new StackItem());\n  };\n\n  const pop = () => {\n    if (stack.length === 1) {\n      return;\n    }\n    const item = stack.shift()!;\n    const top = stack[0]!;\n    if (top.l2r) {\n      top.chunks = [...top.chunks, ...item.chunks];\n    } else {\n      top.chunks = [...item.chunks, ...top.chunks];\n    }\n  };\n\n  const ctxOut = (text: string, color?: string) =>\n    stack[0]!.add({ text, color });\n\n  const space = () => ctxOut(\" \");\n\n  const isLtr = (bond?: ChemBond): boolean => !bond?.isNeg;\n\n  const drawCharge = (\n    charge: ChemCharge | undefined,\n    isPrefix: boolean,\n    color?: string\n  ) =>\n    ifDef(charge, (it) => {\n      if (isPrefix === it.isLeft) {\n        ctxOut(rules.nodeCharge(it), color);\n      }\n    });\n\n  let autoNode = false;\n\n  chemObj.walk({\n    agentPre(obj) {\n      space();\n      push();\n      if (obj.n.isSpecified()) {\n        ctxOut(rules.agentK(obj.n));\n      }\n    },\n    agentPost() {\n      pop();\n    },\n    atom(obj) {\n      if (!autoNode) {\n        ctxOut(rules.atom(obj.id), atomColor ?? itemColor);\n      }\n    },\n\n    bond(obj) {\n      stack[0]!.l2r = isLtr(obj);\n      ctxOut(obj.tx, obj.color);\n    },\n\n    comma() {\n      ctxOut(rules.comma(), itemColor);\n    },\n\n    comment(obj) {\n      ctxOut(rules.comment(obj.text), itemColor);\n    },\n\n    custom(obj) {\n      ctxOut(rules.custom(obj.text), itemColor);\n    },\n\n    itemPre(obj) {\n      if (autoNode) return;\n      itemColor = obj.color;\n      atomColor = obj.atomColor;\n      const rawAtomNum = obj.atomNum;\n      if (rawAtomNum !== undefined) {\n        // Вывести двухэтажную конструкцию: масса/атомный номер слева от элемента\n        const atomNum = rawAtomNum === \"\" ? locateAtomNumber(obj) : rawAtomNum;\n        if (atomNum === undefined) {\n          ctxOut(rules.itemMass(obj.mass || 0), itemColor);\n        } else {\n          ctxOut(rules.itemMassAndNum(obj.mass || 0, atomNum), itemColor);\n        }\n      } else {\n        ifDef(obj.mass, (mass) => ctxOut(rules.itemMass(mass), itemColor));\n      }\n    },\n\n    itemPost(obj) {\n      if (autoNode) return;\n      if (obj.charge) ctxOut(rules.itemCharge(obj.charge), itemColor);\n      if (obj.n.isSpecified()) ctxOut(rules.itemCount(obj.n), itemColor);\n    },\n\n    nodePre(obj) {\n      push();\n      drawCharge(obj.charge, true, obj.color);\n      if (obj.autoMode) {\n        autoNode = true;\n      }\n    },\n\n    nodePost(obj) {\n      drawCharge(obj.charge, false, obj.color);\n      autoNode = false;\n      pop();\n    },\n\n    operation(obj) {\n      space();\n      ctxOut(rules.operation(obj), obj.color);\n    },\n\n    radical(obj) {\n      ctxOut(rules.radical(obj.label), itemColor);\n    },\n\n    bracketBegin(obj) {\n      const ltr = isLtr(obj.bond);\n      if (ltr) {\n        push();\n        drawCharge(obj.end?.charge, true, obj.color);\n        ctxOut(obj.text, obj.color);\n      } else {\n        const { color, end } = obj;\n        if (end) {\n          if (stack[0]) stack[0].l2r = false;\n          drawCharge(end.charge, false, color);\n          if (end.n.isSpecified()) ctxOut(rules.itemCount(end.n), color);\n          ctxOut(end.text, color);\n        }\n        push();\n      }\n    },\n\n    bracketEnd(obj) {\n      const { begin } = obj;\n      const { color } = begin;\n      const ltr = isLtr(begin.bond);\n      if (ltr) {\n        ctxOut(obj.text, color);\n        if (obj.n.isSpecified()) ctxOut(rules.itemCount(obj.n), color);\n        drawCharge(obj.charge, false, color);\n        pop();\n      } else {\n        pop();\n        if (stack[0]) stack[0].l2r = false;\n        ctxOut(begin.text, color);\n        drawCharge(obj.charge, true, color);\n      }\n    },\n\n    mul(obj) {\n      if (!obj.isFirst) ctxOut(rules.mul(), obj.color);\n      if (obj.n.isSpecified()) ctxOut(rules.mulK(obj.n), obj.color);\n    },\n  });\n\n  // Обычно такое не нужно.\n  // Но если нужно получить текст для одной команды (скобки), тогда содержимое может остаться в стеке.\n  while (stack.length > 1) pop();\n\n  const nonOptimized = buildTextFromChunks(stack[0]!.chunks, rules).trim();\n  return rules.postProcess(nonOptimized);\n};\n\nconst buildTextFromChunks = (chunks: Chunk[], rules: RulesBase): string => {\n  const tags = chunks.map((chunkItem, index) => {\n    let result = chunkItem.text;\n    const { color } = chunkItem;\n    if (color) {\n      const needOpen = index === 0 || color !== chunks[index - 1]!.color;\n      const needClose =\n        index === chunks.length - 1 || color !== chunks[index + 1]!.color;\n      if (needOpen) result = rules.colorBegin(color) + result;\n      if (needClose) result += rules.colorEnd();\n    }\n    return result;\n  });\n  return tags.reduce((acc: string, tag) => acc + tag, \"\");\n};\n\nexport const makeTextFormulaSrc = (\n  sourceText: string,\n  rules: RulesBase\n): string => {\n  const expr = compile(sourceText);\n  if (!expr.isOk()) return \"\";\n  return makeTextFormula(expr, rules);\n};\n","import { ifDef } from \"../utils/ifDef\";\nimport { baseDictEn } from \"./baseDictEn\";\nimport { baseDictRu } from \"./baseDictRu\";\nimport { LocalDict, LangParams } from \"./LangTypes\";\nimport { replaceLangParams } from \"./replaceLangParams\";\n\nexport class Lang {\n  /**\n   * Current language\n   * Format uses from https://tools.ietf.org/html/rfc7231#section-3.1.3.1\n   * Examples: en, ru - internal languages; zh, zh-TW - external (by addDict)\n   */\n  static curLang: string = \"en\";\n\n  static navLang: string | undefined = undefined;\n\n  /**\n   * Translate phrase\n   * example: Lang.tr(\"Hello, [first] [last]\", listOf(\"first\" to \"John\", \"last\" to \"Connor\"))\n   */\n  static tr(key: string, params?: LangParams, langId?: string): string {\n    // actual language\n    const lang = (!langId ? Lang.curLang : langId).toLowerCase();\n    const { dict } = Lang;\n    // find local dictionary\n    let curDict: LocalDict | undefined = dict[lang];\n    if (!curDict) {\n      const k = lang.indexOf(\"-\");\n      if (k >= 0) curDict = dict[lang.substring(0, k)];\n    }\n    const finalDict: LocalDict = curDict ?? Lang.enDict;\n    // find phrase\n    const text = finalDict[key] ?? key;\n    return replaceLangParams({ text, params, langId, tr: Lang.tr });\n  }\n\n  static findPhrase(key: string): string | undefined {\n    return Lang.dict[Lang.curLang]?.[key];\n  }\n\n  private static ruDict: LocalDict = baseDictRu;\n\n  private static enDict: LocalDict = baseDictEn;\n\n  static dict: Record<string, LocalDict> = {\n    en: Lang.enDict,\n    ru: Lang.ruDict,\n  };\n\n  static addDict(globalDictUpdates: Record<string, LocalDict>) {\n    const { dict } = Lang;\n    Object.entries(globalDictUpdates).forEach(([locale, locDict]) => {\n      if (!dict[locale]) {\n        dict[locale] = locDict;\n      } else {\n        dict[locale] = { ...dict[locale], ...locDict };\n      }\n    });\n  }\n}\n\nif (typeof window !== \"undefined\") {\n  Lang.navLang = (\n    navigator.language ||\n    // @ts-ignore\n    navigator.browserLanguage ||\n    // @ts-ignore\n    navigator.userLanguage ||\n    \"en\"\n  ).toLowerCase();\n\n  ifDef(Lang.navLang, (navLang) => {\n    if (navLang in Lang.dict) {\n      Lang.curLang = navLang;\n    } else if (navLang.indexOf(\"-\") >= 0) {\n      const loc = navLang.split(\"-\")[0]!;\n      if (loc in Lang.dict) {\n        Lang.curLang = loc;\n      }\n    }\n  });\n}\n","export const baseDictEn: Record<string, string> = {\n  $Native: \"English\",\n  $English: \"English\",\n  \"Invalid version\":\n    \"Formula requires CharChem version [need] instead of [cur]\",\n  H: \"Hydrogen\",\n  He: \"Helium\",\n  Li: \"Lithium\",\n  Be: \"Beryllium\",\n  B: \"Boron\",\n  C: \"Carbon\",\n  N: \"Nitrogen\",\n  O: \"Oxygen\",\n  F: \"Fluorine\",\n  Ne: \"Neon\",\n  Na: \"Sodium\",\n  Mg: \"Magnesium\",\n  Al: \"Aluminium\",\n  Si: \"Silicon\",\n  P: \"Phosphorus\",\n  S: \"Sulfur\",\n  Cl: \"Chlorine\",\n  Ar: \"Argon\",\n  K: \"Potassium\",\n  Ca: \"Calcium\",\n  Sc: \"Scandium\",\n  Ti: \"Titanium\",\n  V: \"Vanadium\",\n  Cr: \"Chromium\",\n  Mn: \"Manganese\",\n  Fe: \"Iron\",\n  Co: \"Cobalt\",\n  Ni: \"Nickel\",\n  Cu: \"Copper\",\n  Zn: \"Zinc\",\n  Ga: \"Gallium\",\n  Ge: \"Germanium\",\n  As: \"Arsenic\",\n  Se: \"Selenium\",\n  Br: \"Bromine\",\n  Kr: \"Krypton\",\n  Rb: \"Rubidium\",\n  Sr: \"Strontium\",\n  Y: \"Yttrium\",\n  Zr: \"Zirconium\",\n  Nb: \"Niobium\",\n  Mo: \"Molybdenum\",\n  Tc: \"Technetium\",\n  Ru: \"Ruthenium\",\n  Rh: \"Rhodium\",\n  Pd: \"Palladium\",\n  Ag: \"Silver\",\n  Cd: \"Cadmium\",\n  In: \"Indium\",\n  Sn: \"Tin\",\n  Sb: \"Antimony\",\n  Te: \"Tellurium\",\n  I: \"Iodine\",\n  Xe: \"Xenon\",\n  Cs: \"Caesium\",\n  Ba: \"Barium\",\n  La: \"Lanthanum\",\n  Ce: \"Cerium\",\n  Pr: \"Praseodymium\",\n  Nd: \"Neodymium\",\n  Pm: \"Promethium\",\n  Sm: \"Samarium\",\n  Eu: \"Europium\",\n  Gd: \"Gadolinium\",\n  Tb: \"Terbium\",\n  Dy: \"Dysprosium\",\n  Ho: \"Holmium\",\n  Er: \"Erbium\",\n  Tm: \"Thulium\",\n  Yb: \"Ytterbium\",\n  Lu: \"Lutetium\",\n  Hf: \"Hafnium\",\n  Ta: \"Tantalum\",\n  W: \"Tungsten\",\n  Re: \"Rhenium\",\n  Os: \"Osmium\",\n  Ir: \"Iridium\",\n  Pt: \"Platinum\",\n  Au: \"Gold\",\n  Hg: \"Mercury\",\n  Tl: \"Thallium\",\n  Pb: \"Lead\",\n  Bi: \"Bismuth\",\n  Po: \"Polonium\",\n  At: \"Astatine\",\n  Rn: \"Radon\",\n  Fr: \"Francium\",\n  Ra: \"Radium\",\n  Ac: \"Actinium\",\n  Th: \"Thorium\",\n  Pa: \"Protactinium\",\n  U: \"Uranium\",\n  Np: \"Neptunium\",\n  Pu: \"Plutonium\",\n  Am: \"Americium\",\n  Cm: \"Curium\",\n  Bk: \"Berkelium\",\n  Cf: \"Californium\",\n  Es: \"Einsteinium\",\n  Fm: \"Fermium\",\n  Md: \"Mendelevium\",\n  No: \"Nobelium\",\n  Lr: \"Lawrencium\",\n  Rf: \"Rutherfordium\",\n  Db: \"Dubnium\",\n  Sg: \"Seaborgium\",\n  Bh: \"Bohrium\",\n  Hs: \"Hassium\",\n  Mt: \"Meitnerium\",\n  Ds: \"Darmstadtium\",\n  Rg: \"Roentgenium\",\n  Cn: \"Copernicium\",\n  Nh: \"Nihonium\",\n  Fl: \"Flerovium\",\n  Mc: \"Moscovium\",\n  Lv: \"Livermorium\",\n  Ts: \"Tennessine\",\n  Og: \"Oganesson\",\n};\n","export const baseDictRu: Record<string, string> = {\n  $Native: \"Русский\",\n  $English: \"Russian\",\n  // Ошибки\n  \"Internal error: [msg]\": \"Внутренняя ошибка: [msg]\",\n  \"Formula can not be displayed as text\":\n    \"Формулу нельзя отобразить в текстовом виде\",\n  \"Expected '(' after [S]\": \" Требуется '(' после [S]\",\n  \"Unexpected '[C]'\": \"Неверный символ '[C]' в позиции [pos]\",\n  \"Expected '[ok]' instead of '[bad]'\":\n    \"Требуется '[ok]' вместо '[bad]' в позиции [pos]\",\n  \"Invalid character '[C]'\": \"Недопустимый символ '[C]' в позиции [pos]\",\n  \"Russian element character\":\n    \"Недопустимый русский символ '[C]'. Для описания химического элемента должны использоваться только латинские символы.\",\n  \"Non-latin element character\":\n    \"Недопустимый символ '[C]'. Для описания химического элемента должны использоваться только латинские символы.\",\n  \"Unknown element character '[C]'\":\n    \"Недопустимый символ '[C]' описания реагента в позиции [pos]\",\n  \"Expected '[C]'\": \"Требуется '[C]' в позиции [pos]\",\n  \"Unknown element '[Elem]'\": \"Ошибочный элемент '[Elem]' в позиции [pos]\",\n  \"Comment is not closed\": \"Не закрыт комментарий, начатый в позиции [pos]\",\n  \"Abstract coefficient is not closed\":\n    \"Не закрыт абстрактный коэффициент, начатый в позиции [pos]\",\n  \"Abstract element is not closed\":\n    \"Не закрыт абстрактный элемент, начатый в позиции [pos]\",\n  \"Expected node declaration before charge\":\n    \"Неизвестно, к чему нужно применить заряд в позиции [pos]\",\n  \"Invalid charge declaration\": \"Ошибка в описании заряда в позиции [pos]\",\n  \"It is necessary to close the bracket\":\n    \"Необходимо закрыть скобку, открытую в позиции [pos]\",\n  \"Expected variable name\": \"Требуется указать имя переменной в позиции [pos]\",\n  \"Undefined variable [name]\":\n    \"Не определена числовая переменная '[name]' в позиции [pos]\",\n  \"Invalid node reference '[ref]'\":\n    \"Неправильная ссылка на узел '[ref]' в позиции [pos]\",\n  \"Invalid label\": \"Неправильная метка в позиции [pos]\",\n  \"Invalid branch close\":\n    \"Нельзя закрыть ветку в позиции [pos], которая не открыта\",\n  \"Cant close branch before bracket\":\n    \"Нельзя закрыть ветку в позиции [pos], пока не закрыта скобка в позиции [pos0]\",\n  \"Cant close bracket before branch\":\n    \"Нельзя закрыть скобку в позиции [pos], пока не закрыта ветка в позиции [pos0]\",\n  \"Invalid bracket close\": \"Нет пары для скобки, закрытой в позиции [pos]\",\n  \"It is necessary to close the branch\":\n    \"Необходимо закрыть ветку, открытую в позиции [pos]\",\n  \"Expected [must] instead of [have]\":\n    \"Требуется [must] вместо [have] в позиции [pos]\",\n  \"Invalid middle point\": \"Не используется промежуточная точка\",\n  \"Cant create ring\": \"Невозможно создать кольцо\",\n  \"Cant close ring\": \"Невозможно замкнуть кольцо\",\n  \"Invalid version\":\n    \"Для формулы требуется CharChem версии [need] вместо [cur]\",\n  \"Invalid number [n]\": \"Неверное числовое значение [n] в позиции [pos]\",\n\n  \"Periodic Table\": \"Периодическая система химических элементов\",\n  \"Table legend\": \"Группы химических элементов\",\n  Group: \"Группа\",\n  Period: \"Период\",\n  Row: \"Ряд\",\n  \"[x]-block\": \"[x]-блок\",\n  Lanthanides: \"Лантаноиды\",\n  Actinides: \"Актиноиды\",\n  \"Alkali metals\": \"Щелочные металлы\",\n  \"Alkaline earth metals\": \"Щёлочноземельные металлы\",\n  \"Transition metals\": \"Переходные металлы\",\n  \"Post transition metals\": \"Постпереходные металлы\",\n  Metalloids: \"Полуметаллы\",\n  \"Other nonmetals\": \"Неметаллы\",\n  Halogens: \"Галогены\",\n  \"Noble gases\": \"Инертные газы\",\n  \"Unknown props\": \"Св-ва неизвестны\",\n\n  \"(s)\": \"(тв)\",\n  \"(l)\": \"(ж)\",\n  \"(g)\": \"(г)\",\n  \"(aq)\": \"(р-р)\",\n  H: \"Водород\",\n  He: \"Гелий\",\n  Li: \"Литий\",\n  Be: \"Бериллий\",\n  B: \"Бор\",\n  C: \"Углерод\",\n  N: \"Азот\",\n  O: \"Кислород\",\n  F: \"Фтор\",\n  Ne: \"Неон\",\n  Na: \"Натрий\",\n  Mg: \"Магний\",\n  Al: \"Алюминий\",\n  Si: \"Кремний\",\n  P: \"Фосфор\",\n  S: \"Сера\",\n  Cl: \"Хлор\",\n  Ar: \"Аргон\",\n  K: \"Калий\",\n  Ca: \"Кальций\",\n  Sc: \"Скандий\",\n  Ti: \"Титан\",\n  V: \"Ванадий\",\n  Cr: \"Хром\",\n  Mn: \"Марганец\",\n  Fe: \"Железо\",\n  Co: \"Кобальт\",\n  Ni: \"Никель\",\n  Cu: \"Медь\",\n  Zn: \"Цинк\",\n  Ga: \"Галлий\",\n  Ge: \"Германий\",\n  As: \"Мышьяк\",\n  Se: \"Селен\",\n  Br: \"Бром\",\n  Kr: \"Криптон\",\n  Rb: \"Рубидий\",\n  Sr: \"Стронций\",\n  Y: \"Иттрий\",\n  Zr: \"Цирконий\",\n  Nb: \"Ниобий\",\n  Mo: \"Молибден\",\n  Tc: \"Технеций\",\n  Ru: \"Рутений\",\n  Rh: \"Родий\",\n  Pd: \"Палладий\",\n  Ag: \"Серебро\",\n  Cd: \"Кадмий\",\n  In: \"Индий\",\n  Sn: \"Олово\",\n  Sb: \"Сурьма\",\n  Te: \"Теллур\",\n  I: \"Йод\",\n  Xe: \"Ксенон\",\n  Cs: \"Цезий\",\n  Ba: \"Барий\",\n  La: \"Лантан\",\n  Ce: \"Церий\",\n  Pr: \"Празеодим\",\n  Nd: \"Неодим\",\n  Pm: \"Прометий\",\n  Sm: \"Самарий\",\n  Eu: \"Европий\",\n  Gd: \"Гадолиний\",\n  Tb: \"Тербий\",\n  Dy: \"Диспрозий\",\n  Ho: \"Гольмий\",\n  Er: \"Эрбий\",\n  Tm: \"Тулий\",\n  Yb: \"Иттербий\",\n  Lu: \"Лютеций\",\n  Hf: \"Гафний\",\n  Ta: \"Тантал\",\n  W: \"Вольфрам\",\n  Re: \"Рений\",\n  Os: \"Осмий\",\n  Ir: \"Иридий\",\n  Pt: \"Платина\",\n  Au: \"Золото\",\n  Hg: \"Ртуть\",\n  Tl: \"Таллий\",\n  Pb: \"Свинец\",\n  Bi: \"Висмут\",\n  Po: \"Полоний\",\n  At: \"Астат\",\n  Rn: \"Радон\",\n  Fr: \"Франций\",\n  Ra: \"Радий\",\n  Ac: \"Актиний\",\n  Th: \"Торий\",\n  Pa: \"Протактиний\",\n  U: \"Уран\",\n  Np: \"Нептуний\",\n  Pu: \"Плутоний\",\n  Am: \"Америций\",\n  Cm: \"Кюрий\",\n  Bk: \"Берклий\",\n  Cf: \"Калифорний\",\n  Es: \"Эйнштейний\",\n  Fm: \"Фермий\",\n  Md: \"Менделеевий\",\n  No: \"Нобелий\",\n  Lr: \"Лоуренсий\",\n  Rf: \"Резерфордий\",\n  Db: \"Дубний\",\n  Sg: \"Сиборгий\",\n  Bh: \"Борий\",\n  Hs: \"Хассий\",\n  Mt: \"Мейтнерий\",\n  Ds: \"Дармштадтий\",\n  Rg: \"Рентгений\",\n  Cn: \"Коперниций\",\n  Nh: \"Нихоний\",\n  Fl: \"Флеровий\",\n  Mc: \"Московий\",\n  Lv: \"Ливерморий\",\n  Ts: \"Теннессин\",\n  Og: \"Оганесон\",\n};\n","export * from \"./Lang\";\nexport * from \"./LangTypes\";\n","import { ifDef } from \"../utils/ifDef\";\nimport { LangParams } from \"./LangTypes\";\n\ninterface ParamsReplaceLangParams {\n  text: string;\n  params?: LangParams;\n  langId?: string;\n  tr(key: string, params?: LangParams, langId?: string): string;\n}\n\nexport const replaceLangParams = (\n  fnParams: ParamsReplaceLangParams\n): string => {\n  const { text, params, langId, tr } = fnParams;\n  let result = \"\";\n  let pos = 0;\n  const getValue = (key: string) =>\n    ifDef(params?.[key], (value) => String(value)) ?? key;\n  while (pos >= 0) {\n    const begin = text.indexOf(\"[\", pos);\n    if (begin < 0) break;\n    const end = text.indexOf(\"]\", begin);\n    if (end < 0) break;\n    result += text.slice(pos, begin);\n    const key = text.slice(begin + 1, end);\n    // TODO: Пока что укороченный вариант. В дальнейшем возможен вариант со списком параметров после #\n    if (key.endsWith(\"#\")) {\n      const pureKey = key.slice(0, -1);\n      result += tr(getValue(pureKey), {}, langId);\n    } else {\n      result += getValue(key);\n    }\n    pos = end + 1;\n  }\n  return result + text.slice(pos);\n  // return paramsList.reduce(\n  //   (acc, [name, val]) => acc.replace(`[${name}]`, String(val)),\n  //   text\n  // );\n};\n","import { toa } from \"./index\";\nimport { Double } from \"../types\";\nimport { Point } from \"./Point\";\nimport { deg2rad } from \"./radians\";\n\n//              a       b       c       d       e       f\ntype Double6 = [Double, Double, Double, Double, Double, Double];\n\n// eslint-disable-next-line no-shadow\nconst enum Index6 {\n  a,\n  b,\n  c,\n  d,\n  e,\n  f,\n}\n\n/**\n *  ┌ a c e ┐\n *  │ b d f │\n *  └ 0 0 1 ┘\n *\n */\nexport class Matrix2x3 {\n  m: Double6;\n\n  constructor(m?: Double6) {\n    this.m = m ?? [0, 0, 0, 0, 0, 0];\n  }\n\n  clone(): Matrix2x3 {\n    return new Matrix2x3([...this.m]);\n  }\n\n  // Human readable string representation\n  toString() {\n    return this.m.map((value) => toa(value)).join(\" \");\n  }\n\n  // String representation without loss of precision.\n  // Useful for generating css and svg transformation attributes.\n  // Similar to the Python language.\n  repr(divider: string = \" \") {\n    return this.m.join(divider);\n  }\n\n  static createIdentity(): Matrix2x3 {\n    return new Matrix2x3([1, 0, 0, 1, 0, 0]);\n  }\n\n  static createZero(): Matrix2x3 {\n    return new Matrix2x3([0, 0, 0, 0, 0, 0]);\n  }\n\n  translate(pt: Point): void;\n\n  translate(dx: Double, dy: Double): void;\n\n  translate(a: Point | Double, b?: Double) {\n    if (a instanceof Point) {\n      this.m[Index6.e] += a.x;\n      this.m[Index6.f] += a.y;\n    } else if (typeof a === \"number\" && typeof b === \"number\") {\n      this.m[Index6.e] += a;\n      this.m[Index6.f] += b;\n    }\n  }\n\n  moveX(x: Double) {\n    this.m[Index6.e] += x;\n  }\n\n  moveY(y: Double) {\n    this.m[Index6.f] += y;\n  }\n\n  scale(k: Double, ky?: Double) {\n    this.m[Index6.a] *= k;\n    this.m[Index6.d] *= ky ?? k;\n    this.m[Index6.e] *= k;\n    this.m[Index6.f] *= ky ?? k;\n  }\n\n  scaleX(kx: Double) {\n    this.m[Index6.a] *= kx;\n  }\n\n  scaleY(ky: Double) {\n    this.m[Index6.d] *= ky;\n  }\n\n  rotate(radians: Double) {\n    const cosA = Math.cos(radians);\n    const sinA = Math.sin(radians);\n    this.m[Index6.a] = cosA;\n    this.m[Index6.b] = sinA;\n    this.m[Index6.c] = -sinA;\n    this.m[Index6.d] = cosA;\n  }\n\n  rotateDeg(degrees: Double) {\n    this.rotate(deg2rad(degrees));\n  }\n\n  apply(pt: Point): Point {\n    return new Point(\n      this.a * pt.x + this.c * pt.y + this.e,\n      this.b * pt.x + this.d * pt.y + this.f\n    );\n  }\n\n  get a(): Double {\n    return this.m[Index6.a];\n  }\n\n  set a(value: Double) {\n    this.m[Index6.a] = value;\n  }\n\n  get b(): Double {\n    return this.m[Index6.b];\n  }\n\n  set b(value: Double) {\n    this.m[Index6.b] = value;\n  }\n\n  get c(): Double {\n    return this.m[Index6.c];\n  }\n\n  set c(value: Double) {\n    this.m[Index6.c] = value;\n  }\n\n  get d(): Double {\n    return this.m[Index6.d];\n  }\n\n  set d(value: Double) {\n    this.m[Index6.d] = value;\n  }\n\n  get e(): Double {\n    return this.m[Index6.e];\n  }\n\n  set e(value: Double) {\n    this.m[Index6.e] = value;\n  }\n\n  get f(): Double {\n    return this.m[Index6.f];\n  }\n\n  set f(value: Double) {\n    this.m[Index6.f] = value;\n  }\n}\n","import { toa, is0 } from \"./index\";\nimport { Double } from \"../types\";\nimport { deg2rad, rad2deg } from \"./radians\";\n\nexport const pointFromRad = (angle: Double): Point =>\n  new Point(Math.cos(angle), Math.sin(angle));\n\nexport const pointFromDeg = (angle: Double): Point =>\n  pointFromRad(deg2rad(angle));\n\nexport class Point {\n  x: Double;\n\n  y: Double;\n\n  constructor(x: Double = 0.0, y: Double = 0.0) {\n    this.x = x;\n    this.y = y;\n  }\n\n  set(x: Double, y: Double): void {\n    this.x = x;\n    this.y = y;\n  }\n\n  setPt(src: Point): void {\n    this.x = src.x;\n    this.y = src.y;\n  }\n\n  toString(): string {\n    return `(${toa(this.x)}, ${toa(this.y)})`;\n  }\n\n  clone(): Point {\n    return new Point(this.x, this.y);\n  }\n\n  // Operator p == p\n  equals(other: Point): boolean {\n    return is0(this.x - other.x) && is0(this.y - other.y);\n  }\n\n  isZero(): boolean {\n    return is0(this.x) && is0(this.y);\n  }\n\n  // Operator p + p\n  plus(pt: Point): Point {\n    return new Point(this.x + pt.x, this.y + pt.y);\n  }\n\n  add(deltaX: Double, deltaY: Double): this {\n    this.x += deltaX;\n    this.y += deltaY;\n    return this;\n  }\n\n  iadd(pt: Point): this {\n    this.x += pt.x;\n    this.y += pt.y;\n    return this;\n  }\n\n  isub(pt: Point): this {\n    this.x -= pt.x;\n    this.y -= pt.y;\n    return this;\n  }\n\n  // Operator p - p\n  minus(pt: Point): Point {\n    return new Point(this.x - pt.x, this.y - pt.y);\n  }\n\n  neg(): Point {\n    return new Point(-this.x, -this.y);\n  }\n\n  // Operator p * k\n  times(k: Double): Point {\n    return new Point(k * this.x, k * this.y);\n  }\n\n  scale(k: Double): this {\n    this.x *= k;\n    this.y *= k;\n    return this;\n  }\n\n  mini(pt: Point): void {\n    this.x = Math.min(this.x, pt.x);\n    this.y = Math.min(this.y, pt.y);\n  }\n\n  maxi(pt: Point): void {\n    this.x = Math.max(this.x, pt.x);\n    this.y = Math.max(this.y, pt.y);\n  }\n\n  polarAngle(): Double {\n    if (is0(this.x) && is0(this.y)) {\n      return 0.0;\n    }\n    if (is0(this.x)) {\n      return this.y > 0.0 ? Math.PI / 2.0 : -Math.PI / 2.0;\n    }\n    return Math.atan2(this.y, this.x);\n  }\n\n  polarAngleDeg(): Double {\n    return rad2deg(this.polarAngle());\n  }\n\n  // Square of length\n  lengthSqr(): Double {\n    return this.x * this.x + this.y * this.y;\n  }\n\n  length(): Double {\n    return Math.sqrt(this.lengthSqr());\n  }\n\n  distSqr(p: Point): Double {\n    return p.minus(this).lengthSqr();\n  }\n\n  dist(p: Point): Double {\n    return Math.sqrt(this.distSqr(p));\n  }\n\n  normal(): Point {\n    const len = this.length();\n    return is0(len) ? new Point() : this.times(1 / len);\n  }\n\n  transpon(ccw?: boolean): Point {\n    return ccw ? new Point(this.y, -this.x) : new Point(-this.y, this.x);\n  }\n\n  static get zero() {\n    return staticZero;\n  }\n}\n\nconst staticZero = Object.freeze(new Point());\n","import { Int } from \"../types\";\n\n/**\n * rational fraction\n */\nexport class Rational {\n  constructor(public x: Int = 0, public y: Int = 1) {}\n\n  set(value: Int): this {\n    this.x = value;\n    this.y = 1;\n    return this;\n  }\n\n  toString(): string {\n    const { x, y } = this;\n    return y === 1 ? String(x) : `${x}/${y}`;\n  }\n\n  copy(): Rational {\n    return new Rational(this.x, this.y);\n  }\n\n  isZero(): boolean {\n    return this.x === 0;\n  }\n\n  absLess(other: Rational): boolean {\n    // Числитель каждой дроби домножаем на знаменатель другой, чтобы привести обе дроби к общему знаменателю.\n    return Math.abs(this.x) * other.y < Math.abs(other.x) * this.y;\n  }\n\n  sign(): -1 | 0 | 1 {\n    if (this.x < 0) return -1;\n    if (this.x > 0) return 1;\n    return 0;\n  }\n\n  negx(): Rational {\n    return new Rational(-this.x, this.y);\n  }\n\n  absx(): Rational {\n    return new Rational(Math.abs(this.x), this.y);\n  }\n\n  norm(): this {\n    if (this.y < 0) {\n      this.x = -this.x;\n      this.y = -this.y;\n    }\n    if (this.x === 0) {\n      this.y = 1;\n    } else if (this.x < 1 || this.x > 1) {\n      const m = calcAbsMCD(this.x, this.y);\n      this.x /= m;\n      this.y /= m;\n    }\n    return this;\n  }\n\n  addi(v: Int | Rational): this {\n    if (typeof v === \"number\") {\n      // целое число\n      this.x += v * this.y; // v домножается на знаменатель\n    } else {\n      // дробь\n      if (this.y === v.y) {\n        // Если дроби имеют одинаковый знаменатель, то можно просто сложить числители\n        this.x += v.x;\n      } else {\n        // Для приведения к общему знаменателю домножаем числители на чужие знаменатели. А знаменатели друг на друга\n        this.x = this.x * v.y + v.x * this.y;\n        this.y *= v.y;\n      }\n      this.norm();\n    }\n    return this;\n  }\n\n  addx(v: Int | Rational): Rational {\n    return typeof v === \"number\"\n      ? new Rational(this.x + v * this.y, this.y)\n      : this.copy().addi(v);\n  }\n\n  subi(a: Rational): this {\n    // вариант вычитания числа из дроби не нужен.\n    return this.addi(a.negx());\n  }\n\n  subx(a: Rational) {\n    // вариант вычитания числа из дроби не нужен.\n    return a.negx().addi(this);\n  }\n\n  // Умножение на целое число / Умножение на дробь\n  muli(v: Int | Rational): this {\n    if (typeof v === \"number\") {\n      this.x *= v; // при домножении дроби на число меняется только числитель\n    } else {\n      this.x *= v.x;\n      this.y *= v.y;\n    }\n    return this.norm();\n  }\n\n  mulx(v: Int | Rational): Rational {\n    if (typeof v === \"number\") {\n      // при домножении дроби на число меняется только числитель\n      return new Rational(this.x * v, this.y).norm();\n    }\n    const r = new Rational(this.x * v.x, this.y * v.y);\n    return r.norm();\n  }\n\n  // Деление на дробь\n  divi(a: Rational): this {\n    // Деление = умножение на перевёрнутую дробь\n    const { x, y } = a;\n    this.x *= y;\n    this.y *= x;\n    return this.norm();\n  }\n\n  divx(a: Rational): Rational {\n    // Деление = умножение на перевёрнутую дробь\n    const r = new Rational(this.x * a.y, this.y * a.x);\n    return r.norm();\n  }\n}\n\n/**\n * Вычисление наибольшего общего делителя для двух чисел. Знак не имеет значения.\n * @param a\n * @param b\n * @return {number}\n */\nexport const calcAbsMCD = (a: Int, b: Int): Int => {\n  // Минимальное значение (без учёта знака)\n  let m = Math.min(Math.abs(a), Math.abs(b));\n  while (m > 1) {\n    if (a % m === 0 && b % m === 0) break;\n    m--;\n  }\n  return m;\n};\n","/**\n * Rectangle object\n * Created by PeterWin\n * ver 1.1 on 26.04.2017\n * ver 2.0 on 30.05.2022\n */\nimport { Point } from \"./Point\";\nimport { Double } from \"../types\";\nimport { is0, toa } from \"./index\";\n\n/* eslint-disable no-bitwise */\n\nexport class Rect {\n  readonly A: Point;\n\n  readonly B: Point;\n\n  constructor();\n\n  constructor(a: Point, b: Point);\n\n  constructor(ax: Double, ay: Double, bx: Double, by: Double);\n\n  constructor(\n    a?: Point | Double,\n    b?: Point | Double,\n    bx?: Double,\n    by?: Double\n  ) {\n    if (typeof a === \"number\" && typeof b === \"number\") {\n      this.A = new Point(a, b);\n      this.B = new Point(bx, by);\n    } else if (a instanceof Point && b instanceof Point) {\n      this.A = a.clone();\n      this.B = b.clone();\n    } else {\n      this.A = new Point();\n      this.B = new Point();\n    }\n  }\n\n  get left(): Double {\n    return this.A.x;\n  }\n\n  get top(): Double {\n    return this.A.y;\n  }\n\n  get right(): Double {\n    return this.B.x;\n  }\n\n  get bottom(): Double {\n    return this.B.y;\n  }\n\n  get width(): Double {\n    return this.B.x - this.A.x;\n  }\n\n  get height(): Double {\n    return this.B.y - this.A.y;\n  }\n\n  get size(): Point {\n    return new Point(this.width, this.height);\n  }\n\n  get cx(): Double {\n    return this.left + this.width * 0.5;\n  }\n\n  get cy(): Double {\n    return this.top + this.height * 0.5;\n  }\n\n  get center(): Point {\n    return new Point(this.cx, this.cy);\n  }\n\n  toString() {\n    return `{${toa(this.left)}, ${toa(this.top)}, ${toa(this.right)}, ${toa(\n      this.bottom\n    )}}`;\n  }\n\n  isEmpty(): boolean {\n    return is0(this.width) && is0(this.height);\n  }\n\n  clone(): Rect {\n    return new Rect(this.A, this.B);\n  }\n\n  updatePoint(pt: Point) {\n    this.A.x = Math.min(this.A.x, pt.x);\n    this.A.y = Math.min(this.A.y, pt.y);\n    this.B.x = Math.max(this.B.x, pt.x);\n    this.B.y = Math.max(this.B.y, pt.y);\n  }\n\n  unite(rc: Rect): Rect {\n    this.updatePoint(rc.A);\n    this.updatePoint(rc.B);\n    return this;\n  }\n\n  move(delta: Point) {\n    this.A.iadd(delta);\n    this.B.iadd(delta);\n  }\n\n  moveXY(deltaX: Double, deltaY: Double) {\n    this.A.add(deltaX, deltaY);\n    this.B.add(deltaX, deltaY);\n  }\n\n  contains(pt: Point): boolean {\n    return (\n      this.A.x <= pt.x &&\n      this.B.x >= pt.x &&\n      this.A.y <= pt.y &&\n      this.B.y >= pt.y\n    );\n  }\n\n  grow(delta: Double, deltaY?: Double): Rect {\n    const realDeltaY: Double = deltaY ?? delta;\n    this.A.x -= delta;\n    this.B.x += delta;\n    this.A.y -= realDeltaY;\n    this.B.y += realDeltaY;\n    return this;\n  }\n\n  scale(k: Double) {\n    this.A.scale(k);\n    this.B.scale(k);\n  }\n\n  clip(a: Point, b: Point): { inside: boolean; a: Point; b: Point } {\n    let { x: x1, y: y1 } = a;\n    let { x: x2, y: y2 } = b;\n    const { left, right, top, bottom } = this;\n\n    const makeOutcodes = (x: number, y: number): number =>\n      mkMask(0, x < left) |\n      mkMask(1, y < top) |\n      mkMask(2, x > right) |\n      mkMask(3, y > bottom);\n    let ocu1 = makeOutcodes(x1, y1);\n    let ocu2 = makeOutcodes(x2, y2);\n    let inside = (ocu1 | ocu2) === 0;\n    let outside = (ocu1 & ocu2) !== 0;\n    let isSwap = false;\n    while (!outside && !inside) {\n      // swap endpoints if necessary so that (x1,y1) needs to be clipped\n      if (ocu1 === 0) {\n        [x1, x2] = [x2, x1];\n        [y1, y2] = [y2, y1];\n        [ocu1, ocu2] = [ocu2, ocu1];\n        isSwap = !isSwap;\n      }\n      if (isMask(0, ocu1)) {\n        // clip left\n        y1 += ((y2 - y1) * (left - x1)) / (x2 - x1);\n        x1 = left;\n      } else if (isMask(1, ocu1)) {\n        // clip above\n        x1 += ((x2 - x1) * (top - y1)) / (y2 - y1);\n        y1 = top;\n      } else if (isMask(2, ocu1)) {\n        // clip right\n        y1 += ((y2 - y1) * (right - x1)) / (x2 - x1);\n        x1 = right;\n      } else if (isMask(3, ocu1)) {\n        // clip below\n        x1 += ((x2 - x1) * (bottom - y1)) / (y2 - y1);\n        y1 = bottom;\n      }\n      ocu1 = makeOutcodes(x1, y1);\n      inside = (ocu1 | ocu2) === 0; // update\n      outside = (ocu1 & ocu2) !== 0; //  4-bit codes\n    }\n    const p1 = new Point(x1, y1);\n    const p2 = new Point(x2, y2);\n    return { inside, a: isSwap ? p2 : p1, b: isSwap ? p1 : p2 };\n  }\n}\n\nconst mkMask = (pos: 0 | 1 | 2 | 3, val: boolean): number =>\n  val ? 1 << pos : 0;\n\nconst isMask = (pos: 0 | 1 | 2 | 3, code: number): boolean =>\n  !!(code & (1 << pos));\n\nexport const updateRect = (pt: Point, srcRect?: Rect): Rect => {\n  if (!srcRect) return new Rect(pt, pt);\n  srcRect.updatePoint(pt);\n  return srcRect;\n};\n","export const normalize360 = (degAngle: number): number => {\n  const m = degAngle % 360;\n  return m < 0 ? 360 + m : m;\n};\n","import { Double } from \"../types\";\n\nexport const is0 = (value: Double) => Math.abs(value) < 0.001;\n\nexport const isClose = (a: Double, b: Double) => is0(Math.abs(a) - Math.abs(b));\n\nexport const toa = (value: Double): string =>\n  value.toFixed(2).replace(/0+$/g, \"\").replace(/\\.$/, \"\").replace(/^-0$/, \"0\");\n","import { toa } from \"./index\";\nimport { Double } from \"../types\";\n\nexport const roundMass = (mass: Double): Double =>\n  Math.round(mass * 100.0) / 100.0;\n\nexport const strMass = (mass: Double) => toa(roundMass(mass));\n","import { Double } from \"../types\";\n\nexport const rad2deg = (angleInRadians: Double) =>\n  (angleInRadians * 180.0) / Math.PI;\n\nexport const deg2rad = (angleInDegrees: Double) =>\n  (angleInDegrees * Math.PI) / 180.0;\n","import { Figure } from \"../drawSys/figures/Figure\";\nimport { ChemNode } from \"../core/ChemNode\";\nimport { Point } from \"../math/Point\";\nimport { ResultBuildNode } from \"./buildNode\";\n\nexport interface NodeInfo {\n  node: ChemNode;\n  res: ResultBuildNode;\n  left?: Figure;\n  right?: Figure;\n}\n\n/**\n * Position of node center relative to owner frame\n */\nexport const getNodeCenterPos = (nodeInfo: NodeInfo): Point =>\n  nodeInfo.res.nodeFrame.org.plus(nodeInfo.res.center);\n\nexport const getNodeInfo = (node: ChemNode, nodesInfo: NodeInfo[]): NodeInfo =>\n  nodesInfo[node.index]!;\n// Предполагается, что все узлы уже включены в nodesInfo. Поэтому результат не может быть undefined\n","import { Double } from \"../types\";\nimport { Rect } from \"../math/Rect\";\n\nexport const applyPadding = (\n  src: Rect,\n  pads: Double[],\n  scale: Double\n): Rect => {\n  if (pads.length === 1) {\n    return src.clone().grow(pads[0]! * scale);\n  }\n  if (pads.length === 2) {\n    return src.clone().grow(pads[1]! * scale, pads[0]! * scale);\n  }\n  if (pads.length === 3) {\n    const top = pads[0]! * scale;\n    const dx = pads[1]! * scale;\n    const bot = pads[2]! * scale;\n    return new Rect(\n      src.left - dx,\n      src.top - top,\n      src.right + dx,\n      src.bottom + bot\n    );\n  }\n  const t = pads[0]! * scale;\n  const r = pads[1]! * scale;\n  const b = pads[2]! * scale;\n  const l = pads[3]! * scale;\n  return new Rect(src.left - l, src.top - t, src.right + r, src.bottom + b);\n};\n","import { Point } from \"../../math/Point\";\nimport { Rect } from \"../../math/Rect\";\n\nexport const clipLine = (\n  rect: Rect,\n  ptInside: Point,\n  ptOutside: Point\n): Point | undefined => {\n  const { inside, b } = rect.clip(ptInside, ptOutside);\n  return inside ? b : ptInside;\n};\n","import { Double } from \"../../types\";\nimport { Point } from \"../../math/Point\";\nimport { ChemNode } from \"../../core/ChemNode\";\nimport { ResultBuildNode } from \"../buildNode\";\nimport { clipLine } from \"./clipLine\";\nimport { isNodeHidden } from \"../../core/isNodeHidden\";\n\nexport const clipLineByNode = (\n  node: ChemNode,\n  nodeRes: ResultBuildNode,\n  a: Point | undefined,\n  b: Point | undefined,\n  margin: Double\n): Point | undefined => {\n  if (!a || !b) return undefined;\n  const result = a.clone();\n  // if (node.autoMode) return result;\n  // Нет смысла отсекать пустой узел - автоматический или состоящий из пустого коммента или абстрактного элемента\n  if (isNodeHidden(node)) return result;\n  const { nodeFrame, rcNodeCore } = nodeRes;\n  // Нужно перевести координаты отсекающих фигур в координаты агента...\n  const rect = rcNodeCore.clone();\n  rect.grow(margin);\n  rect.move(nodeFrame.org);\n\n  return clipLine(rect, a, b);\n};\n","import { StructAnalyzer } from \"../../core/StructAnalyzer\";\nimport { BondAlign, ChemBond } from \"../../core/ChemBond\";\nimport { ChemImgProps } from \"../../drawSys/ChemImgProps\";\nimport { FigFrame } from \"../../drawSys/figures/FigFrame\";\nimport { Point } from \"../../math/Point\";\nimport { getBondStyleWidth } from \"./getBondStyleWidth\";\nimport { singleLine } from \"./singleLine\";\n\nconst getAlignSign = (\n  bond: ChemBond,\n  stA: StructAnalyzer,\n  align?: BondAlign\n): 0 | 1 | -1 => {\n  if (!align) {\n    return stA.calcBondSign(bond);\n  }\n  switch (align) {\n    case \"l\":\n      return -1;\n    case \"r\":\n      return 1;\n    default:\n      return 0;\n  }\n};\n\n// Нужно ли делать отступ для внутренней линии, чтобы она была короче внешней\nconst isPadding = (bond: ChemBond, side: number): boolean | undefined => {\n  const node = bond.nodes[side];\n  // Узел должен быть автоматическим и иметь более одной связи\n  return node && node.autoMode && node.bonds.size > 1;\n};\n\ninterface ParamsDoubleBond {\n  bond: ChemBond;\n  frame: FigFrame;\n  imgProps: ChemImgProps;\n  p0: Point;\n  p1: Point;\n  styles: string[];\n  color: string;\n  align?: BondAlign;\n  stA: StructAnalyzer;\n}\n\nexport const doubleBond = ({\n  bond,\n  frame,\n  imgProps,\n  p0,\n  p1,\n  styles,\n  color,\n  align,\n  stA,\n}: ParamsDoubleBond) => {\n  const dir = p1.minus(p0);\n  const d1 = dir.normal();\n  const styleL = styles[0];\n  const styleR = styles[1];\n  const left1 = d1.transpon(true);\n  const right1 = d1.transpon();\n  const wL = getBondStyleWidth(imgProps, styleL);\n  const wR = getBondStyleWidth(imgProps, styleR);\n  let aL;\n  let bL;\n  let aR;\n  let bR: Point;\n  if (align === \"x\") {\n    const { lineSpace2x } = imgProps;\n    const dL = left1.times((wL + lineSpace2x) / 2);\n    const dR = right1.times((wR + lineSpace2x) / 2);\n    aL = p0.plus(dL);\n    aR = p0.plus(dR);\n    bL = p1.plus(dR); // cross left to right\n    bR = p1.plus(dL);\n  } else {\n    const aSign = getAlignSign(bond, stA, align);\n    const { lineSpace2 } = imgProps;\n    let dL;\n    let dR: Point;\n    if (aSign < 0) {\n      dL = left1.times((wL + wR) / 2 + lineSpace2);\n      dR = Point.zero;\n    } else if (aSign > 0) {\n      dL = Point.zero;\n      dR = right1.times((wL + wR) / 2 + lineSpace2);\n    } else {\n      dL = left1.times((wL + lineSpace2) / 2);\n      dR = right1.times((wR + lineSpace2) / 2);\n    }\n    aL = p0.plus(dL);\n    aR = p0.plus(dR);\n    bL = p1.plus(dL);\n    bR = p1.plus(dR);\n    if (isPadding(bond, 0)) {\n      if (aSign < 0) aL.iadd(d1.times(lineSpace2));\n      else if (aSign > 0) aR.iadd(d1.times(lineSpace2));\n    }\n    if (isPadding(bond, 1)) {\n      if (aSign < 0) bL.isub(d1.times(lineSpace2));\n      else if (aSign > 0) bR.isub(d1.times(lineSpace2));\n    }\n  }\n  singleLine(bond, frame, imgProps, aL, bL, styleL, color);\n  singleLine(bond, frame, imgProps, aR, bR, styleR, color);\n};\n","import { Point } from \"../../math/Point\";\nimport { ChemImgProps } from \"../../drawSys/ChemImgProps\";\nimport { FigFrame } from \"../../drawSys/figures/FigFrame\";\nimport { ResultBuildNode } from \"../buildNode\";\nimport { clipLine } from \"./clipLine\";\nimport { PathSeg } from \"../../drawSys/path\";\nimport { FigPath } from \"../../drawSys/figures/FigPath\";\nimport { getBondColor } from \"./getBondColor\";\nimport { ChemBond } from \"../../core/ChemBond\";\nimport { drawBondArrow } from \"./drawBondArrow\";\nimport { isNodeHidden } from \"../../core/isNodeHidden\";\n\ninterface ParamsBezierBond {\n  bond: ChemBond;\n  frame: FigFrame;\n  props: ChemImgProps;\n  middlePoints: Point[];\n  res0: ResultBuildNode;\n  res1: ResultBuildNode;\n}\n\nexport const drawBezierBond = ({\n  bond,\n  frame,\n  props,\n  middlePoints,\n  res0,\n  res1,\n}: ParamsBezierBond): void => {\n  const L = Math.min(middlePoints.length - 1, 2);\n  if (L <= 0) return;\n  const { line, lineWidth, nodeMargin } = props;\n  // Подключение первого сегмента\n  const rect0 = res0.rcNodeCore.clone();\n  rect0.move(res0.nodeFrame.org);\n  if (bond.nodes[0] && !isNodeHidden(bond.nodes[0])) rect0.grow(nodeMargin);\n  const c0 = res0.center.plus(res0.nodeFrame.org);\n  const rect1 = res1.rcNodeCore.clone();\n  rect1.move(res1.nodeFrame.org);\n  if (bond.nodes[1] && !isNodeHidden(bond.nodes[1])) rect1.grow(nodeMargin);\n  const c1 = res1.center.plus(res1.nodeFrame.org);\n  let prev = c0;\n  const wPoints = middlePoints.slice(0, L).map((vpt) => {\n    const wpt = vpt.times(line).plus(prev);\n    prev = wpt;\n    return wpt;\n  });\n  const p0 = clipLine(rect0, c0, wPoints[0]!);\n  if (!p0) return;\n  const p1 = clipLine(rect1, c1, wPoints[L - 1]!);\n  if (!p1) return;\n\n  const segs: PathSeg[] = [\n    { cmd: \"M\", pt: p0 },\n    L === 1\n      ? { cmd: \"Q\", cp: wPoints[0]!, pt: p1 }\n      : { cmd: \"C\", cp1: wPoints[0]!, cp2: wPoints[1]!, pt: p1 },\n  ];\n  const color = getBondColor(bond, props);\n  const fig = new FigPath(segs, { stroke: color, strokeWidth: lineWidth });\n  fig.update();\n  frame.addFigure(fig, true);\n  if (bond.arr0) {\n    drawBondArrow(frame, props, wPoints[0]!, p0, color);\n  }\n  if (bond.arr1) {\n    drawBondArrow(frame, props, wPoints[L - 1]!, p1, color);\n  }\n};\n","import { FigFrame } from \"../../drawSys/figures/FigFrame\";\nimport { ChemBond } from \"../../core/ChemBond\";\nimport { drawBondAB } from \"./drawBondAB\";\nimport { Point } from \"../../math/Point\";\nimport { clipLineByNode } from \"./clipLineByNode\";\nimport { ChemImgProps } from \"../../drawSys/ChemImgProps\";\nimport { getNodeInfo, NodeInfo } from \"../NodeInfo\";\nimport { drawBondPoly } from \"./drawBondPoly\";\nimport { StructAnalyzer } from \"../../core/StructAnalyzer\";\nimport { drawBezierBond } from \"./drawBezierBond\";\n\ninterface ParamsDrawBond {\n  bond: ChemBond;\n  frame: FigFrame;\n  props: ChemImgProps;\n  nodesInfo: NodeInfo[];\n  stA: StructAnalyzer;\n}\n\nexport const drawBond = ({\n  bond,\n  props,\n  frame,\n  nodesInfo,\n  stA,\n}: ParamsDrawBond) => {\n  if (!bond.isVisible()) return;\n  const { nodeMargin } = props;\n  if (bond.nodes.length !== 2) {\n    drawBondPoly(bond, frame, props, nodesInfo);\n    return;\n  }\n  // bond between 2 nodes\n  const [node0, node1] = bond.nodes;\n  if (!node0 || !node1) return;\n  const { res: res0 } = getNodeInfo(node0, nodesInfo);\n  const { res: res1 } = getNodeInfo(node1, nodesInfo);\n  let bondA: Point | undefined = res0.nodeFrame.org.plus(res0.center);\n  const { middlePoints } = bond;\n  if (middlePoints && middlePoints.length > 0) {\n    drawBezierBond({ bond, frame, props, middlePoints, res0, res1 });\n    return;\n  }\n  let bondB: Point | undefined = res1.nodeFrame.org.plus(res1.center);\n  bondA = clipLineByNode(node0, res0, bondA, bondB, nodeMargin);\n  if (!bondA) return;\n  bondB = clipLineByNode(node1, res1, bondB, bondA, nodeMargin);\n  if (!bondB) return;\n  drawBondAB({\n    bond,\n    bondA,\n    bondB,\n    frame,\n    imgProps: props,\n    stA,\n  });\n};\n","import { ChemImgProps } from \"../../drawSys/ChemImgProps\";\nimport { FigFrame } from \"../../drawSys/figures/FigFrame\";\nimport { ChemBond } from \"../../core/ChemBond\";\nimport { Point } from \"../../math/Point\";\nimport { getBondColor } from \"./getBondColor\";\nimport { tripleBond } from \"./tripleBond\";\nimport { singleLine } from \"./singleLine\";\nimport { doubleBond } from \"./doubleBond\";\nimport { Figure } from \"../../drawSys/figures/Figure\";\nimport { wedgeBond } from \"./wedgeBond\";\nimport { drawBondArrow } from \"./drawBondArrow\";\nimport { StructAnalyzer } from \"../../core/StructAnalyzer\";\n\ninterface ParamsDrawBondAB {\n  bond: ChemBond;\n  bondA: Point;\n  bondB: Point;\n  imgProps: ChemImgProps;\n  frame: FigFrame;\n  stA: StructAnalyzer;\n}\n\nexport const drawBondAB = ({\n  bond,\n  bondA,\n  bondB,\n  imgProps,\n  frame,\n  stA,\n}: ParamsDrawBondAB) => {\n  const { n, style, w0, w1 } = bond;\n  const color = getBondColor(bond, imgProps);\n  let fig: Figure | undefined;\n  if (!w0 && w1 === 1) {\n    fig = wedgeBond(bondA, bondB, imgProps, color, false);\n  } else if (w0 === 1 && !w1) {\n    fig = wedgeBond(bondB, bondA, imgProps, color, false);\n  } else if (!w0 && w1 === -1) {\n    fig = wedgeBond(bondA, bondB, imgProps, color, true);\n  } else if (w0 === -1 && !w1) {\n    fig = wedgeBond(bondB, bondA, imgProps, color, true);\n  }\n  if (fig) {\n    fig.update();\n    frame.addFigure(fig);\n    return;\n  }\n  const stList: string[] = style ? Array.from(style) : new Array(n).fill(\"|\");\n  stList.reverse();\n  if (stList.length === 1 && bond.w0 === 1 && bond.w1 === 1) {\n    stList[0] = \"I\";\n  }\n  switch (stList.length) {\n    case 1:\n      singleLine(bond, frame, imgProps, bondA, bondB, stList[0], color);\n      if (bond.arr1) drawBondArrow(frame, imgProps, bondA, bondB, color);\n      if (bond.arr0) drawBondArrow(frame, imgProps, bondB, bondA, color);\n      break;\n    case 2:\n      doubleBond({\n        bond,\n        frame,\n        imgProps,\n        p0: bondA,\n        p1: bondB,\n        styles: stList,\n        color,\n        align: bond.align,\n        stA,\n      });\n      break;\n    case 3:\n      tripleBond(bond, frame, imgProps, bondA, bondB, stList, color);\n      break;\n    default:\n      break;\n  }\n};\n","import { Point } from \"../../math/Point\";\nimport { PathSeg } from \"../../drawSys/path\";\nimport { ChemImgProps } from \"../../drawSys/ChemImgProps\";\nimport { FigFrame } from \"../../drawSys/figures/FigFrame\";\nimport { PathStyle } from \"../../drawSys/AbstractSurface\";\nimport { FigPath } from \"../../drawSys/figures/FigPath\";\n\nexport const drawBondArrow = (\n  frame: FigFrame,\n  imgProps: ChemImgProps,\n  a: Point,\n  b: Point,\n  color: string\n) => {\n  const { arrowL, arrowD, lineWidth } = imgProps;\n  const n = a.minus(b).normal();\n  const c = b.plus(n.times(arrowL));\n  const cL = c.plus(n.transpon(true).times(arrowD));\n  const cR = c.plus(n.transpon().times(arrowD));\n  const segs: PathSeg[] = [\n    { cmd: \"M\", pt: cR },\n    { cmd: \"L\", pt: b },\n    { cmd: \"L\", pt: cL },\n  ];\n  const style: PathStyle = {\n    stroke: color,\n    strokeWidth: lineWidth,\n  };\n  const fig = new FigPath(segs, style);\n  fig.update();\n  frame.addFigure(fig, true);\n};\n","import { Point } from \"../../math/Point\";\nimport { ChemBond } from \"../../core/ChemBond\";\nimport { ChemImgProps } from \"../../drawSys/ChemImgProps\";\nimport { FigEllipse } from \"../../drawSys/figures/FigEllipse\";\nimport { FigFrame } from \"../../drawSys/figures/FigFrame\";\nimport { getNodeCenterPos, getNodeInfo, NodeInfo } from \"../NodeInfo\";\nimport { getBondColor } from \"./getBondColor\";\nimport { PathStyle } from \"../../drawSys/AbstractSurface\";\nimport { FigBSpline } from \"../../drawSys/figures/FigBSpline\";\n\nconst calcCenter = (wPoints: Point[]): Point =>\n  wPoints\n    .reduce((sum, wpt) => sum.iadd(wpt), new Point())\n    .scale(1 / wPoints.length);\n\nexport const drawBondPoly = (\n  bond: ChemBond,\n  frame: FigFrame,\n  imgProps: ChemImgProps,\n  nodesInfo: NodeInfo[]\n): void => {\n  const color = getBondColor(bond, imgProps);\n  const { lineWidth, dash } = imgProps;\n  const { nodes } = bond;\n  const wPoints = nodes\n    .filter((n) => !!n)\n    .map((n) => getNodeCenterPos(getNodeInfo(n!, nodesInfo)));\n  if (wPoints.length < 2) return;\n  const center = calcCenter(wPoints);\n  const style: PathStyle = { stroke: color, strokeWidth: lineWidth };\n  if (bond.ext === \"o\") {\n    const p0 = wPoints[0]!;\n    const p1 = wPoints[1]!;\n    const v = p0.plus(p1).times(0.5);\n    const r = center.minus(v).length() * 0.7;\n    const fig = new FigEllipse(center, new Point(r, r), style);\n    frame.addFigure(fig);\n  } else if (bond.ext === \"s\") {\n    //= ==== Связь, объединяющая несколько узлов при помощи Би-сплайна\n    let i = 0;\n    let n = wPoints.length;\n    if (!bond.isCycle) {\n      // не циклический вариант\n      // Линия выходит из концов и проходит на некотором расстоянии от остальных точек, смещаясь к центру\n      i++;\n      n--;\n    }\n    for (; i < n; i++) {\n      const p = wPoints[i]!;\n      const d = center.minus(p);\n      p.iadd(d.times(0.2));\n    }\n    // const segs: PathSeg[] = wPoints.map((pt, i) => ({cmd: i>0 ? \"L\":\"M\", pt}))\n    // if (bond.isCycle) segs.push({cmd:\"Z\"});\n    // const fig = new FigPath(segs, style);\n    const bPoints = FigBSpline.extendsPoints(wPoints, bond.isCycle);\n    if (bPoints) {\n      const fig = new FigBSpline(bPoints, style, dash, bond.style === \":\");\n      frame.addFigure(fig);\n    }\n  }\n};\n","import { ChemImgProps } from \"../../drawSys/ChemImgProps\";\nimport { ChemBond } from \"../../core/ChemBond\";\n\nexport const getBondColor = (bond: ChemBond, imgProps: ChemImgProps): string =>\n  bond.color ?? imgProps.stdStyle.style.fill;\n","import { ChemImgProps } from \"../../drawSys/ChemImgProps\";\n\nexport const getBondStyleWidth = (\n  imgProps: ChemImgProps,\n  styleDef?: string\n): number => (styleDef === \"I\" ? imgProps.thickWidth : imgProps.lineWidth);\n","import { PathStyle } from \"../../drawSys/AbstractSurface\";\nimport { ChemImgProps } from \"../../drawSys/ChemImgProps\";\nimport { Point } from \"../../math/Point\";\nimport { FigFrame } from \"../../drawSys/figures/FigFrame\";\nimport { PathSeg } from \"../../drawSys/path\";\nimport { FigPath } from \"../../drawSys/figures/FigPath\";\nimport { getBondStyleWidth } from \"./getBondStyleWidth\";\nimport { Figure } from \"../../drawSys/figures/Figure\";\nimport { ChemBond } from \"../../core/ChemBond\";\nimport { FigHashTrapezoid } from \"../../drawSys/figures/FigHashTrapezoid\";\n\nexport const singleLine = (\n  bond: ChemBond,\n  frame: FigFrame,\n  imgProps: ChemImgProps,\n  a: Point,\n  b: Point,\n  style: string | undefined,\n  color: string\n) => {\n  const lnStyle: PathStyle = {\n    stroke: color,\n    strokeWidth: getBondStyleWidth(imgProps, style),\n    cap: \"round\",\n  };\n  let fig: Figure | undefined;\n  if (style === \"~\") {\n    fig = drawWaveLine(bond, a, b, imgProps, lnStyle);\n  } else if (style === \":\") {\n    fig = drawDashedLine(a, b, imgProps, lnStyle);\n  } else if (bond.w0 < 0 && bond.w0 === bond.w1) {\n    const { thickWidth, lineWidth, hatch } = imgProps;\n    fig = new FigHashTrapezoid(\n      a,\n      thickWidth,\n      b,\n      thickWidth,\n      color,\n      lineWidth,\n      hatch\n    );\n    fig.update();\n  }\n  if (!fig) {\n    const segs: PathSeg[] = [\n      { cmd: \"M\", rel: false, pt: a },\n      { cmd: \"L\", rel: false, pt: b },\n    ];\n    fig = new FigPath(segs, lnStyle);\n    fig.update();\n  }\n  frame.addFigure(fig);\n};\n\nconst drawWaveLine = (\n  bond: ChemBond,\n  p0: Point,\n  p1: Point,\n  imgProps: ChemImgProps,\n  style: PathStyle\n) => {\n  const srcSpace = !!bond.arr0;\n  const dstSpace = !!bond.arr1;\n  const { line, arrowL } = imgProps;\n  const ampl = line / 8;\n  const step = line / 6;\n  const arrLen = arrowL * 1.4; // Если стрелка впритык к изгибу, это выглядит плохо\n\n  const dir = p1.minus(p0);\n  let len = dir.length();\n  const d1 = dir.normal();\n  if (srcSpace) len -= arrLen;\n  if (dstSpace) len -= arrLen;\n  if (len < step) return undefined;\n  const wp0 = srcSpace ? p0.plus(d1.times(arrLen)) : p0;\n  const wp1 = dstSpace ? p1.minus(d1.times(arrLen)) : p1;\n\n  const nSegs = Math.floor((len + step / 2) / step);\n  const vAmp = d1.times(ampl);\n  const segDir = wp1.minus(wp0).times(1 / nSegs);\n  const segs: PathSeg[] = [{ cmd: \"M\", pt: p0 }];\n  if (srcSpace) segs.push({ cmd: \"L\", pt: wp0 });\n  let a: Point = wp0;\n  for (let k = 0; k < nSegs; k++) {\n    const pt = a.plus(segDir);\n    const cp1 = a.plus(\n      // eslint-disable-next-line no-bitwise\n      (k & 1) === 0 ? new Point(vAmp.y, -vAmp.x) : new Point(-vAmp.y, vAmp.x)\n    );\n    const cp2 = cp1.plus(segDir);\n    segs.push({ cmd: \"C\", cp1, cp2, pt });\n    a = pt;\n  }\n  if (dstSpace) segs.push({ cmd: \"L\", pt: p1 });\n  const fig = new FigPath(segs, style);\n  fig.update();\n  return fig;\n};\n\nconst drawDashedLine = (\n  p0: Point,\n  p1: Point,\n  imgProps: ChemImgProps,\n  style: PathStyle\n) => {\n  // Общее число отрезков: n. Число всегда нечётное.\n  const dir = p1.minus(p0);\n  const len = dir.length();\n  const { dash } = imgProps;\n  if (len < dash * 2) {\n    // Отрезок слишком короткий, чтобы выводиться прерывистой линией\n    return undefined;\n  }\n  let n = Math.floor(len / dash);\n  // eslint-disable-next-line no-bitwise\n  if (!(n & 1)) n++;\n  const segLen = len / n;\n  const segs: PathSeg[] = [{ cmd: \"M\", pt: p0 }];\n  for (let i = 0; i < n; i++) {\n    const pt = dir.times(((i + 1) * segLen) / len).iadd(p0);\n    // eslint-disable-next-line no-bitwise\n    segs.push({ cmd: (i & 1) === 0 ? \"L\" : \"M\", pt });\n  }\n  const fig = new FigPath(segs, style);\n  fig.update();\n  return fig;\n};\n","import { ChemImgProps } from \"../../drawSys/ChemImgProps\";\nimport { Point } from \"../../math/Point\";\nimport { ChemBond } from \"../../core/ChemBond\";\n\nexport const softBondTemplate = (\n  bond: ChemBond,\n  imgProps: ChemImgProps,\n  src: Point\n) => {\n  const vDir = bond.dir ?? new Point(1, 0);\n  const sign = vDir.x < 0 ? -1 : 1;\n  // Если связь слишком короткая, то использовать близкое соединение без полей. Как будто два узла сливаются в один.\n  const isClose = Math.abs(vDir.x) < 0.1;\n  const dir = isClose\n    ? vDir\n    : new Point(vDir.x * imgProps.horizLine, vDir.y * imgProps.line);\n  const field = isClose ? Point.zero : new Point(sign * imgProps.nodeMargin, 0);\n  const bondA = src.plus(field);\n  const bondB = bondA.plus(dir);\n  const dst = bondB.plus(field);\n  return { src, dst, bondA, bondB, sign };\n};\n","import { Point } from \"../../math/Point\";\nimport { FigFrame } from \"../../drawSys/figures/FigFrame\";\nimport { ChemImgProps } from \"../../drawSys/ChemImgProps\";\nimport { getBondStyleWidth } from \"./getBondStyleWidth\";\nimport { singleLine } from \"./singleLine\";\nimport { ChemBond } from \"../../core/ChemBond\";\n\nexport const tripleBond = (\n  bond: ChemBond,\n  frame: FigFrame,\n  imgProps: ChemImgProps,\n  a: Point,\n  b: Point,\n  styles: string[],\n  color: string\n) => {\n  //   left = style#0\n  //   |\n  //   a********************>b\n  //   |\n  //   right = style#2\n  const dir = b.minus(a);\n  const d1 = dir.normal();\n  const { lineSpace3 } = imgProps;\n  const styleLeft = styles[0];\n  const styleCenter = styles[1];\n  const styleRight = styles[2];\n  const wL = getBondStyleWidth(imgProps, styleLeft);\n  const wC = getBondStyleWidth(imgProps, styleCenter);\n  const wR = getBondStyleWidth(imgProps, styleRight);\n  const left1 = d1.transpon(true).times(lineSpace3 + (wL + wC) / 2);\n  const right1 = d1.transpon().times(lineSpace3 + (wR + wC) / 2);\n  singleLine(\n    bond,\n    frame,\n    imgProps,\n    a.plus(left1),\n    b.plus(left1),\n    styleLeft,\n    color\n  );\n  singleLine(bond, frame, imgProps, a, b, styleCenter, color);\n  singleLine(\n    bond,\n    frame,\n    imgProps,\n    a.plus(right1),\n    b.plus(right1),\n    styleRight,\n    color\n  );\n};\n","import { FigHashTrapezoid } from \"../../drawSys/figures/FigHashTrapezoid\";\nimport { ChemImgProps } from \"../../drawSys/ChemImgProps\";\nimport { FigPath } from \"../../drawSys/figures/FigPath\";\nimport { Figure } from \"../../drawSys/figures/Figure\";\nimport { PathSeg } from \"../../drawSys/path\";\nimport { Point } from \"../../math/Point\";\n\nexport const wedgeBond = (\n  src: Point,\n  dst: Point,\n  imgProps: ChemImgProps,\n  color: string,\n  hash: boolean\n): Figure => {\n  const { chiralWidth, lineWidth, hatch } = imgProps;\n  if (hash) {\n    return new FigHashTrapezoid(\n      src,\n      lineWidth,\n      dst,\n      chiralWidth,\n      color,\n      lineWidth,\n      hatch\n    );\n  }\n  const d1 = dst.minus(src).normal();\n  const left = d1.transpon(true).times(chiralWidth / 2);\n  const right = d1.transpon().times(chiralWidth / 2);\n  const b = dst.plus(left);\n  const c = dst.plus(right);\n  const left0 = d1.transpon(true).times(lineWidth / 2);\n  const right0 = d1.transpon().times(lineWidth / 2);\n  const segs: PathSeg[] = [\n    { cmd: \"M\", pt: src.plus(left0) },\n    { cmd: \"L\", pt: b },\n    { cmd: \"L\", pt: c },\n    { cmd: \"L\", pt: src.plus(right0) },\n    { cmd: \"Z\" },\n  ];\n  return new FigPath(segs, {\n    fill: color,\n    cap: \"round\",\n    strokeWidth: lineWidth,\n  });\n};\n","import { PAgentCtx } from \"./PAgentCtx\";\n\nexport class AgentCmd {\n  srcCmd?: AgentCmd;\n\n  dstCmd?: AgentCmd;\n\n  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars\n  canPush(ctx: PAgentCtx): boolean {\n    return false;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars, class-methods-use-this\n  postExec(ctx: PAgentCtx): void {}\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars, class-methods-use-this\n  onPrevious(cmd: AgentCmd, ctx: PAgentCtx): void {}\n}\n","import { ChemBracketEnd } from \"../../core/ChemBracket\";\nimport { AgentCmd } from \"./AgentCmd\";\nimport { AgentCmdBrOpen } from \"./AgentCmdBrOpen\";\nimport { PAgentCtx } from \"./PAgentCtx\";\nimport { unwind } from \"./unwind\";\nimport { Figure } from \"../../drawSys/figures/Figure\";\nimport { processBrackets } from \"./brackets/processBrackets\";\n\nexport class AgentCmdBrClose extends AgentCmd {\n  figure?: Figure;\n\n  isRealText?: boolean;\n\n  constructor(public readonly end: ChemBracketEnd) {\n    super();\n  }\n\n  override onPrevious(cmd: AgentCmd): void {\n    // )]\n    if (cmd instanceof AgentCmdBrClose) {\n      this.srcCmd = cmd;\n    }\n  }\n\n  override canPush(ctx: PAgentCtx): boolean {\n    let isCanUnwindNext = true;\n    unwind(ctx, (cmd) => {\n      if (isCanUnwindNext && cmd instanceof AgentCmdBrOpen) {\n        processBrackets(ctx, cmd, this);\n        isCanUnwindNext = false;\n        return true;\n      }\n      return isCanUnwindNext;\n    });\n    return false;\n  }\n}\n","import { Figure } from \"../../drawSys/figures/Figure\";\nimport { ChemBracketBegin } from \"../../core/ChemBracket\";\nimport { AgentCmd } from \"./AgentCmd\";\nimport { AgentCmdBrClose } from \"./AgentCmdBrClose\";\nimport { AgentCmdBridge } from \"./AgentCmdBridge\";\nimport { ifDef } from \"../../utils/ifDef\";\nimport { PAgentCtx } from \"./PAgentCtx\";\nimport { ChemNode } from \"../../core/ChemNode\";\nimport { AgentCmdNode } from \"./AgentCmdNode\";\n\nexport class AgentCmdBrOpen extends AgentCmd {\n  isBridge: boolean = false;\n\n  prevBracket?: AgentCmdBrClose;\n\n  prevText?: boolean;\n\n  figure?: Figure;\n\n  constructor(public readonly begin: ChemBracketBegin) {\n    super();\n  }\n\n  checkRtl(ctx: PAgentCtx, rtlNode?: ChemNode) {\n    ifDef(rtlNode, (it) => {\n      ctx.rtlNodes.add(it.index);\n      ifDef(this.begin?.end?.nodes[0], (endNode) =>\n        ctx.rtlNodes.add(endNode.index)\n      );\n    });\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  override canPush(ctx: PAgentCtx) {\n    this.checkRtl(\n      ctx,\n      ifDef(this.begin.bond, (bond) =>\n        ifDef(bond.dir, (dir) => (dir.x < 0 ? bond.nodes[1] : undefined))\n      )\n    );\n    return true;\n  }\n\n  override onPrevious(cmd: AgentCmd, ctx: PAgentCtx): void {\n    // Если перед началом скобки стоит мост или любая скобка,\n    // То предыдущая команда должна на выходе стыковаться с текущей на входе\n    // -(, [(, ](\n    if (cmd instanceof AgentCmdBridge || cmd instanceof AgentCmdBrOpen) {\n      // eslint-disable-next-line no-param-reassign\n      cmd.dstCmd = this;\n      this.srcCmd = cmd;\n    } else if (cmd instanceof AgentCmdBrClose) {\n      // eslint-disable-next-line prefer-destructuring\n      this.begin.nodes[0] = cmd.end.nodes[0];\n\n      ifDef(this.begin.nodes[0], (beginNode) => {\n        if (ctx.rtlNodes.has(beginNode.index)) {\n          this.checkRtl(ctx, beginNode);\n        }\n      });\n      this.isBridge = true;\n      this.prevBracket = cmd;\n    } else {\n      if (cmd instanceof AgentCmdNode) {\n        this.prevText = true;\n        // Если у узла одна связь, то проверить направление\n        const { node } = cmd;\n        if (node.bonds.size === 1) {\n          const nodeBond = Array.from(node.bonds)[0]!;\n          ifDef(nodeBond.dir, (dir) => {\n            if (dir.x < 0) this.checkRtl(ctx, node);\n          });\n        }\n      }\n      const [n1, n2] = this.begin.nodes;\n      if (n1?.subChain !== n2?.subChain) {\n        this.isBridge = true;\n      }\n    }\n  }\n}\n","import { AgentCmd } from \"./AgentCmd\";\nimport { AgentCmdBrClose } from \"./AgentCmdBrClose\";\nimport { PAgentCtx } from \"./PAgentCtx\";\nimport { unwind } from \"./unwind\";\n\nexport class AgentCmdBridge extends AgentCmd {\n  override onPrevious(cmd: AgentCmd): void {\n    if (cmd instanceof AgentCmdBrClose) {\n      // ]-\n      this.srcCmd = cmd;\n    }\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  override canPush(ctx: PAgentCtx): boolean {\n    unwind(ctx, (cmd: AgentCmd) => cmd instanceof AgentCmdBridge);\n    return true;\n  }\n}\n","import { ChemMul } from \"../../core/ChemMul\";\nimport { PAgentCtx } from \"./PAgentCtx\";\nimport { FigText } from \"../../drawSys/figures/FigText\";\nimport { AgentCmd } from \"./AgentCmd\";\nimport { AgentCmdBrOpen } from \"./AgentCmdBrOpen\";\nimport { getNodeInfo } from \"../NodeInfo\";\nimport { createCoeff } from \"./createCoeff\";\nimport { AgentCmdMulBridge } from \"./AgentCmdMulBridge\";\n\nexport const createAgentCmdMul = (mul: ChemMul): AgentCmd =>\n  mul.isFirst ? new AgentCmdMul(mul) : new AgentCmdMulBridge(mul);\n\nexport class AgentCmdMul extends AgentCmd {\n  figure?: FigText;\n\n  constructor(public readonly mul: ChemMul) {\n    super();\n  }\n\n  override onPrevious(cmd: AgentCmd): void {\n    // множитель внутри скобок. Н.р [2H2O] - это формула для теста, но не имеет практического смысла.\n    // Команды: brBegin, mulBegin, Node, mulEnd, brEnd\n    // Более правдоподобный случай ['n'FeO*'m'Fe2O3*'k'H2O]\n    // Ситуация редкая, но без скобок первый коэффициент применяется не к первому узлу, а ко всему выражению\n    // TODO: Возможно, анализ ситуации перенести в компилятор\n    if (cmd instanceof AgentCmdBrOpen) {\n      const { begin } = cmd;\n      if (!begin.nodes[1]) {\n        // eslint-disable-next-line prefer-destructuring\n        begin.nodes[1] = this.mul.nodes[1];\n      }\n      // eslint-disable-next-line no-param-reassign\n      cmd.dstCmd = this;\n    }\n  }\n\n  override canPush(ctx: PAgentCtx): boolean {\n    const dstNode = this.mul.nodes[1];\n    const { n } = this.mul;\n    if (dstNode && n.isSpecified()) {\n      const ni = getNodeInfo(dstNode, ctx.nodesInfo);\n      const { cluster } = ctx.clusters.findByNode(dstNode);\n      const { frame } = cluster;\n      const figK = createCoeff(this.mul, ctx.props);\n      figK.org.set(\n        frame.bounds.left - figK.bounds.width,\n        ni.res.rcNodeCore.bottom + ni.res.nodeFrame.org.y\n      );\n      frame.addFigure(figK, true);\n      this.figure = figK;\n    }\n    return false;\n  }\n\n  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-empty-function\n  override postExec(): void {}\n}\n","import { FigFrame } from \"../../drawSys/figures/FigFrame\";\nimport { ChemMul } from \"../../core/ChemMul\";\nimport { AgentCmdBridge } from \"./AgentCmdBridge\";\nimport { PAgentCtx } from \"./PAgentCtx\";\nimport { createCoeff } from \"./createCoeff\";\nimport { Point } from \"../../math/Point\";\nimport { AgentCmdBrClose } from \"./AgentCmdBrClose\";\nimport { AgentCmdBrOpen } from \"./AgentCmdBrOpen\";\nimport { drawMul } from \"./drawMul\";\n\nexport class AgentCmdMulBridge extends AgentCmdBridge {\n  constructor(public readonly mul: ChemMul) {\n    super();\n  }\n\n  override postExec(ctx: PAgentCtx): void {\n    const { mul } = this;\n    const { props } = ctx;\n    let [srcNode] = mul.nodes;\n    const dstNode = mul.nodes[1];\n    let isPrevBox = false;\n    if (!srcNode && this.srcCmd instanceof AgentCmdBrClose) {\n      // Такая ситуация возникает, если перед множителем закрывается скобка [K]*H\n      [srcNode] = this.srcCmd.end.nodes;\n      isPrevBox = true;\n    }\n    const isNextBox = this.dstCmd instanceof AgentCmdBrOpen;\n    if (!srcNode || !dstNode) return;\n    const bridgeFrame = new FigFrame();\n    const { font: mFont, style: mStyle } = props.getStyleColored(\n      \"multiplier\",\n      mul.color\n    );\n    const mFields = props.line * 0.2;\n    const figMul = drawMul(props, mFont, mStyle);\n    figMul.org.x += mFields;\n    bridgeFrame.addFigure(figMul, true);\n    if (mul.n.isSpecified()) {\n      const figK = createCoeff(mul, props);\n      figK.org.set(bridgeFrame.bounds.right + mFields, 0);\n      bridgeFrame.addFigure(figK, true);\n    } else {\n      bridgeFrame.bounds.B.x += mFields;\n    }\n    const { cluster, srcConn } = ctx.clusters.unite(\n      ctx,\n      { node: srcNode!, allBox: isPrevBox },\n      { node: dstNode!, allBox: isNextBox },\n      new Point(bridgeFrame.bounds.right, 0)\n    );\n    let y = srcConn.yBase;\n    if (y === undefined) {\n      // Такая ситуация возможна если перед множителем пустой узел.\n      // Например, гидрохлорид с нетекстовой левой частью: C-{}*5HCl\n      y = srcConn.yMiddle + mFont.getFontFace().ascent / 2;\n    }\n    bridgeFrame.org.set(srcConn.x, y);\n    cluster.frame.addFigure(bridgeFrame, true);\n  }\n}\n","import { Point } from \"../../math/Point\";\nimport { ChemNode } from \"../../core/ChemNode\";\nimport { AgentCmd } from \"./AgentCmd\";\nimport { AgentCmdBrClose } from \"./AgentCmdBrClose\";\nimport { PAgentCtx } from \"./PAgentCtx\";\nimport { getNodeInfo } from \"../NodeInfo\";\nimport { makeBridge } from \"./brackets/processBrackets\";\n\nexport class AgentCmdNode extends AgentCmd {\n  prevBracket?: AgentCmdBrClose;\n\n  constructor(public readonly node: ChemNode) {\n    super();\n  }\n\n  override canPush(ctx: PAgentCtx): boolean {\n    const { prevBracket } = this;\n    if (prevBracket) {\n      const br = prevBracket.end;\n      if (br) {\n        const n0 = br.nodes[0];\n        const step = new Point();\n        if (n0) {\n          const ni0 = getNodeInfo(n0, ctx.nodesInfo);\n          step.y = ni0.res.nodeFrame.org.y + ni0.res.center.y;\n        }\n        const isBothText = !!prevBracket.isRealText;\n        makeBridge(ctx, br, true, isBothText);\n      }\n    }\n    return false;\n  }\n\n  override onPrevious(cmd: AgentCmd): void {\n    if (cmd instanceof AgentCmdBrClose) {\n      this.prevBracket = cmd;\n    }\n  }\n}\n","import { ifDef } from \"../../utils/ifDef\";\nimport { ChemAgent } from \"../../core/ChemAgent\";\nimport { ChemBond } from \"../../core/ChemBond\";\nimport { Point } from \"../../math/Point\";\nimport { drawBondAB } from \"../bond/drawBondAB\";\nimport { softBondTemplate } from \"../bond/softBondTemplate\";\nimport { AgentCmdBridge } from \"./AgentCmdBridge\";\nimport { PAgentCtx } from \"./PAgentCtx\";\n\nexport class AgentCmdSoftBond extends AgentCmdBridge {\n  constructor(\n    public readonly bond: ChemBond,\n    public readonly agent: ChemAgent\n  ) {\n    super();\n  }\n\n  override postExec(ctx: PAgentCtx): void {\n    const {\n      bond,\n      agent: { stA },\n    } = this;\n    const imgProps = ctx.props;\n    const { src, dst, bondA, bondB } = softBondTemplate(\n      bond,\n      ctx.props,\n      Point.zero\n    );\n    const [srcNode, dstNode] = this.bond.nodes;\n    const step = dst.minus(src);\n    const { cluster, srcConn, dstConn, srcNodeInfo, dstNodeInfo } =\n      ctx.clusters.unite(\n        ctx,\n        { node: srcNode!, allBox: !!this.srcCmd },\n        { node: dstNode!, allBox: !!this.dstCmd },\n        step\n      );\n    if (bond.isVisible()) {\n      const y =\n        ifDef(srcConn.yBase, (srcBase) =>\n          ifDef(dstConn.yBase, () => {\n            if (!srcNodeInfo || !dstNodeInfo) return undefined;\n            const srcH = srcNodeInfo.res.rcNodeCore.height ?? 0;\n            const dstH = dstNodeInfo.res.rcNodeCore.height ?? 0;\n            return srcBase - Math.min(srcH / 2, dstH / 2);\n          })\n        ) ?? srcConn.yMiddle;\n      const connPt = new Point(srcConn.x, y);\n      bondA.iadd(connPt);\n      bondB.iadd(connPt);\n      drawBondAB({ bond, bondA, bondB, frame: cluster.frame, imgProps, stA });\n    }\n  }\n}\n","import { ChemNode } from \"../../core/ChemNode\";\nimport { getItemForced } from \"../../utils/getItemForced\";\nimport { FigFrame } from \"../../drawSys/figures/FigFrame\";\nimport { getNodeCenterPos, getNodeInfo, NodeInfo } from \"../NodeInfo\";\nimport { Point } from \"../../math/Point\";\nimport { PAgentCtx } from \"./PAgentCtx\";\nimport { Rect } from \"../../math/Rect\";\nimport { addAllSet } from \"../../utils/addAllSet\";\nimport { ifDef } from \"../../utils/ifDef\";\n\nexport interface Cluster {\n  frame: FigFrame;\n  nodes: Set<number>;\n  contentRect?: Rect;\n}\n\nexport const insertToCluster = (\n  cluster: Cluster,\n  node: ChemNode,\n  nodesInfo: NodeInfo[]\n) => {\n  const { frame, nodes } = cluster;\n  nodes.add(node.index);\n  const { res } = getNodeInfo(node, nodesInfo);\n  frame.addFigure(res.nodeFrame, true);\n};\n\ninterface ClusterConnection {\n  x: number;\n  yMiddle: number;\n  yBase?: number;\n}\n\nconst getClusterBoxConnection = (\n  cluster: Cluster,\n  isLeft: boolean\n): ClusterConnection => {\n  const { bounds } = cluster.frame;\n  return {\n    x: isLeft ? bounds.left : bounds.right,\n    yMiddle: (bounds.top + bounds.bottom) / 2,\n  };\n};\n\nexport const getClusterConnection = (\n  allBox: boolean,\n  cluster: Cluster,\n  nodeInfo: NodeInfo,\n  isLeft: boolean\n): ClusterConnection => {\n  const { res } = nodeInfo;\n  let rcNode: Rect | undefined;\n  let x: number | undefined;\n  let yBase: number | undefined;\n  let yMiddle;\n  const { nodeFrame, rcNodeCore } = res;\n  if (rcNodeCore.isEmpty()) {\n    yMiddle = nodeFrame.org.y;\n  } else {\n    rcNode = rcNodeCore.clone();\n    // Верхняя и нижняя границы идут от внутренней рамки\n    // Левая и правая границы идут от фрейма узла, т.к. индексы и заряды не входят в rcNodeCore\n    rcNode.A.x = nodeFrame.bounds.left;\n    rcNode.B.x = nodeFrame.bounds.right;\n    rcNode.move(nodeFrame.org);\n    yBase = rcNode.bottom;\n    yMiddle = yBase - rcNode.height / 2;\n    x = isLeft ? rcNode.left : rcNode.right;\n  }\n\n  if (allBox) {\n    const { bounds } = cluster.frame;\n    x = isLeft ? bounds.left : bounds.right;\n  } else if (x === undefined) {\n    x = getNodeCenterPos(nodeInfo).x;\n  }\n  if (isLeft) {\n    ifDef(nodeInfo.left, (it) => {\n      x = it.getRelativeBounds().left;\n    });\n  } else {\n    ifDef(nodeInfo.right, (it) => {\n      x = it.getRelativeBounds().right;\n    });\n  }\n  return { x, yMiddle, yBase };\n};\n\nconst isBothBaseline = (\n  srcConn: ClusterConnection,\n  dstConn: ClusterConnection\n) => srcConn.yBase !== undefined && dstConn.yBase !== undefined;\n\nexport const calcOffset = (\n  srcConn: ClusterConnection,\n  dstConn: ClusterConnection,\n  step: Point\n) =>\n  new Point(\n    srcConn.x - dstConn.x + step.x,\n    (isBothBaseline(srcConn, dstConn)\n      ? srcConn.yBase! - dstConn.yBase!\n      : srcConn.yMiddle - dstConn.yMiddle) + step.y\n  );\n\nexport const calcOffsetAbs = (c0: Cluster, c1: Cluster, step: Point): Point => {\n  const dx =\n    step.x >= 0\n      ? c0.frame.bounds.right - c1.frame.bounds.left\n      : c0.frame.bounds.left - c1.frame.bounds.right;\n  return new Point(dx + step.x, step.y);\n};\n\nexport const mergeClusters = (\n  srcCluster: Cluster,\n  dstCluster: Cluster,\n  offset: Point\n): void => {\n  addAllSet(srcCluster.nodes, dstCluster.nodes);\n  dstCluster.frame.figures.forEach((fig) => {\n    fig.org.iadd(offset);\n    srcCluster.frame.addFigure(fig, true);\n  });\n};\n\ninterface Connector {\n  node: ChemNode;\n  allBox: boolean;\n}\n\ninterface FindResult {\n  clusterIndex: number;\n  cluster: Cluster;\n}\n\nexport class Clusters {\n  clusters: Cluster[] = [];\n\n  init(nodes: ChemNode[], nodesInfo: NodeInfo[]) {\n    const dict: Record<number, Cluster> = {};\n    nodes.forEach((node) => {\n      const cluster = getItemForced(dict, node.subChain, () => ({\n        frame: new FigFrame(),\n        nodes: new Set<number>(),\n      }));\n      insertToCluster(cluster, node, nodesInfo);\n    });\n    this.clusters = Object.values(dict);\n  }\n\n  findByIndex(nodeIndex: number): FindResult {\n    const clusterIndex = this.clusters.findIndex((cl) =>\n      cl.nodes.has(nodeIndex)\n    );\n    if (clusterIndex < 0)\n      throw new Error(`Not found node with index ${nodeIndex}`);\n    const cluster = this.clusters[clusterIndex]!;\n    return { clusterIndex, cluster };\n  }\n\n  findByNode(node: ChemNode): FindResult {\n    return this.findByIndex(node.index);\n  }\n\n  unite(\n    ctx: PAgentCtx,\n    src: Connector,\n    dst: Connector,\n    step: Point,\n    bAbs?: boolean\n  ) {\n    const { cluster: srcCluster } = this.findByNode(src.node);\n    if (!dst.node) {\n      // Вообще такого быть не должно. Но если рисовать некорректно откомпилированную формулу, то бывает.\n      // Было бы неплохо придумать более удачный способ обработки некорректных ситуаций.\n      return {\n        cluster: srcCluster,\n        srcConn: { x: 0, yMiddle: 0 } as ClusterConnection,\n        dstConn: { x: 0, yMiddle: 0 } as ClusterConnection,\n        offset: Point.zero,\n      };\n    }\n    const srcNodeInfo = getNodeInfo(src.node, ctx.nodesInfo);\n    const { cluster: dstCluster, clusterIndex: dstPos } = this.findByNode(\n      dst.node\n    );\n    const dstNodeInfo = getNodeInfo(dst.node, ctx.nodesInfo);\n    const leftToRight = step.x >= 0;\n    let offset: Point;\n    const srcConn = getClusterConnection(\n      src.allBox,\n      srcCluster,\n      srcNodeInfo,\n      !leftToRight\n    );\n\n    const dstConn = getClusterConnection(\n      dst.allBox,\n      dstCluster,\n      dstNodeInfo,\n      leftToRight\n    );\n    if (bAbs) {\n      offset = calcOffsetAbs(srcCluster, dstCluster, step);\n    } else {\n      offset = calcOffset(srcConn, dstConn, step);\n    }\n    mergeClusters(srcCluster, dstCluster, offset);\n    this.clusters.splice(dstPos, 1);\n    return {\n      cluster: srcCluster,\n      srcConn,\n      dstConn,\n      offset,\n      srcNodeInfo,\n      dstNodeInfo,\n    };\n  }\n\n  uniteRest(ctx: PAgentCtx) {\n    const { clusters } = this;\n    while (clusters.length > 1) {\n      const c0 = clusters[0]!;\n      const c1 = clusters[1]!;\n      const offset = calcOffset(\n        getClusterBoxConnection(c0, false),\n        getClusterBoxConnection(c1, true),\n        new Point(ctx.props.horizLine, 0)\n      );\n      mergeClusters(c0, c1, offset);\n      clusters.splice(1, 1);\n    }\n  }\n}\n","import { ChemAgent } from \"../../core/ChemAgent\";\nimport { ChemImgProps } from \"../../drawSys/ChemImgProps\";\nimport { FigFrame } from \"../../drawSys/figures/FigFrame\";\nimport { AgentCmd } from \"./AgentCmd\";\nimport { Clusters } from \"./Clusters\";\nimport { NodeInfo } from \"../NodeInfo\";\nimport { ChemBackground } from \"../../core/ChemBackground\";\n\nexport class PAgentCtx {\n  readonly agentFrame: FigFrame;\n\n  readonly nodesInfo: NodeInfo[] = [];\n\n  readonly cmdStack: AgentCmd[] = [];\n\n  readonly clusters: Clusters = new Clusters();\n\n  readonly backs: ChemBackground[] = [];\n\n  readonly rtlNodes: Set<number> = new Set(); // Для определения направления стыковки без связей\n\n  constructor(\n    public readonly agent: ChemAgent,\n    public readonly props: ChemImgProps\n  ) {\n    this.agentFrame = new FigFrame();\n  }\n}\n","import { isLeftCoeff } from \"../../../types/CoeffPos\";\nimport { ifDef } from \"../../../utils/ifDef\";\nimport { Point } from \"../../../math/Point\";\nimport { Rect } from \"../../../math/Rect\";\nimport { CommonBracket, getBracketsContent } from \"../../../core/ChemBracket\";\nimport { ChemCharge } from \"../../../core/ChemCharge\";\nimport { ChemK } from \"../../../core/ChemK\";\nimport { ChemNode } from \"../../../core/ChemNode\";\nimport { ChemObj } from \"../../../core/ChemObj\";\nimport { isTextBracketsCached } from \"../../../core/isTextBrackets\";\nimport { PathStyle } from \"../../../drawSys/AbstractSurface\";\nimport { ChemImgProps } from \"../../../drawSys/ChemImgProps\";\nimport { FigFrame } from \"../../../drawSys/figures/FigFrame\";\nimport { FigText } from \"../../../drawSys/figures/FigText\";\nimport { Figure } from \"../../../drawSys/figures/Figure\";\nimport { drawRubberFigure } from \"../../../drawSys/figures/rubber/drawRubberFigure\";\nimport { getRubberBracket } from \"../../../drawSys/figures/rubber/getRubberBracket\";\nimport { getFontHeight } from \"../../../drawSys/utils/fontFaceProps\";\nimport { drawCharge } from \"../../drawCharge\";\nimport { drawTextNear } from \"../../drawTextNear\";\nimport { getTextInternalRect } from \"../../getTextInternalRect\";\nimport { getNodeCenterPos, getNodeInfo, NodeInfo } from \"../../NodeInfo\";\nimport { AgentCmdBrClose } from \"../AgentCmdBrClose\";\nimport { AgentCmdBrOpen } from \"../AgentCmdBrOpen\";\nimport { PAgentCtx } from \"../PAgentCtx\";\nimport { applyPadding } from \"../../applyPadding\";\nimport { AgentCmdMul } from \"../AgentCmdMul\";\n\ninterface ResBracket {\n  figure: Figure;\n  y: number;\n  rect: Rect;\n}\n\nconst bracketCoeffs = (\n  frame: FigFrame,\n  rect: Rect,\n  props: ChemImgProps,\n  color?: string,\n  n?: ChemK,\n  charge?: ChemCharge\n) => {\n  if (charge) {\n    drawCharge({\n      charge,\n      frame,\n      rect,\n      imgProps: props,\n      color,\n      styleId: \"bracketCharge\",\n      type: \"bracket\",\n    });\n  }\n  if (n && n.isSpecified()) {\n    drawTextNear({\n      frame,\n      rcCore: rect,\n      text: String(n),\n      imgProps: props,\n      style: props.getStyleColored(\"bracketCount\", color),\n      pos: n.pos ?? \"RB\",\n      type: \"bracket\",\n    });\n  }\n  frame.update();\n};\n\nconst rubberBracket = (\n  isOpen: boolean,\n  bracket: CommonBracket,\n  props: ChemImgProps,\n  contentRect: Rect,\n  n?: ChemK,\n  charge?: ChemCharge\n): ResBracket => {\n  const rubberFig = getRubberBracket(isOpen, bracket.text);\n  const desiredRect = new Rect(0, 0, props.bracketWidth, contentRect.height);\n  const style: PathStyle = { fill: bracket.color ?? props.stdStyle.style.fill };\n  const frame = new FigFrame();\n  frame.addFigure(drawRubberFigure(rubberFig, desiredRect, style, props), true);\n  const rect = frame.bounds.clone();\n  bracketCoeffs(frame, rect, props, bracket.color, n, charge);\n  return {\n    figure: frame,\n    y: contentRect.top,\n    rect,\n  };\n};\n\nconst textBracket = (\n  bracket: CommonBracket,\n  props: ChemImgProps,\n  contentRect: Rect,\n  k?: ChemK,\n  charge?: ChemCharge\n): ResBracket => {\n  const style = props.getStyleColored(\"bracket\", bracket.color);\n  const frame = new FigFrame();\n  const figText = new FigText(bracket.text, style.font, style.style);\n  frame.addFigure(figText, true);\n  const { top } = frame.bounds;\n  const rect = getTextInternalRect(figText);\n  bracketCoeffs(frame, rect, props, bracket.color, k, charge);\n  return {\n    figure: frame,\n    y: contentRect.top - top,\n    rect,\n  };\n};\n\ninterface ParamsDrawBracket {\n  bracket: CommonBracket;\n  props: ChemImgProps;\n  isText: boolean;\n  isOpen: boolean;\n  contentRect: Rect;\n  nodeInfo: NodeInfo;\n  n?: ChemK;\n  charge?: ChemCharge;\n}\n\nconst drawBracket = ({\n  bracket,\n  contentRect,\n  isOpen,\n  isText,\n  props,\n  nodeInfo,\n  n,\n  charge,\n}: ParamsDrawBracket): Figure => {\n  const { figure, y, rect } = isText\n    ? textBracket(bracket, props, contentRect, n, charge)\n    : rubberBracket(isOpen, bracket, props, contentRect, n, charge);\n  const x = isOpen ? contentRect.left - rect.width : contentRect.right;\n  figure.org.set(x, y);\n\n  // Для присоединения текстовой скобки к текстовому узлу используем базовую линию\n  if (isText && !nodeInfo.node.autoMode) {\n    figure.org.y = nodeInfo.res.nodeFrame.org.y;\n  }\n\n  return figure;\n};\n\nexport const makeBridge = (\n  ctx: PAgentCtx,\n  bracket: CommonBracket,\n  isSrcBracket: boolean,\n  isBothText: boolean\n) => {\n  const [node0, node1] = bracket.nodes;\n  if (node0 && node1) {\n    const src = { node: node0, allBox: isSrcBracket };\n    const dst = { node: node1, allBox: true };\n    const sign = ctx.rtlNodes.has(node0.index) ? -1 : 1;\n    let dy = 0;\n    const flAbs = !isBothText;\n    if (flAbs) {\n      // Стыковка скобки со скобкой. Выравнивание пропорционально высоте содержимого кластеров\n      const { cluster: c0 } = ctx.clusters.findByNode(node0);\n      const { cluster: c1 } = ctx.clusters.findByNode(node1);\n      const b0 = c0.contentRect ?? c0.frame.bounds;\n      const b1 = c1.contentRect ?? c1.frame.bounds;\n      dy = b0.top - b1.top + (b0.height - b1.height) / 2;\n    }\n    ctx.clusters.unite(\n      ctx,\n      src,\n      dst,\n      new Point(sign * ctx.props.bracketSpace, dy),\n      flAbs\n    );\n  }\n};\n\nconst calcBracketRect = (\n  content: ChemObj[],\n  nodesInfo: NodeInfo[]\n): Rect | undefined =>\n  content.reduce((rect, cmd) => {\n    if (cmd instanceof ChemNode) {\n      const nodeInfo = getNodeInfo(cmd, nodesInfo);\n      const rcRel: Rect = nodeInfo.res.nodeFrame.getRelativeBounds();\n      if (!rect) return rcRel;\n      rect.unite(rcRel);\n      return rect;\n    }\n    return rect;\n  }, undefined as Rect | undefined);\n\nexport const processBrackets = (\n  ctx: PAgentCtx,\n  cmdOpen: AgentCmdBrOpen,\n  cmdClose: AgentCmdBrClose\n) => {\n  const { begin } = cmdOpen;\n  const { end } = cmdClose;\n  const { nodesInfo, agent, clusters, props } = ctx;\n  const { useTextBrackets, line, lineWidth } = props;\n  const beginNode = begin.nodes[1];\n  const endNode = end.nodeIn;\n  if (!beginNode || !endNode) return;\n  const { cluster } = clusters.findByNode(beginNode);\n  const beginNi = getNodeInfo(beginNode, nodesInfo);\n  const endNi = getNodeInfo(endNode, nodesInfo);\n  const isText0: boolean = useTextBrackets\n    ? isTextBracketsCached(begin, agent.commands)\n    : false;\n  const content = getBracketsContent(begin, agent.commands);\n  let contentRect0 = calcBracketRect(content, nodesInfo);\n  if (\n    (!contentRect0 || contentRect0.isEmpty()) &&\n    content.length === 1 &&\n    content[0] instanceof ChemNode\n  ) {\n    // Пустые скобки при наличии автоузла внутри. Example: /()'n'\\\n    const { font } = props.getStyle(\"atom\");\n    const ff = font.getFontFace();\n    const h = getFontHeight(ff) / 2;\n    const p = getNodeCenterPos(getNodeInfo(content[0], nodesInfo));\n    contentRect0 = new Rect(\n      new Point(p.x - lineWidth, p.y - h),\n      new Point(p.x + lineWidth, p.y + h)\n    );\n  }\n  const contentRect1 = contentRect0;\n  if (!contentRect1) return;\n\n  const contentRect =\n    ifDef(begin.padding, (p) => applyPadding(contentRect1, p, line)) ??\n    contentRect1;\n  const isText = isText0 && contentRect.height === contentRect1.height;\n  // eslint-disable-next-line no-param-reassign\n  cmdClose.isRealText = isText;\n\n  const xPad = isText ? 0 : lineWidth;\n  if (\n    cmdOpen.dstCmd instanceof AgentCmdBrOpen ||\n    cmdOpen.dstCmd instanceof AgentCmdMul\n  ) {\n    if (cmdOpen.dstCmd.figure) {\n      const rc = cmdOpen.dstCmd.figure.getRelativeBounds();\n      contentRect.updatePoint(new Point(rc.left - xPad, rc.center.y));\n    }\n  }\n  if (cmdOpen.srcCmd instanceof AgentCmdBrClose) {\n    if (cmdOpen.srcCmd.figure) {\n      const rc = cmdOpen.srcCmd.figure.getRelativeBounds();\n      contentRect.updatePoint(new Point(rc.left, rc.center.y));\n    }\n  }\n  if (cmdClose.srcCmd instanceof AgentCmdBrClose) {\n    if (cmdClose.srcCmd.figure) {\n      const rc = cmdClose.srcCmd.figure.getRelativeBounds();\n      contentRect.updatePoint(new Point(rc.right + xPad, rc.center.y));\n    }\n  }\n\n  // TODO: отладочный вывод рамки\n  // const fr = new FigRect(contentRect, {stroke: \"red\", strokeWidth: 0.5});\n  // cluster.frame.addFigure(fr);\n\n  const { charge, n } = end;\n  const ch = (open: boolean): ChemCharge | undefined =>\n    open === charge?.isLeft ? charge : undefined;\n  const coeff = (open: boolean): ChemK | undefined =>\n    open === isLeftCoeff(n.pos) ? n : undefined;\n  const figOpen = drawBracket({\n    isOpen: true,\n    bracket: begin,\n    isText,\n    props,\n    contentRect,\n    nodeInfo: beginNi,\n    n: coeff(true),\n    charge: ch(true),\n  });\n  const figClose = drawBracket({\n    isOpen: false,\n    bracket: end,\n    isText,\n    props,\n    contentRect,\n    nodeInfo: endNi,\n    n: coeff(false),\n    charge: ch(false),\n  });\n  cluster.frame.addFigure(figOpen, true);\n  cluster.frame.addFigure(figClose, true);\n\n  // Для вложенных скобок внешние переписывают внутренние.\n  beginNi.left = figOpen;\n  endNi.right = figClose;\n\n  // eslint-disable-next-line no-param-reassign\n  cmdOpen.figure = figOpen;\n  // eslint-disable-next-line no-param-reassign\n  cmdClose.figure = figClose;\n  cluster.contentRect = contentRect;\n\n  if (cmdOpen.isBridge) {\n    const isBothText =\n      isText && (!!cmdOpen?.prevBracket?.isRealText || !!cmdOpen.prevText);\n    makeBridge(ctx, cmdOpen.begin, !!cmdOpen.prevBracket, isBothText);\n  }\n};\n","/**\n * Алгоритм построения агента, использующий приоритет команд\n *\n */\n\nimport { ChemImgProps } from \"../../drawSys/ChemImgProps\";\nimport { ChemAgent } from \"../../core/ChemAgent\";\nimport { FigFrame } from \"../../drawSys/figures/FigFrame\";\nimport { PAgentCtx } from \"./PAgentCtx\";\nimport { prepareNodes } from \"./prepareNodes\";\nimport { processCommands } from \"./processCommands\";\nimport { drawAllBonds } from \"./drawAllBonds\";\nimport { Point } from \"../../math/Point\";\nimport { findAgentCenter } from \"./findAgentCenter\";\nimport { FigText } from \"../../drawSys/figures/FigText\";\nimport { getTextInternalRect } from \"../getTextInternalRect\";\nimport { drawBackground } from \"./drawBackground\";\n\nexport interface ResultBuildAgent {\n  agentFrame: FigFrame;\n  center: Point;\n  ctx: PAgentCtx;\n}\n\nexport const buildAgentPrior = (\n  agent: ChemAgent,\n  imgProps: ChemImgProps\n): ResultBuildAgent => {\n  const ctx = new PAgentCtx(agent, imgProps);\n  const { agentFrame } = ctx;\n\n  prepareNodes(ctx);\n  processCommands(ctx);\n  ctx.clusters.uniteRest(ctx);\n  drawAllBonds(ctx);\n\n  const cluster = ctx.clusters.clusters.shift();\n  if (cluster) {\n    cluster.frame.figures.forEach((fig) => agentFrame.addFigure(fig));\n    agentFrame.update();\n  }\n  drawBackground(ctx);\n  const center = findAgentCenter(ctx);\n\n  if (agent.n.isSpecified()) {\n    const kStyle = imgProps.getStyleColored(\"agentK\", agent.n.color);\n    const figK = new FigText(agent.n.toString(), kStyle.font, kStyle.style);\n    const irc = getTextInternalRect(figK);\n    figK.org.x =\n      agentFrame.bounds.left - figK.bounds.width - imgProps.agentKSpace;\n    figK.org.y = center.y - irc.center.y;\n    agentFrame.addFigure(figK, true);\n  }\n\n  return { agentFrame, ctx, center };\n};\n","import { ChemNode } from \"../../core/ChemNode\";\nimport { ChemBond } from \"../../core/ChemBond\";\nimport { ChemBracketBegin, ChemBracketEnd } from \"../../core/ChemBracket\";\nimport { ChemObj } from \"../../core/ChemObj\";\nimport { AgentCmd } from \"./AgentCmd\";\nimport { AgentCmdBrClose } from \"./AgentCmdBrClose\";\nimport { AgentCmdBrOpen } from \"./AgentCmdBrOpen\";\nimport { AgentCmdNode } from \"./AgentCmdNode\";\nimport { AgentCmdSoftBond } from \"./AgentCmdSoftBond\";\nimport { ChemMul, ChemMulEnd } from \"../../core/ChemMul\";\nimport { createAgentCmdMul } from \"./AgentCmdMul\";\nimport { ChemAgent } from \"../../core/ChemAgent\";\n\nexport const createAgentCmd = (\n  obj: ChemObj,\n  agent: ChemAgent\n): AgentCmd | undefined => {\n  if (obj instanceof ChemBond) {\n    if (obj.soft) return new AgentCmdSoftBond(obj, agent);\n  } else if (obj instanceof ChemBracketBegin) {\n    return new AgentCmdBrOpen(obj);\n  } else if (obj instanceof ChemBracketEnd) {\n    return new AgentCmdBrClose(obj);\n  } else if (obj instanceof ChemMul) {\n    return createAgentCmdMul(obj);\n  } else if (obj instanceof ChemNode) {\n    return new AgentCmdNode(obj);\n  } else if (obj instanceof ChemMulEnd) {\n    return undefined;\n  }\n  return new AgentCmd();\n};\n","import { ChemImgProps } from \"../../drawSys/ChemImgProps\";\nimport { ChemMul } from \"../../core/ChemMul\";\nimport { FigText } from \"../../drawSys/figures/FigText\";\n\nexport const createCoeff = (mul: ChemMul, props: ChemImgProps): FigText => {\n  const kStyle = props.getStyleColored(\"multiK\", mul.color);\n  return new FigText(String(mul.n), kStyle.font, kStyle.style);\n};\n","import { ChemBond } from \"../../core/ChemBond\";\nimport { drawBond } from \"../bond/drawBond\";\nimport { PAgentCtx } from \"./PAgentCtx\";\n\nexport const drawAllBonds = (ctx: PAgentCtx) => {\n  const { agent, props, agentFrame, nodesInfo } = ctx;\n  agent.commands.forEach((cmd) => {\n    if (cmd instanceof ChemBond && !cmd.soft) {\n      drawBond({\n        bond: cmd,\n        props,\n        frame: agentFrame,\n        nodesInfo,\n        stA: agent.stA,\n      });\n    }\n  });\n};\n","import { Point } from \"../../math/Point\";\nimport { Rect } from \"../../math/Rect\";\nimport { ChemNode } from \"../../core/ChemNode\";\nimport { Figure } from \"../../drawSys/figures/Figure\";\nimport { ParamsChemBackground } from \"../../core/ChemBackground\";\nimport { FigFrame } from \"../../drawSys/figures/FigFrame\";\nimport { PAgentCtx } from \"./PAgentCtx\";\nimport { getNodeInfo } from \"../NodeInfo\";\nimport { PathStyle } from \"../../drawSys/AbstractSurface\";\nimport { FigRect } from \"../../drawSys/figures/FigRect\";\nimport { FigEllipse } from \"../../drawSys/figures/FigEllipse\";\nimport { ifDef } from \"../../utils/ifDef\";\nimport { applyPadding } from \"../applyPadding\";\n\nexport const calcBgRect = (\n  ctx: PAgentCtx,\n  nodes: ChemNode[] = []\n): Rect | undefined =>\n  nodes.reduce((rc: Rect | undefined, node: ChemNode) => {\n    const ni = getNodeInfo(node, ctx.nodesInfo);\n    const rcNode = ni.res.nodeFrame.getRelativeBounds();\n    return rc ? rc.unite(rcNode) : rcNode;\n  }, undefined);\n\nconst createBgRect = (rc: Rect, style: PathStyle, radius?: Point) =>\n  new FigRect(rc, style, radius);\n\nconst createBgEllipse = (rc: Rect, style: PathStyle) => {\n  const p0 = rc.center;\n  const w = rc.width;\n  const h = rc.height;\n  // if (is0(w - h)) return createBgRound(rc, style);\n  const calcAB = (c: number, p: number) => {\n    const d = p * p + 4 * c * c;\n    const e = (-p + Math.sqrt(d)) / (2 * c);\n    const a = c / e;\n    const b = (c * Math.sqrt(1 - e * e)) / e;\n    return { a, b };\n  };\n  if (w > h) {\n    const { a, b } = calcAB(w / 2, h / 2);\n    return new FigEllipse(p0, new Point(a, b), style);\n  }\n  const { a, b } = calcAB(h / 2, w / 2);\n  return new FigEllipse(p0, new Point(b, a), style);\n};\n\nconst calcRadius = (\n  ctx: PAgentCtx,\n  rect: Rect,\n  srcNodes?: ChemNode[]\n): number => {\n  const nodes = srcNodes ?? ctx.agent.nodes;\n  const { center } = rect;\n  let maxSqr = 0;\n  nodes.forEach((node) => {\n    const ni = getNodeInfo(node, ctx.nodesInfo);\n    const rc = ni.res.nodeFrame.getRelativeBounds();\n    const cc = rc.center;\n    const p = new Point(\n      cc.x < center.x ? rc.left : rc.right,\n      cc.y < center.y ? rc.top : rc.bottom\n    );\n    maxSqr = Math.max(maxSqr, center.minus(p).lengthSqr());\n  });\n  return Math.sqrt(maxSqr);\n};\n\nexport const makeBackFigure = (\n  ctx: PAgentCtx,\n  params: ParamsChemBackground\n): Figure => {\n  const {\n    nodes,\n    isAll,\n    padding,\n    fill,\n    stroke,\n    strokeWidth,\n    shape,\n    borderRadius,\n  } = params;\n  const { agentFrame, props } = ctx;\n  // TODO: Использование agentFrame.bounds норм для rect.\n  // Но для round это обычно плохо, т.к углы часто пустые. А круги считают углы радиусом. Поэтому получается слишком широкий отступ.\n  // Было бы лучше перебрать все узлы и найти максимальное расстояние от центра\n  let rect: Rect | undefined = isAll\n    ? agentFrame.bounds.clone()\n    : calcBgRect(ctx, nodes);\n  if (!rect) {\n    // Выгоднее использовать заглушку, чем потом контролировать пригодность полученных объектов.\n    return new FigFrame();\n  }\n  const srcRect = rect.clone();\n  if (padding) {\n    rect = applyPadding(rect, padding, props.line);\n  }\n\n  const style: PathStyle = {};\n  if (fill) style.fill = fill;\n  if (stroke) style.stroke = stroke;\n  if (strokeWidth) style.strokeWidth = props.lineWidth * strokeWidth;\n\n  if (shape === \"round\") {\n    const r0 = calcRadius(ctx, rect, nodes);\n    const rPad = Math.min(\n      (rect.width - srcRect.width) / 2,\n      (rect.height - srcRect.height) / 2\n    );\n    const r = r0 + rPad;\n    return new FigEllipse(rect.center, new Point(r, r), style);\n  }\n  if (shape === \"ellipse\") return createBgEllipse(rect, style);\n  const radius = ifDef(\n    borderRadius,\n    (it) => new Point(it * props.line, it * props.line)\n  );\n  return createBgRect(rect, style, radius);\n};\n\nexport const drawBackground = (ctx: PAgentCtx) => {\n  const { backs } = ctx;\n  if (backs.length === 0) return;\n  const figs = backs.map((bg) => makeBackFigure(ctx, bg.params));\n  figs.forEach((fig, i) => ctx.agentFrame.insertFigure(i, fig, true));\n};\n","import { ChemImgProps } from \"../../drawSys/ChemImgProps\";\nimport { Figure } from \"../../drawSys/figures/Figure\";\nimport { FigText } from \"../../drawSys/figures/FigText\";\nimport { LocalFont, TextStyle } from \"../../drawSys/AbstractSurface\";\nimport { FigEllipse } from \"../../drawSys/figures/FigEllipse\";\nimport { Point } from \"../../math/Point\";\nimport { getFontHeight } from \"../../drawSys/utils/fontFaceProps\";\n\nexport const drawMul = (\n  props: ChemImgProps,\n  mFont: LocalFont,\n  mStyle: TextStyle\n): Figure => {\n  const { mulRadius } = props;\n  if (mulRadius) {\n    const ff = mFont.getFontFace();\n    const r = getFontHeight(ff) * mulRadius;\n    return new FigEllipse(new Point(r, -ff.capHeight * 0.5), new Point(r, r), {\n      fill: mStyle.fill,\n    });\n  }\n  return new FigText(props.mulChar, mFont, mStyle);\n};\n","import { Rect } from \"../../math/Rect\";\nimport { Point } from \"../../math/Point\";\nimport { getNodeCenterPos, getNodeInfo, NodeInfo } from \"../NodeInfo\";\nimport { PAgentCtx } from \"./PAgentCtx\";\nimport { ifDef } from \"../../utils/ifDef\";\n\nexport const findAgentCenter = (ctx: PAgentCtx): Point =>\n  calcExplicitCenter(findExplicitlyCentred(ctx.nodesInfo)) ??\n  monoCycle(ctx) ??\n  findDefaultCenter(ctx.nodesInfo, ctx.agentFrame.bounds) ??\n  ctx.agentFrame.bounds.center;\n\nconst monoCycle = (ctx: PAgentCtx): Point | undefined => {\n  const {\n    agent: { stA },\n    nodesInfo,\n  } = ctx;\n  stA.analyze();\n  if (stA.cycles.length !== 1) return undefined;\n  const cy = stA.cycles[0]!;\n  return cy.nodes\n    .reduce(\n      (sum, node) => sum.iadd(getNodeCenterPos(getNodeInfo(node, nodesInfo))),\n      new Point()\n    )\n    .scale(1 / cy.nodes.length);\n};\n\nexport const findExplicitlyCentred = (allNodesInfo: NodeInfo[]): NodeInfo[] =>\n  allNodesInfo.filter(({ node }) => node.bCenter);\n\nexport const calcExplicitCenter = (\n  expNodesInfo: NodeInfo[]\n): Point | undefined => {\n  const centers: Point[] = expNodesInfo.map((ni) => getNodeCenterPos(ni));\n  if (centers.length === 0) {\n    return undefined;\n  }\n  if (centers.length === 1) {\n    return centers[0]!;\n  }\n  const summa = centers.reduce((acc, p) => acc.iadd(p), new Point());\n  return summa.times(1 / centers.length);\n};\n\nconst findDefaultCenter = (\n  nodesInfo: NodeInfo[],\n  rect: Rect\n): Point | undefined =>\n  ifDef(findDefaultY(nodesInfo), (y) => new Point(rect.center.x, y));\n\nexport const findDefaultY = (nodesInfo: NodeInfo[]): number | undefined => {\n  // Алгоритм: найти наибольшее количество узлов с одинаковым y\n  // Если таких несколько, то взять из них среднее\n  const dict: Record<number, number> = {};\n  let maxCount = 0;\n  nodesInfo.forEach((ni) => {\n    // Ключом является значение y, округленное до сотых\n    const y = Math.round(getNodeCenterPos(ni).y * 100);\n    const count = (dict[y] ?? 0) + 1;\n    dict[y] = count;\n    maxCount = Math.max(count, maxCount);\n  });\n  let cy = 0;\n  let n = 0;\n  Object.entries(dict).forEach(([y, count]) => {\n    if (count === maxCount) {\n      cy += +y;\n      n++;\n    }\n  });\n  return n ? cy / 100 / n : undefined;\n};\n","import { FigFrame } from \"../../drawSys/figures/FigFrame\";\nimport { Point } from \"../../math/Point\";\nimport { Rect } from \"../../math/Rect\";\nimport { buildNode } from \"../buildNode\";\nimport { PAgentCtx } from \"./PAgentCtx\";\n\nexport const prepareNodes = (ctx: PAgentCtx) => {\n  const { agent, props } = ctx;\n  agent.nodes.forEach((node) => {\n    const res = buildNode(node, props) ?? {\n      nodeFrame: new FigFrame(),\n      rcNodeCore: new Rect(),\n      center: new Point(),\n    };\n    const pos = node.pt.times(props.line);\n    const { nodeFrame, center } = res;\n    nodeFrame.org.iadd(pos);\n    nodeFrame.org.isub(center);\n\n    ctx.nodesInfo[node.index] = { node, res };\n  });\n\n  ctx.clusters.init(agent.nodes, ctx.nodesInfo);\n};\n","import { ChemBackground } from \"../../core/ChemBackground\";\nimport { AgentCmd } from \"./AgentCmd\";\nimport { createAgentCmd } from \"./createAgentCmd\";\nimport { PAgentCtx } from \"./PAgentCtx\";\nimport { unwind } from \"./unwind\";\n\nexport const processCommands = (ctx: PAgentCtx) => {\n  let previousCmd: AgentCmd;\n  ctx.agent.commands.forEach((obj) => {\n    if (obj instanceof ChemBackground) {\n      ctx.backs.push(obj);\n      return;\n    }\n    const cmd = createAgentCmd(obj, ctx.agent);\n    if (cmd) {\n      if (previousCmd) cmd.onPrevious(previousCmd, ctx);\n      if (cmd.canPush(ctx)) {\n        ctx.cmdStack.unshift(cmd);\n      }\n      previousCmd = cmd;\n    }\n  });\n  unwind(ctx, () => true);\n};\n","import { AgentCmd } from \"./AgentCmd\";\nimport { PAgentCtx } from \"./PAgentCtx\";\n\nexport const unwind = (ctx: PAgentCtx, canPop: (cmd: AgentCmd) => boolean) => {\n  const { cmdStack } = ctx;\n  for (;;) {\n    const head = cmdStack.shift();\n    if (!head) return;\n    if (!canPop(head)) {\n      cmdStack.unshift(head);\n      return;\n    }\n    head.postExec(ctx);\n  }\n};\n","import { ChemAgent } from \"../core/ChemAgent\";\nimport { ChemOp } from \"../core/ChemOp\";\nimport { ChemExpr } from \"../core/ChemExpr\";\nimport { ChemImgProps } from \"../drawSys/ChemImgProps\";\nimport { FigFrame } from \"../drawSys/figures/FigFrame\";\nimport { buildAgentPrior } from \"./buildAgentPrior/buildAgentPrior\";\nimport { buildOp } from \"./buildOp\";\n\ninterface ResultBuildExpr {\n  frame: FigFrame;\n}\n\ninterface EntityInfo {\n  frame: FigFrame;\n  y: number;\n}\n\nexport const buildExpression = (\n  expr: ChemExpr,\n  props: ChemImgProps\n): ResultBuildExpr => {\n  const frame = new FigFrame();\n  let x = 0;\n  expr.entities.forEach((obj) => {\n    let einfo: EntityInfo | undefined;\n    if (obj instanceof ChemAgent) {\n      const { agentFrame, center } = buildAgentPrior(obj, props);\n      einfo = { frame: agentFrame, y: center.y };\n    } else if (obj instanceof ChemOp) {\n      const { frame: opFrame, center } = buildOp(obj, props);\n      einfo = { frame: opFrame, y: center.y };\n    }\n    if (einfo) {\n      einfo.frame.org.y -= einfo.y;\n      einfo.frame.org.x = x - einfo.frame.bounds.left;\n      x += einfo.frame.bounds.width + props.opSpace;\n      frame.addFigure(einfo.frame, true);\n    }\n  });\n  frame.bounds.grow(1); // Небольшое поле позволяет скрыть недостатки определения границ. Иначе отсекаются края.\n  return { frame };\n};\n","import { ChemImgProps } from \"../drawSys/ChemImgProps\";\nimport { ChemAgent } from \"../core/ChemAgent\";\nimport { ChemExpr } from \"../core/ChemExpr\";\nimport { FigFrame } from \"../drawSys/figures/FigFrame\";\nimport { buildExpression } from \"./buildExpression\";\nimport { buildAgentPrior } from \"./buildAgentPrior/buildAgentPrior\";\n\nexport const buildFrame = (\n  expr: ChemExpr | ChemAgent,\n  imgProps: ChemImgProps\n): FigFrame =>\n  expr instanceof ChemExpr\n    ? buildExpression(expr, imgProps).frame\n    : buildAgentPrior(expr, imgProps).agentFrame;\n","import { ChemNodeItem } from \"../core/ChemNodeItem\";\nimport { FigFrame } from \"../drawSys/figures/FigFrame\";\nimport { ChemImgProps, TextProps } from \"../drawSys/ChemImgProps\";\nimport { drawText } from \"./drawText\";\nimport { Rect } from \"../math/Rect\";\nimport { drawTextNear } from \"./drawTextNear\";\nimport { getTextInternalRect } from \"./getTextInternalRect\";\nimport { Figure } from \"../drawSys/figures/Figure\";\nimport { drawTextWithMarkup } from \"./drawTextWithMarkup\";\nimport { drawLewisShell } from \"./drawLewisShell\";\nimport { FigEllipse } from \"../drawSys/figures/FigEllipse\";\nimport { Point } from \"../math/Point\";\nimport { LocalFont } from \"../drawSys/AbstractSurface\";\nimport { ChemStyleId } from \"../drawSys/ChemStyleId\";\nimport { CoeffPos } from \"../types/CoeffPos\";\nimport { locateAtomNumber } from \"../inspectors/locateAtomNumber\";\nimport { ifDef } from \"../utils/ifDef\";\n\ninterface BuildItemResult {\n  itemFrame: FigFrame;\n  figText?: Figure;\n  rcCore?: Rect;\n}\n\nexport const buildItem = (\n  item: ChemNodeItem,\n  imgProps: ChemImgProps\n): BuildItemResult => {\n  const itemFrame = new FigFrame();\n  itemFrame.label = \"item\";\n  const { color } = item;\n  let itemFont: LocalFont | undefined;\n  const { fig, rcCore } = item.walkExt({\n    fig: undefined as Figure | undefined,\n    rcCore: undefined as Rect | undefined,\n    onText(text: string, style: TextProps) {\n      const txFig = drawText(itemFrame, text, style);\n      this.fig = txFig;\n      this.rcCore = getTextInternalRect(txFig);\n      itemFont = style.font;\n    },\n    onMarkup(textWithMarkup: string, style: TextProps) {\n      itemFont = style.font;\n      const { fig: figM, irc } = drawTextWithMarkup(\n        textWithMarkup,\n        imgProps,\n        style\n      );\n      itemFrame.addFigure(figM, true);\n      this.fig = figM;\n      this.rcCore = irc;\n    },\n\n    atom(obj) {\n      this.onText(\n        obj.id,\n        imgProps.getStyleColored(\"atom\", item.atomColor ?? item.color)\n      );\n    },\n    radical(obj) {\n      this.onText(obj.label, imgProps.getStyleColored(\"radical\", item.color));\n    },\n    comment(obj) {\n      this.onMarkup(obj.text, imgProps.getStyleColored(\"comment\", item.color));\n    },\n    custom(obj) {\n      this.onMarkup(obj.text, imgProps.getStyleColored(\"custom\", item.color));\n    },\n    comma() {\n      this.onText(\",\", imgProps.getStyleColored(\"comma\", item.color));\n    },\n  });\n  if (rcCore) {\n    const drawIndex = (value: unknown, styleName: ChemStyleId, pos: CoeffPos) =>\n      drawTextNear({\n        frame: itemFrame,\n        rcCore,\n        text: String(value),\n        imgProps,\n        style: imgProps.getStyleColored(styleName, item.color),\n        pos,\n      });\n\n    const { atomNum, n, charge, mass, dots } = item;\n    if (n.isSpecified()) {\n      drawIndex(n.toString(), \"itemCount\", \"RB\");\n    }\n    if (charge) {\n      drawIndex(charge.text, \"oxidationState\", \"CU\");\n    }\n    ifDef(mass, (it) => drawIndex(it, \"itemMass\", \"LT\"));\n    ifDef(atomNum, (it) => {\n      const atomNumber = it === \"\" ? locateAtomNumber(item) : it;\n      if (atomNumber !== undefined) drawIndex(atomNumber, \"atomNumber\", \"LB\");\n    });\n    if (dots) {\n      const rc = rcCore.clone();\n      if (itemFont) {\n        rc.B.y -= (itemFont as LocalFont).getFontFace().descent;\n        rc.B.y -= imgProps.lineWidth;\n      }\n      const radius = imgProps.electronDotD / 2;\n      const pr = new Point(radius, radius);\n      rc.grow(imgProps.lineWidth + radius);\n      drawLewisShell(rc, dots, imgProps, ({ p, color: dotColor }) => {\n        const figDot = new FigEllipse(p, pr, {\n          fill: dotColor || color || imgProps.stdStyle.style.fill,\n        });\n        figDot.bounds.grow(imgProps.lineWidth);\n        itemFrame.addFigure(figDot);\n      });\n    }\n    // TODO: dashes\n  }\n  itemFrame.update();\n  return { itemFrame, figText: fig, rcCore };\n};\n","import { ChemImgProps } from \"../drawSys/ChemImgProps\";\nimport { ChemNode } from \"../core/ChemNode\";\nimport { FigFrame } from \"../drawSys/figures/FigFrame\";\nimport { buildItem } from \"./buildItem\";\nimport { Point } from \"../math/Point\";\nimport { Rect } from \"../math/Rect\";\nimport { drawCharge } from \"./drawCharge\";\nimport { isEmptyNode } from \"../core/isEmptyNode\";\n\nexport interface ResultBuildNode {\n  nodeFrame: FigFrame;\n  rcNodeCore: Rect; // in local coordinates\n  center: Point; // in local coordinates (relative (0,0) of frame bounds)\n}\n\nexport const buildNode = (\n  node: ChemNode,\n  imgProps: ChemImgProps\n): ResultBuildNode | undefined => {\n  if ((node.autoMode || isEmptyNode(node)) && !node.charge) {\n    // auto node dont draw items. Example: /\\/\\\n    return undefined;\n  }\n  const nodeFrame = new FigFrame();\n  nodeFrame.label = \"node\";\n  const centerItem = node.getCenterItem();\n  let x = 0;\n  let center: Point | undefined;\n  let rcNodeCore: Rect | undefined;\n  if (node.autoMode) {\n    // Для автоузлов нужно имитировать область, вокруг которой будет выводиться заряд\n    // Координаты так подобраны, чтобы соответствовать тексту (то есть, относительно базовой линии)\n    const d = imgProps.line * 0.2;\n    nodeFrame.bounds = new Rect(0, -d, d, 0);\n  } else {\n    node.items.forEach((item) => {\n      const { itemFrame, rcCore } = buildItem(item, imgProps);\n      itemFrame.org.x = x - itemFrame.bounds.left;\n      nodeFrame.addFigure(itemFrame);\n      if (rcCore) {\n        const irc = rcCore.clone();\n        irc.moveXY(itemFrame.org.x, 0);\n        if (item === centerItem) {\n          center = irc.center;\n        }\n        if (!rcNodeCore) {\n          rcNodeCore = irc.clone();\n        } else {\n          rcNodeCore.unite(irc);\n        }\n      }\n      x += itemFrame.bounds.width;\n    });\n    nodeFrame.update();\n  }\n  const { charge } = node;\n  rcNodeCore = rcNodeCore ?? nodeFrame.bounds.clone();\n  if (charge) {\n    drawCharge({\n      charge,\n      frame: nodeFrame,\n      rect: rcNodeCore,\n      imgProps,\n      color: node.color,\n    });\n  }\n\n  center = center ?? rcNodeCore.center;\n  return { nodeFrame, rcNodeCore, center };\n};\n","import { ChemOp } from \"../core/ChemOp\";\nimport { ChemImgProps } from \"../drawSys/ChemImgProps\";\nimport { FigText } from \"../drawSys/figures/FigText\";\nimport { Point } from \"../math/Point\";\nimport { FigFrame } from \"../drawSys/figures/FigFrame\";\nimport { getTextInternalRect } from \"./getTextInternalRect\";\nimport { Figure } from \"../drawSys/figures/Figure\";\nimport { Rect } from \"../math/Rect\";\nimport { ChemComment } from \"../core/ChemComment\";\nimport { ifDef } from \"../utils/ifDef\";\nimport { FigPath } from \"../drawSys/figures/FigPath\";\nimport { PathSeg } from \"../drawSys/path\";\nimport { LocalFont, PathStyle, TextStyle } from \"../drawSys/AbstractSurface\";\nimport { drawTextWithMarkup, ResultTextWithMarkup } from \"./drawTextWithMarkup\";\n\ninterface FigDef {\n  figOp: Figure;\n  irc: Rect;\n}\n\ninterface ParamsOpDraw {\n  srcText: string;\n  dstText: string;\n  props: ChemImgProps;\n  font: LocalFont;\n  style: TextStyle;\n  commWidth: number;\n}\n\ninterface ResultBuildOp {\n  frame: FigFrame;\n  center: Point;\n}\n\nexport const buildOp = (op: ChemOp, props: ChemImgProps): ResultBuildOp => {\n  const comms: [\n    ResultTextWithMarkup | undefined,\n    ResultTextWithMarkup | undefined\n  ] = [\n    ifDef(op.commentPre, (it) => buildOpComment(it, props, op.color)),\n    ifDef(op.commentPost, (it) => buildOpComment(it, props, op.color)),\n  ];\n  const { srcText, dstText } = op;\n  const commWidth = comms.reduce(\n    (width, com) => Math.max(width, com ? com.fig.bounds.width : 0),\n    0\n  );\n  const frame = new FigFrame();\n  const style = props.getStyleColored(\"operation\", op.color);\n  const drawFn = opDict[srcText] ?? opTextFigure;\n  const { figOp, irc } = drawFn({\n    srcText,\n    dstText,\n    props,\n    commWidth,\n    ...style,\n  });\n  frame.addFigure(figOp, true);\n  comms.forEach((com, i) =>\n    ifDef(com, (it) => addOpComment(frame, irc, it, i === 0))\n  );\n  return { frame, center: irc.center };\n};\n\nconst makeStrokeStyle = ({ props, style }: ParamsOpDraw): PathStyle => ({\n  stroke: style.fill,\n  strokeWidth: props.lineWidth,\n});\n\nconst opTextFigure = ({ dstText, font, style }: ParamsOpDraw): FigDef => {\n  const figOp = new FigText(dstText, font, style);\n  const irc = getTextInternalRect(figOp);\n  return { figOp, irc };\n};\n\nconst opLongArrow = (params: ParamsOpDraw): FigDef => {\n  const { props, style, font, commWidth, srcText, dstText } = params;\n  const { arrowD, arrowL, line } = props;\n  const isFilledArrow = srcText === \"--|>\";\n  const minWidth = Math.max(line, font.getTextWidth(dstText));\n  const width = Math.max(commWidth + 2 * props.opSpace, minWidth);\n  const lineLen = width - arrowL;\n\n  const segs: PathSeg[] = [\n    { cmd: \"M\", pt: Point.zero },\n    { cmd: \"L\", pt: new Point(isFilledArrow ? lineLen : width, 0) },\n  ];\n  const figLine = new FigPath(segs, makeStrokeStyle(params));\n  figLine.update();\n\n  const tri: PathSeg[] = [\n    { cmd: \"M\", pt: new Point(lineLen, -arrowD) },\n    { cmd: \"L\", pt: new Point(width, 0) },\n    { cmd: \"L\", pt: new Point(lineLen, arrowD) },\n  ];\n  if (isFilledArrow) tri.push({ cmd: \"Z\" });\n  const triStyle: PathStyle = isFilledArrow\n    ? { fill: style.fill }\n    : makeStrokeStyle(params);\n  triStyle.join = \"miter\";\n  const figArrow = new FigPath(tri, triStyle);\n  figArrow.update();\n\n  const figOp = new FigFrame();\n  figOp.addFigure(figLine, true);\n  figOp.addFigure(figArrow, true);\n  return { figOp, irc: figOp.bounds };\n};\n\nconst opLongLeftArrow = (params: ParamsOpDraw): FigDef => {\n  const { props, style, font, commWidth, srcText, dstText } = params;\n  const { arrowD, arrowL, line } = props;\n  const isFilledArrow = srcText === \"<|--\";\n  const minWidth = Math.max(line, font.getTextWidth(dstText));\n  const width = Math.max(commWidth + 2 * props.opSpace, minWidth);\n\n  const segs: PathSeg[] = [\n    { cmd: \"M\", pt: new Point(width, 0) },\n    { cmd: \"L\", pt: new Point(isFilledArrow ? arrowL : 0, 0) },\n  ];\n  const figLine = new FigPath(segs, makeStrokeStyle(params));\n  figLine.update();\n\n  const tri: PathSeg[] = [\n    { cmd: \"M\", pt: new Point(arrowL, -arrowD) },\n    { cmd: \"L\", pt: new Point(0, 0) },\n    { cmd: \"L\", pt: new Point(arrowL, arrowD) },\n  ];\n  if (isFilledArrow) tri.push({ cmd: \"Z\" });\n  const triStyle: PathStyle = isFilledArrow\n    ? { fill: style.fill }\n    : makeStrokeStyle(params);\n  triStyle.join = \"miter\";\n  const figArrow = new FigPath(tri, triStyle);\n  figArrow.update();\n\n  const figOp = new FigFrame();\n  figOp.addFigure(figLine, true);\n  figOp.addFigure(figArrow, true);\n  return { figOp, irc: figOp.bounds };\n};\n\n// <-->\nconst opLongBiArrow = (params: ParamsOpDraw): FigDef => {\n  const { props, style, font, commWidth, srcText, dstText } = params;\n  const { arrowD, arrowL, line } = props;\n  const isFilledArrow = srcText === \"<|--|>\";\n  const minWidth = Math.max(line, font.getTextWidth(dstText));\n  const width = Math.max(commWidth + 2 * props.opSpace, minWidth);\n  const lineLen = width - arrowL;\n\n  const segs: PathSeg[] = [\n    { cmd: \"M\", pt: new Point(isFilledArrow ? lineLen : width, 0) },\n    { cmd: \"L\", pt: new Point(isFilledArrow ? arrowL : 0, 0) },\n  ];\n  const figLine = new FigPath(segs, makeStrokeStyle(params));\n  figLine.update();\n\n  const triLeft: PathSeg[] = [\n    { cmd: \"M\", pt: new Point(arrowL, -arrowD) },\n    { cmd: \"L\", pt: new Point(0, 0) },\n    { cmd: \"L\", pt: new Point(arrowL, arrowD) },\n  ];\n  if (isFilledArrow) triLeft.push({ cmd: \"Z\" });\n  const triStyle: PathStyle = isFilledArrow\n    ? { fill: style.fill }\n    : makeStrokeStyle(params);\n  triStyle.join = \"miter\";\n  const figArrowLeft = new FigPath(triLeft, triStyle);\n  figArrowLeft.update();\n\n  const triRight: PathSeg[] = [\n    { cmd: \"M\", pt: new Point(lineLen, -arrowD) },\n    { cmd: \"L\", pt: new Point(width, 0) },\n    { cmd: \"L\", pt: new Point(lineLen, arrowD) },\n  ];\n  if (isFilledArrow) triRight.push({ cmd: \"Z\" });\n  const figArrowRight = new FigPath(triRight, triStyle);\n  figArrowRight.update();\n\n  const figOp = new FigFrame();\n  figOp.addFigure(figArrowLeft, true);\n  figOp.addFigure(figLine, true);\n  figOp.addFigure(figArrowRight, true);\n  return { figOp, irc: figOp.bounds };\n};\n\nconst opLongBothArrow = (params: ParamsOpDraw): FigDef => {\n  const { props, commWidth } = params;\n  const { lineWidth, lineSpace2x, arrowD, arrowL, opSpace } = props;\n  const dy = (lineSpace2x + lineWidth) / 2;\n  const width = commWidth + 2 * opSpace;\n  const segs: PathSeg[] = [\n    { cmd: \"M\", pt: new Point(0, -dy) },\n    { cmd: \"H\", x: width - lineWidth },\n    { cmd: \"L\", rel: true, pt: new Point(-arrowL, -arrowD) },\n    { cmd: \"M\", pt: new Point(width, dy) },\n    { cmd: \"H\", x: lineWidth },\n    { cmd: \"L\", rel: true, pt: new Point(arrowL, arrowD) },\n  ];\n  const figOp = new FigPath(segs, {\n    ...makeStrokeStyle(params),\n    join: \"miter\",\n  });\n  figOp.update();\n  return { figOp, irc: figOp.bounds };\n};\n\nconst opDict: Record<string, (params: ParamsOpDraw) => FigDef> = {\n  \"-->\": opLongArrow,\n  \"--|>\": opLongArrow,\n  \"<==>\": opLongBothArrow,\n  \"<--\": opLongLeftArrow,\n  \"<|--\": opLongLeftArrow,\n  \"<-->\": opLongBiArrow,\n};\n\nconst addOpComment = (\n  frame: FigFrame,\n  opRect: Rect,\n  comm: ResultTextWithMarkup,\n  isTop: boolean\n): void => {\n  const { fig, irc } = comm;\n  const { bounds } = fig;\n  fig.org.set(\n    irc.left + opRect.width / 2 - irc.width / 2,\n    isTop ? -(bounds.bottom - irc.bottom) + opRect.top : opRect.bottom - irc.top\n  );\n  frame.addFigure(fig, true);\n};\n\nconst buildOpComment = (\n  comm: ChemComment,\n  props: ChemImgProps,\n  color: string | undefined\n): ResultTextWithMarkup => {\n  const tp = props.getStyleColored(\"opComment\", color);\n  return drawTextWithMarkup(comm.text, props, tp);\n};\n","import { ChemStyleId } from \"../drawSys/ChemStyleId\";\nimport { ChemCharge } from \"../core/ChemCharge\";\nimport { ChemImgProps, TextProps } from \"../drawSys/ChemImgProps\";\nimport { FigFrame } from \"../drawSys/figures/FigFrame\";\nimport { Rect } from \"../math/Rect\";\nimport { drawTextNear, moveNearFigure, NearTextType } from \"./drawTextNear\";\nimport { FigEllipse } from \"../drawSys/figures/FigEllipse\";\nimport { Point } from \"../math/Point\";\nimport { Figure } from \"../drawSys/figures/Figure\";\nimport { CoeffPosOrAngle } from \"../types/CoeffPos\";\nimport { FigPath } from \"../drawSys/figures/FigPath\";\nimport { PathSeg } from \"../drawSys/path\";\n\ninterface ParamsDrawCharge {\n  charge: ChemCharge;\n  frame: FigFrame;\n  rect: Rect;\n  imgProps: ChemImgProps;\n  color?: string;\n  styleId?: ChemStyleId;\n  type?: NearTextType;\n}\n\nexport const drawCharge = ({\n  charge,\n  frame,\n  rect,\n  imgProps,\n  color,\n  styleId = \"nodeCharge\",\n  type,\n}: ParamsDrawCharge) => {\n  const style = imgProps.getStyleColored(styleId, color);\n  const pos = charge.pos ?? \"RT\";\n  const figTxt: Figure =\n    charge.text === \"+\" || charge.text === \"-\"\n      ? drawSpecialCharge({\n          frame,\n          rect,\n          text: charge.text,\n          isRound: charge.isRound,\n          pos,\n          style,\n          imgProps,\n          type,\n        })\n      : drawTextNear({\n          frame,\n          rcCore: rect,\n          text: charge.text,\n          imgProps,\n          style,\n          pos,\n          type,\n        });\n  frame.updateFigure(figTxt);\n};\n\ninterface ParamsDrawSpechialCharge {\n  frame: FigFrame;\n  rect: Rect;\n  text: \"+\" | \"-\";\n  isRound: boolean;\n  pos: CoeffPosOrAngle;\n  style: TextProps;\n  imgProps: ChemImgProps;\n  type: NearTextType;\n}\nconst drawSpecialCharge = (params: ParamsDrawSpechialCharge): Figure => {\n  const { frame, rect, text, isRound, pos, style, imgProps, type } = params;\n  const ff = style.font.getFontFace();\n  const lw = imgProps.lineWidth;\n  const w = style.font.getTextWidth(\"+\") * 0.9 - (text === \"-\" ? lw : 0);\n\n  // Для пиксельных поверхностей лучше было бы использовать вывод линий, а не закрашенных многоугольников\n  // Но пока этого не делаем. Считаем, что всё выводится в вектор.\n\n  // Координаты фигуры должны соответствовать принципам вывода текста. Т.е. начало в левом нижнем углу.\n  const maxX = w;\n  const maxY = -ff.capHeight;\n  const minY = 0; // -ff.descent;\n  const cx = maxX / 2;\n  const cy = (maxY + minY) / 2;\n  const lw2 = lw / 2;\n  const segs: PathSeg[] =\n    text === \"-\"\n      ? [\n          { cmd: \"M\", pt: new Point(0, cy - lw2) },\n          { cmd: \"H\", x: maxX },\n          { cmd: \"V\", y: lw, rel: true },\n          { cmd: \"H\", x: 0 },\n          { cmd: \"Z\" },\n        ]\n      : [\n          { cmd: \"M\", pt: new Point(0, cy - lw2) },\n          { cmd: \"H\", x: cx - lw2 },\n          { cmd: \"V\", y: cy - w / 2 },\n          { cmd: \"H\", rel: true, x: lw },\n          { cmd: \"V\", y: cy - lw2 },\n          { cmd: \"H\", x: maxX },\n          { cmd: \"V\", rel: true, y: lw },\n          { cmd: \"H\", x: cx + lw2 },\n          { cmd: \"V\", y: cy + w / 2 },\n          { cmd: \"H\", rel: true, x: -lw },\n          { cmd: \"V\", y: cy + lw2 },\n          { cmd: \"H\", x: 0 },\n          { cmd: \"Z\" },\n        ];\n  const fig = new FigFrame();\n  const figCharge = new FigPath(segs, { fill: style.style.fill });\n  figCharge.update();\n  figCharge.bounds.unite(new Rect(0, maxY, maxX, minY));\n  fig.addFigure(figCharge);\n\n  if (isRound) {\n    const bounds = new Rect(0, maxY, maxX, minY);\n    const r = Math.max(bounds.width, bounds.height) * 0.5;\n    const figR = new FigEllipse(bounds.center, new Point(r, r), {\n      stroke: style.style.fill,\n    });\n    fig.addFigure(figR);\n  }\n\n  fig.update();\n  const rcFig = fig.bounds.clone();\n  rcFig.A.y = -ff.ascent;\n  rcFig.B.y = -ff.descent;\n  moveNearFigure(fig, rcFig, pos, rect, imgProps, type);\n\n  frame.addFigure(fig);\n  frame.update();\n  return fig;\n};\n","import { ifDef } from \"../utils/ifDef\";\nimport { LewisDot } from \"../core/ChemNodeItem\";\nimport { Point, pointFromDeg } from \"../math/Point\";\nimport { Rect } from \"../math/Rect\";\nimport { ChemImgProps } from \"../drawSys/ChemImgProps\";\n\nexport interface LewisDotExt {\n  c: Point;\n  p: Point;\n  color?: string;\n}\n\nconst div = 3.5;\n\nconst calcPos: ((rc: Rect) => Point)[] = [\n  (rc) => new Point(rc.right, rc.bottom - rc.height / div), // 0: right bottom\n  (rc) => new Point(rc.right - rc.width / div, rc.bottom), // 1: bottom right\n  (rc) => new Point(rc.left + rc.width / div, rc.bottom), // 2: bottom left\n  (rc) => new Point(rc.left, rc.bottom - rc.height / div), // 3: left bottom\n  (rc) => new Point(rc.left, rc.top + rc.height / div), // 4: left top\n  (rc) => new Point(rc.left + rc.width / div, rc.top), // 5: top left\n  (rc) => new Point(rc.right - rc.width / div, rc.top), // 6: top right\n  (rc) => new Point(rc.right, rc.top + rc.height / div), // 7: right top\n];\n\nexport const drawLewisShell = (\n  rc: Rect,\n  dots: LewisDot[],\n  props: ChemImgProps,\n  onDot: (dot: LewisDotExt) => void\n) => {\n  const c = rc.center;\n  const d = rc.width + rc.height;\n  dots.forEach(({ angle, pos, color, margin }) => {\n    const rcCur = rc.clone();\n    if (margin) rcCur.grow(margin * props.line);\n    ifDef(angle, (it) => {\n      const pExt = pointFromDeg(it).times(d).plus(c);\n      const { b: p } = rcCur.clip(c, pExt);\n      onDot({ c, p, color });\n    });\n    ifDef(pos, (it) => {\n      const fn = calcPos[it];\n      if (fn) onDot({ c, p: fn(rcCur), color });\n    });\n  });\n};\n","import { FigFrame } from \"../drawSys/figures/FigFrame\";\nimport { TextProps } from \"../drawSys/ChemImgProps\";\nimport { FigText } from \"../drawSys/figures/FigText\";\n\nexport const drawText = (\n  frame: FigFrame,\n  text: string,\n  style: TextProps\n): FigText => {\n  const fig = new FigText(text, style.font, style.style);\n  frame.addFigure(fig);\n  return fig;\n};\n","import { isClose } from \"../math\";\nimport { Rect } from \"../math/Rect\";\nimport { FigFrame } from \"../drawSys/figures/FigFrame\";\nimport { ChemImgProps, TextProps } from \"../drawSys/ChemImgProps\";\nimport { drawText } from \"./drawText\";\nimport { CoeffPosOrAngle } from \"../types/CoeffPos\";\nimport { pointFromDeg } from \"../math/Point\";\nimport { Figure } from \"../drawSys/figures/Figure\";\n\nexport type NearTextType = \"bracket\" | undefined;\n\ninterface ParamsDrawTextNear {\n  frame: FigFrame;\n  rcCore: Rect;\n  text: string;\n  imgProps: ChemImgProps;\n  style: TextProps;\n  pos: CoeffPosOrAngle;\n  type?: NearTextType;\n}\n\nconst getShiftCoeff = (\n  imgProps: ChemImgProps,\n  pos: \"sup\" | \"sub\",\n  type: NearTextType\n): number => {\n  switch (type) {\n    case \"bracket\":\n      return pos === \"sup\" ? imgProps.bracketSupKY : imgProps.bracketSubKY;\n    default:\n      return pos === \"sup\" ? imgProps.supKY : imgProps.subKY;\n  }\n};\n\nconst makeRectExt = (\n  rcCore: Rect,\n  type: NearTextType,\n  imgProps: ChemImgProps\n): Rect => {\n  const rcCoreExt = rcCore.clone();\n  if (type === \"bracket\") {\n    const sp = imgProps.lineWidth * 2;\n    rcCoreExt.A.x -= sp;\n    rcCoreExt.B.x += sp;\n  }\n  return rcCoreExt;\n};\n\nexport const moveNearFigure = (\n  fig: Figure,\n  rcFig: Rect,\n  pos: CoeffPosOrAngle,\n  rcCore: Rect,\n  imgProps: ChemImgProps,\n  type: NearTextType\n) => {\n  const rcCoreExt = makeRectExt(rcCore, type, imgProps);\n\n  /* eslint no-param-reassign: \"off\" */\n  if (typeof pos === \"number\") {\n    const { center } = rcCoreExt;\n    const { b } = rcCoreExt.clip(\n      center,\n      center.plus(pointFromDeg(pos).times(rcCoreExt.width + rcCoreExt.height))\n    );\n    if (isClose(b.x, rcCoreExt.right)) {\n      fig.org.x = b.x - rcFig.left;\n    } else if (isClose(b.x, rcCoreExt.left)) {\n      fig.org.x = b.x - rcFig.right;\n    } else {\n      fig.org.x = b.x - rcFig.left - rcFig.width / 2;\n    }\n    if (isClose(b.y, rcCoreExt.top)) {\n      fig.org.y = b.y - rcFig.bottom;\n    } else if (isClose(b.y, rcCoreExt.bottom)) {\n      fig.org.y = b.y - rcFig.top;\n    } else {\n      fig.org.y = b.y - rcFig.top - rcFig.height / 2; // fontFace.ascent / 2;\n    }\n  } else {\n    if (pos[0] === \"R\") {\n      fig.org.x = rcCoreExt.right - rcFig.left;\n    } else if (pos[0] === \"L\") {\n      fig.org.x = rcCoreExt.left - rcFig.right;\n    } else if (pos[0] === \"C\") {\n      fig.org.x = rcCoreExt.cx - fig.bounds.width * 0.5;\n    }\n    if (pos[1] === \"T\") {\n      fig.org.y =\n        rcCoreExt.top +\n        rcFig.height * (1 - getShiftCoeff(imgProps, \"sup\", type));\n    } else if (pos[1] === \"B\") {\n      fig.org.y =\n        rcCoreExt.bottom + rcFig.height * getShiftCoeff(imgProps, \"sub\", type);\n    } else if (pos[1] === \"U\") {\n      fig.org.y = rcCoreExt.top - rcFig.bottom;\n    } else if (pos[1] === \"D\") {\n      fig.org.y = rcCoreExt.bottom - rcFig.top;\n    }\n  }\n};\n\nexport const drawTextNear = ({\n  frame,\n  rcCore,\n  text,\n  imgProps,\n  style,\n  pos,\n  type,\n}: ParamsDrawTextNear) => {\n  const rcCoreExt = makeRectExt(rcCore, type, imgProps);\n  const fig = drawText(frame, text, style);\n  const figFF = fig.font.getFontFace();\n  if (typeof pos === \"number\") {\n    const { center } = rcCoreExt;\n    const { b } = rcCoreExt.clip(\n      center,\n      center.plus(pointFromDeg(pos).times(rcCoreExt.width + rcCoreExt.height))\n    );\n    if (isClose(b.x, rcCoreExt.right)) {\n      fig.org.x = b.x;\n    } else if (isClose(b.x, rcCoreExt.left)) {\n      fig.org.x = b.x - fig.font.getTextWidth(text);\n    } else {\n      fig.org.x = b.x - fig.font.getTextWidth(text) / 2;\n    }\n    if (isClose(b.y, rcCoreExt.top)) {\n      fig.org.y = b.y + figFF.descent;\n    } else if (isClose(b.y, rcCoreExt.bottom)) {\n      fig.org.y = b.y + figFF.ascent;\n    } else {\n      fig.org.y = b.y + figFF.ascent / 2;\n    }\n  } else {\n    if (pos[0] === \"R\") {\n      fig.org.x = rcCoreExt.right;\n    } else if (pos[0] === \"L\") {\n      fig.org.x = -fig.bounds.width;\n    } else if (pos[0] === \"C\") {\n      fig.org.x = rcCoreExt.cx - fig.bounds.width * 0.5;\n    }\n    if (pos[1] === \"T\") {\n      fig.org.y =\n        rcCoreExt.top +\n        figFF.ascent * (1 - getShiftCoeff(imgProps, \"sup\", type));\n    } else if (pos[1] === \"B\") {\n      fig.org.y =\n        rcCoreExt.bottom + figFF.ascent * getShiftCoeff(imgProps, \"sub\", type);\n    } else if (pos[1] === \"U\") {\n      fig.org.y = rcCoreExt.top + figFF.descent;\n    } else if (pos[1] === \"D\") {\n      fig.org.y = rcCoreExt.bottom + figFF.ascent;\n    }\n  }\n  return fig;\n};\n","import { FigFrame } from \"../drawSys/figures/FigFrame\";\nimport { MarkupChunk, parseMarkup } from \"../utils/markup\";\nimport { ChemImgProps, TextProps } from \"../drawSys/ChemImgProps\";\nimport { Figure } from \"../drawSys/figures/Figure\";\nimport { Rect } from \"../math/Rect\";\nimport { FigText } from \"../drawSys/figures/FigText\";\nimport { is0 } from \"../math\";\nimport { LocalFont, TextStyle } from \"../drawSys/AbstractSurface\";\n\nexport interface ResultTextWithMarkup {\n  fig: Figure;\n  irc: Rect;\n}\n\ninterface ParamsDrawMarkup {\n  chunk: MarkupChunk;\n  imgProps: ChemImgProps;\n  font: LocalFont;\n  style: TextStyle;\n  scale: number;\n}\n\nconst drawMarkup = ({\n  chunk,\n  imgProps,\n  font,\n  style,\n  scale,\n}: ParamsDrawMarkup): ResultTextWithMarkup => {\n  const irc = new Rect(0, -font.getFontFace().ascent, 0, 0);\n  const fig = new FigFrame();\n  fig.label = \"markup\";\n  let xSup = 0;\n  let xSub = 0;\n  const updateX = () => {\n    xSup = fig.bounds.right;\n    xSub = xSup;\n  };\n  chunk.chunks.forEach((subChunk) => {\n    if (typeof subChunk === \"string\") {\n      const txFig = new FigText(subChunk, font, style);\n      txFig.org.x = fig.bounds.right;\n      fig.addFigure(txFig, true);\n      updateX();\n      return;\n    }\n    const { type, color } = subChunk;\n    if (type === \"sup\" || type === \"sub\") {\n      const isSup = type === \"sup\";\n      const newFont: LocalFont = font.createScaled\n        ? font.createScaled(scale)\n        : font;\n      const ff = newFont.getFontFace();\n      const height = ff.ascent - ff.descent;\n      const rs = drawMarkup({\n        chunk: subChunk,\n        font: newFont,\n        style,\n        scale,\n        imgProps,\n      });\n      const rsFig = rs.fig;\n      if (isSup) {\n        const dY = height * imgProps.supKY;\n        rsFig.org.set(xSup, irc.top + ff.ascent - dY);\n        xSup += rsFig.bounds.width;\n      } else {\n        const dY = height * imgProps.subKY;\n        rsFig.org.set(xSub, irc.bottom + dY);\n        xSub += rsFig.bounds.width;\n      }\n      fig.addFigure(rsFig, true);\n      return;\n    }\n    const newStyle = { ...style };\n    if (color) newStyle.fill = color;\n    const res = drawMarkup({\n      chunk: subChunk,\n      imgProps,\n      font,\n      style: newStyle,\n      scale,\n    });\n    res.fig.org.x = fig.bounds.right;\n    fig.addFigure(res.fig, true);\n    updateX();\n  });\n  irc.B.x = fig.bounds.right;\n  return { fig, irc };\n};\n\nexport const drawTextWithMarkup = (\n  text: string,\n  imgProps: ChemImgProps,\n  { font, style }: TextProps\n): ResultTextWithMarkup => {\n  const stdH = imgProps.stdStyle.font.getFontFace().ascent;\n  const subH = imgProps.getStyle(\"itemCount\").font.getFontFace().ascent;\n  const scale = is0(stdH - subH) ? 0.7 : subH / stdH;\n  const chunk = parseMarkup(text);\n  return drawMarkup({ chunk, imgProps, font, style, scale });\n};\n","import { Rect } from \"../math/Rect\";\nimport { FigText } from \"../drawSys/figures/FigText\";\n\nexport const getTextInternalRect = (figText: FigText): Rect => {\n  const rc = figText.bounds.clone();\n  rc.A.y = -figText.font.getFontFace().ascent;\n  rc.B.y = 0;\n  return rc;\n};\n","import { ChemAtom } from \"../core/ChemAtom\";\nimport { Lang } from \"../lang/Lang\";\nimport { drawTag } from \"../utils/xml/drawTag\";\nimport { escapeXml } from \"../utils/xml/escapeXml\";\n\nconst div = (\n  cls: string,\n  value: string | number,\n  attrs?: Record<string, string>,\n  tag?: string\n): string =>\n  `${\n    drawTag(tag ?? \"div\", { ...attrs, class: cls }) + escapeXml(String(value))\n  }</div>`;\n\nexport type FieldRenderFn = (elem: ChemAtom, stdOut: typeof div) => string;\n\nexport type CellRenderField = \"number\" | \"id\" | \"name\" | \"mass\";\n\nconst fieldsDict: Record<CellRenderField, FieldRenderFn> = {\n  number: (elem, stdOut) => stdOut(\"number\", elem.n),\n  id: (elem, stdOut) => stdOut(\"id\", elem.id),\n  name: (elem, stdOut) => stdOut(\"name\", Lang.tr(elem.id)),\n  mass: (elem, stdOut) => stdOut(\"mass\", elem.mass),\n};\n\nexport class CellRender {\n  fields: FieldRenderFn[];\n\n  constructor(\n    fields: (CellRenderField | FieldRenderFn)[] = [\n      \"number\",\n      \"id\",\n      \"name\",\n      \"mass\",\n    ]\n  ) {\n    // В старых JS версиях вместо массива fields может быть строка, разделенная запятыми\n    if (typeof fields === \"string\") {\n      // eslint-disable-next-line no-param-reassign\n      fields = (fields as unknown as string).split(\",\") as CellRenderField[];\n    }\n    this.fields = fields.map((f) =>\n      typeof f === \"function\" ? f : fieldsDict[f]\n    );\n  }\n\n  draw(elem: ChemAtom): string {\n    return this.fields.map((field) => (field ? field(elem, div) : \"\")).join(\"\");\n  }\n}\n","/**\n * Site: https://chemistry-easy.ru/\n *\n * In certain circles, this version of the table is the most correct.\n * Although it does not correspond to the form adopted by IUPAC.\n * Discussion:\n * https://vk.com/topic-93343283_35170908\n * Images:\n * https://drive.google.com/drive/folders/1H8VT9UcX0UsWWIIiXh5O19C_FryArFYC\n */\n\nimport { fallingNumbers } from \"./fallingNumbers\";\nimport { categoryBlockDLa } from \"./tableCategories\";\nimport { TableRules } from \"./TableRules\";\n\nconst rules: TableRules = {\n  tables: [\n    { NCol: 19, NRow: 7 }, // 18 + Short column for lanthanides and actinides placeholder.\n    { NCol: 15, NRow: 2 },\n  ],\n  category: categoryBlockDLa,\n  points: {\n    He: [18, 0],\n    B: [13, 1],\n    Al: [13, 2],\n    Ti: [4, 3],\n    Zr: [4, 4],\n    Ce: [1, 0, 1],\n    Hf: [4, 5],\n    Th: [1, 1, 1],\n    Rf: [4, 6],\n  },\n  hardNotes: [\n    { text: \"*\", x: 3, y: 5, cls: \"chem-element f_block mtbl-note\" },\n    { text: \"*<br>*\", x: 3, y: 6, cls: \"chem-element f2_block mtbl-note\" },\n    { text: \"*\", x: 0, y: 0, tblN: 1, cls: \"chem-element f_block mtbl-note\" },\n    {\n      text: \"*<br>*\",\n      x: 0,\n      y: 1,\n      tblN: 1,\n      cls: \"chem-element f2_block mtbl-note\",\n    },\n  ],\n  drawGroups: fallingNumbers,\n  groupIds: \"1,2,3,,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18\".split(\",\"),\n  groupCls: \"group-id\",\n  tableCls: \"mentable easy-chem-table\",\n  elementBoxCls: \"element-box\",\n};\n\nexport const tableRulesEasyChemistry = Object.freeze(rules);\n","/*\n * Короткая форма таблицы отменена ИЮПАК в 1989 году.\n * Из современной иностранной литературы короткая форма исключена полностью,\n * вместо неё используется длинная форма, (Std)\n * однако, благодаря своей привычности и распространённости, она все ещё периодически встречается в российских справочниках и пособиях\n * https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D1%80%D0%BE%D1%82%D0%BA%D0%B0%D1%8F_%D1%84%D0%BE%D1%80%D0%BC%D0%B0_%D0%BF%D0%B5%D1%80%D0%B8%D0%BE%D0%B4%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B9_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B_%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%BE%D0%B2\n */\n/* eslint-disable no-param-reassign */\n\nimport { Lang } from \"../lang/Lang\";\nimport { categoryBlock, subGroup } from \"./tableCategories\";\nimport { TableRules, TCell } from \"./TableRules\";\n\nexport const tableRulesShort: TableRules = {\n  tables: [\n    { NCol: 11, NRow: 11, periodCols: 2, groupRows: 2 },\n    { NCol: 15, NRow: 2 },\n  ],\n  points: {\n    H: [0, 0],\n    He: [10, 0],\n    Ne: [10, 1],\n    Ar: [10, 2],\n    Cu: [0, 4],\n    Kr: [10, 4],\n    Ag: [0, 6],\n    Xe: [10, 6],\n    La: [0, 0, 1],\n    Hf: [3, 7],\n    Au: [0, 8],\n    Rn: [10, 8],\n    Ac: [0, 1, 1],\n    Rf: [3, 9],\n    Rg: [0, 10],\n  },\n  flLanAct: true,\n  notes: { La: [2, 7], Ac: [2, 9] },\n\n  category: categoryBlock,\n  categoryExt: [subGroup],\n  groupIds:\n    \"I:a;b,II:a;b,III:a;b,IV:a;b,V:a;b,VI:a;b,VII:a;b,::R,VIII:b:LR,::LR,:a:L\".split(\n      \",\"\n    ),\n  groupCls: \"chem-cell\",\n\n  drawGroups({ cells, actualTables, rules }) {\n    const tdef = actualTables[0]!;\n    const t0 = cells[0]!;\n\n    for (let i = 0; i < tdef.NCol; i++) {\n      const v = rules.groupIds![i]!.split(\":\");\n      const p = {\n        cls: rules.groupCls,\n        rowspan: 2,\n        text: `${v[0]}<div class=\"mentable-subgroup-hd\">`,\n      };\n      if (v.length > 1) {\n        const w = v[1]!.split(\";\");\n        if (w.length === 2)\n          p.text += `<span class=\"left\">${w[0]}</span><span class=\"right\">${w[1]}</span>`;\n        else p.text += w[0];\n      }\n      if (v.length > 2) {\n        if (v[2]!.indexOf(\"L\") >= 0) p.cls += \" noleft\";\n        if (v[2]!.indexOf(\"R\") >= 0) p.cls += \" noright\";\n      }\n\n      p.text += \"</div>\";\n      t0[tdef.y1 - 2]![i + tdef.x1] = p;\n      t0[tdef.y1 - 1]![i + tdef.x1] = { colspan: 0 };\n    }\n  },\n\n  drawPeriods({ cells, actualTables }) {\n    // var i,p,\n    let n = 1;\n    const tdef = actualTables[0]!;\n    const t0 = cells[0]!;\n    for (let i = 0; i < tdef.NRow; i++) {\n      const p: TCell =\n        // eslint-disable-next-line no-bitwise\n        i < 3 || i & 1\n          ? { text: String(n++), cls: \"period-id\" }\n          : { colspan: 0 };\n      if (p && i >= 3) p.rowspan = 2;\n      t0[tdef.y1 + i]![tdef.x1 - 2] = p;\n    }\n    for (let i = 0; i < tdef.NRow; i++)\n      t0[tdef.y1 + i]![tdef.x1 - 1] = { text: String(i + 1), cls: \"period-id\" };\n  },\n  post({ cells }) {\n    if (this.flGroups && this.flPeriods) {\n      cells[0]![0]![0] = {\n        text: `${Lang.tr(\"Group\")}→`,\n        cls: \"mentable-text period-id\",\n        colspan: 2,\n      };\n      cells[0]![0]![1] = { colspan: 0 };\n      cells[0]![1]![0] = {\n        text: Lang.tr(\"Period\"),\n        cls: \"mentable-text period-id\",\n      };\n      cells[0]![1]![1]! = {\n        text: Lang.tr(\"Row\"),\n        cls: \"mentable-text period-id\",\n      };\n    }\n  },\n  pre({ cells, actualTables }) {\n    // Разметка. Колонки 0-6,10 имеют границы со всех сторон, 7,8,9-только сверху и снизу\n    //  var a,i,\n    // row,\n    const t0 = cells[0]!;\n    const tdef = actualTables[0]!;\n    for (let j = 0; j < tdef.NRow; j++) {\n      const row = t0[j + tdef.y1]!;\n      for (let i = 0; i < tdef.NCol; i++) {\n        row[i + tdef.x1] =\n          i > 6 && i < 10 ? { cls: \"chem-row\" } : { cls: \"chem-cell\" };\n      }\n    }\n  },\n};\n","/**\n * IUPAC Periodic Table of the Elements\n * https://iupac.org/what-we-do/periodic-table-of-elements/\n */\nimport { fallingNumbers } from \"./fallingNumbers\";\nimport { categoryProps } from \"./tableCategories\";\nimport { TableRules } from \"./TableRules\";\n\nconst rules: TableRules = {\n  tables: [\n    { NCol: 18, NRow: 7 },\n    { NCol: 15, NRow: 2 },\n  ],\n  category: categoryProps,\n  points: {\n    He: [17, 0],\n    B: [12, 1],\n    Al: [12, 2],\n    La: [0, 0, 1],\n    Hf: [3, 5],\n    Ac: [0, 1, 1],\n    Rf: [3, 6],\n  },\n  notes: { La: [2, 5], Ac: [2, 6] },\n  drawGroups: fallingNumbers,\n  groupIds: [\n    \"1A\",\n    \"2A\",\n    \"3B\",\n    \"4B\",\n    \"5B\",\n    \"6B\",\n    \"7B\",\n    \"┌──\",\n    \"─8B─\",\n    \"──┐\",\n    \"1B\",\n    \"2B\",\n    \"3A\",\n    \"4A\",\n    \"5A\",\n    \"6A\",\n    \"7A\",\n    \"8A\",\n  ],\n  groupCls: \"group-id\",\n};\n\nexport const tableRulesStd = Object.freeze(rules);\n","import { fallingNumbers } from \"./fallingNumbers\";\nimport { categoryProps } from \"./tableCategories\";\nimport { TableRules } from \"./TableRules\";\n\nconst rules: TableRules = {\n  tables: [{ NCol: 32, NRow: 7, ofsX: 1, ofsY: 1, width: 33, height: 8 }],\n  category: categoryProps,\n  points: {\n    H: [0, 0],\n    He: [31, 0],\n    B: [26, 1],\n    Al: [26, 2],\n    Sc: [16, 3],\n    Y: [16, 4],\n  },\n  groupIds:\n    \"1A,2A,,,,,,,,,,,,,,,3B,4B,5B,6B,7B,┌──,8B,──┐,1B,2B,3A,4A,5A,6A,7A,8A\".split(\n      \",\"\n    ),\n  groupCls: \"group-id\",\n  drawGroups: fallingNumbers,\n};\n\nexport const tableRulesWide = Object.freeze(rules);\n","import { Lang } from \"../lang/Lang\";\nimport { PeriodicTable } from \"../core/PeriodicTable\";\nimport { ifDef } from \"../utils/ifDef\";\nimport { CellRender } from \"./CellRender\";\nimport { Category, TableConfigItemExt, TableRules, TCell } from \"./TableRules\";\nimport { tableRulesStd } from \"./TableRulesStd\";\nimport { drawTag } from \"../utils/xml/drawTag\";\n\nexport const drawPeriodicTable = (rules: TableRules = tableRulesStd) => {\n  const {\n    tables,\n    category,\n    categoryExt = [],\n    points,\n    notes,\n    cellFields,\n  } = rules;\n  const { cellRender = new CellRender(cellFields) } = rules;\n  const cells: TCell[][][] = [];\n  // Заготовка структкры\n  const actualTables: TableConfigItemExt[] = tables.map((srcItem, n) => {\n    const { NCol, NRow, ofsX = 0, ofsY = 0 } = srcItem;\n    const { width = NCol, height = NRow } = srcItem;\n    const tdef: TableConfigItemExt = {\n      ...srcItem,\n      width,\n      height,\n      ofsX,\n      ofsY,\n      w1: width,\n      h1: height,\n      x1: ofsX,\n      y1: ofsY,\n    };\n    if (n === 0) {\n      const { groupRows = 1, periodCols = 1 } = tdef;\n      if (rules.flGroups) {\n        tdef.y1 += groupRows;\n        tdef.h1 += groupRows;\n      }\n      if (rules.flPeriods) {\n        tdef.x1 += periodCols;\n        tdef.w1 += periodCols;\n      }\n    }\n    const row: TCell[][] = [];\n    for (let j = 0; j < tdef.h1; j++) {\n      row[j] = new Array<TCell>(tdef.w1);\n    }\n    cells[n] = row;\n    return tdef;\n  });\n  if (rules.pre) rules.pre({ cells, actualTables, rules });\n\n  // Развернуть свойства\n  const categories: Category[] = [\n    ...(category ? [category] : []),\n    ...categoryExt,\n  ];\n  const grpMaps = categories.map((curCat) => {\n    const catDict: Record<string, string> = {};\n    Object.entries(curCat).forEach(([catName, catValues]) => {\n      const list = Array.isArray(catValues) ? catValues : catValues.split(\",\");\n      list.forEach((catValue) => {\n        catDict[catValue] = catName;\n      });\n    });\n    return catDict;\n  });\n\n  // набор текущих значений для каждой группы свойств из списка grpMaps\n  let t = 0;\n  let tdef = actualTables[t]!;\n  let j = tdef.y1;\n  let i = tdef.x1;\n  const Ga = new Array(grpMaps.length);\n\n  PeriodicTable.elements.forEach((elem) => {\n    const { id } = elem;\n    ifDef(points[id], (pos) => {\n      t = pos[2] ?? 0;\n      tdef = actualTables[t]!;\n      i = pos[0] + tdef.x1;\n      j = pos[1] + tdef.y1;\n    });\n    let cls = \"chem-element\";\n    // перебираем все элементы grpMaps и достаём свойства, если они назначены на элемент\n    grpMaps.forEach((G, gm) => {\n      // очередная группа свойств\n      ifDef(G[id], (grp) => {\n        Ga[gm] = grp;\n      });\n      cls += ` ${Ga.join(\" \")}`;\n    });\n    cells[t]![j]![i] = { elem, cls };\n    if (++i === tdef.x1 + tdef.NCol) {\n      i = tdef.x1;\n      j++;\n    }\n  });\n\n  // Номера групп\n  if (rules.flGroups) {\n    if (rules.drawGroups) rules.drawGroups({ cells, actualTables, rules });\n    else\n      for (i = 0; i < tdef.NCol; i++)\n        cells[0]![tdef.y1 - 1]![tdef.x1 + i] = { text: String(i + 1) };\n  }\n\n  // Расставить номера периодов\n  tdef = actualTables[0]!;\n  if (rules.flPeriods) {\n    const { drawPeriods } = rules;\n    if (drawPeriods) {\n      drawPeriods({ cells, actualTables, rules });\n    } else {\n      for (i = 0; i < tdef.NRow; i++)\n        cells[0]![tdef.y1 + i]![tdef.x1 - 1] = {\n          text: String(i + 1),\n          cls: \"period-id\",\n        };\n    }\n  }\n\n  if (rules.post) rules.post({ cells, actualTables, rules });\n\n  // Подписи к лантаноидам и актиноидам\n  const LanActMap: Record<string, string> = {\n    La: `57-71<br>${Lang.tr(\"Lanthanides\")}`,\n    Ac: `89-103<br>${Lang.tr(\"Actinides\")}`,\n  };\n  if (rules.flLanAct && notes) {\n    tdef = actualTables[0]!;\n    Object.entries(notes).forEach(([id, pos]) => {\n      cells[0]![pos[1] + tdef.y1]![pos[0] + tdef.x1] = {\n        text: LanActMap[id],\n        cls: \"chem-cell mentable-text\",\n      };\n    });\n  }\n  // Безусловные подписи\n  ifDef(rules.hardNotes, (list) =>\n    list.forEach(({ text, x, y, tblN = 0, cls }) => {\n      const curTable = actualTables[tblN]!;\n      cells[tblN]![y + curTable.y1]![x + curTable.x1] = { text, cls };\n    })\n  );\n\n  // Финальный рендер\n  let s = \"\";\n  cells.forEach((curTable, n) => {\n    s +=\n      ifDef(rules.beginTable, (beginTable) => beginTable(n, rules)) ??\n      drawTag(\"table\", { class: rules.tableCls || \"mentable\" });\n    curTable.forEach((row) => {\n      s += \"<tr>\";\n      for (const c of row) {\n        if (!c) {\n          s += \"<td></td>\";\n        } else if (c.colspan !== 0) {\n          s += `<td class=\"${c.cls || \"chem-element\"}\"`;\n          if (c.colspan) s += ` colspan=\"${c.colspan}\"`;\n          if (c.rowspan) s += ` rowspan=\"${c.rowspan}\"`;\n          s += \">\";\n          if (c.elem) {\n            if (rules.elementBoxCls) {\n              s += drawTag(\"div\", { class: rules.elementBoxCls });\n            }\n            s += cellRender.draw(c.elem);\n            if (rules.elementBoxCls) {\n              s += \"</div>\";\n            }\n          } else if (c.text) s += c.text;\n          s += \"</td>\";\n        }\n      }\n      s += \"</tr>\";\n    });\n    s += \"</table>\";\n  });\n  return s;\n};\n","import { ParamsTableCallback } from \"./TableRules\";\n\n/**  Функция, выводящая номера из массива rules.groupIds над первой заполненной ячейкой\n */\nexport const fallingNumbers = ({\n  cells,\n  actualTables,\n  rules,\n}: ParamsTableCallback) => {\n  const t0 = cells[0]!;\n  const tdef = actualTables[0]!;\n  const X: number[] = [];\n  const Y: number[] = [];\n  let y: number;\n\n  for (let j = 0; j < tdef.NCol; j++) {\n    const x = tdef.x1 + j;\n    X.push(x);\n    // опускаемся по столбцу до последней незаполненной ячейки. первая всегда незаполнена. для H и He она же последняя.\n    y = tdef.y1;\n    while (y < t0.length && !t0[y]![x]) y++;\n    Y.push(y);\n    if (y < t0.length) {\n      t0[y - 1]![x] = { text: rules.groupIds?.[j] ?? \"\", cls: rules.groupCls };\n    }\n  }\n  // Объединение ячеек 7,8,9\n  y = Y[7]!;\n  if (\n    (rules.groupIds?.[8]?.indexOf(\"8B\") ?? -1) >= 0 &&\n    y < t0.length &&\n    y === Y[8] &&\n    Y[8] === Y[9]\n  ) {\n    const x = X[7] ?? 0;\n    y--;\n    t0[y]![x]!.text += t0[y]![x + 1]!.text! + t0[y]![x + 2]!.text!;\n    t0[y]![x]!.colspan = 3;\n    t0[y]![x + 1]!.colspan = 0;\n    t0[y]![x + 2]!.colspan = 0;\n  }\n};\n","import { PeriodicTable } from \"../core/PeriodicTable\";\nimport { ifDef } from \"../utils/ifDef\";\nimport { Lang } from \"../lang/Lang\";\nimport { TCategories } from \"./tableCategories\";\n\n// Поиск категории для элемента\nconst GrpCache = new Map<TCategories, Record<string, string>>();\n\nexport const findCategory = (\n  table: TCategories,\n  item: string,\n  locale?: string\n) => {\n  if (!GrpCache.has(table)) {\n    const dict: Record<string, string> = {};\n    GrpCache.set(table, dict);\n    const revMap = Object.entries(table).reduce(\n      (map, [categoryKey, pkList]) => {\n        pkList.split(\",\").forEach((id) => {\n          // eslint-disable-next-line no-param-reassign\n          map[id] = categoryKey;\n        });\n        return map;\n      },\n      {} as Record<string, string>\n    );\n    let curCategory = \"\";\n    PeriodicTable.elements.forEach(({ id }) => {\n      ifDef(revMap[id], (it) => {\n        curCategory = it;\n      });\n      dict[id] = curCategory;\n    });\n  }\n  let cat = GrpCache.get(table)![item] ?? \"\";\n  cat = cat.replace(/-/g, \" \").replace(/_/g, \"-\");\n  cat = Lang.tr(cat, {}, locale);\n  return cat;\n};\n","export type TCategories = Record<string, string>;\n\n// Распределение элементов по цветовым группам\n// по электронам\nexport const categoryBlock: TCategories = {\n  s_block: \"H,Na,K,Rb,Cs,Fr\",\n  p_block: \"B,Al,Ga,In,Tl,Nh\",\n  d_block: \"Sc,Y,Hf,Rf\",\n  f_block: \"La,Ac\",\n};\n\n// La and Ac in d-blocks\nexport const categoryBlockDLa: TCategories = {\n  s_block: \"H,Na,K,Rb,Cs,Fr\",\n  p_block: \"B,Al,Ga,In,Tl,Nh\",\n  d_block: \"Sc,Y,La,Hf,Ac,Rf\",\n  f_block: \"Ce\",\n  f2_block: \"Th\",\n};\n\n// по свойствам\nexport const categoryProps: TCategories = {\n  \"Alkali-metals\": \"Li,Na,K,Rb,Cs,Fr\",\n  \"Alkaline-earth-metals\": \"Be,Mg,Ca,Sr,Ba,Ra\",\n  Lanthanides: \"La\",\n  Actinides: \"Ac\",\n  \"Transition-metals\": \"Sc,Y,Hf,Rf,Cn\",\n  \"Post-transition-metals\": \"Al,Ga,In,Tl,Nh\",\n  Metalloids: \"B,Si,Ge,Sb\",\n  \"Other-nonmetals\": \"H,C,P,Se\",\n  Halogens: \"F,Cl,Br,I,At,Ts\",\n  \"Noble-gases\": \"He,Ne,Ar,Kr,Xe,Rn,Og\",\n  // 'Unknown-props': 'Mt'\n};\n\nexport const subGroup = {\n  subgr_a: \"H,Ga,In,Tl\",\n  subgr_b: \"Sc,Y,La,Ac\",\n};\n","import { ChemNodeItem } from \"../../core/ChemNodeItem\";\nimport { TextNode } from \"./TextNode\";\nimport { locateAtomNumber } from \"../../inspectors/locateAtomNumber\";\nimport { ChemK } from \"../../core/ChemK\";\nimport { ifDef } from \"../../utils/ifDef\";\n\nexport const addItemProps = (\n  obj: ChemNodeItem,\n  addItem: (node: TextNode) => void\n) => {\n  const { color } = obj;\n  if (obj.n.isSpecified())\n    addItem({\n      type: \"k\",\n      k: obj.n,\n      pos: \"RB\",\n      kType: \"item\",\n      color,\n    });\n  const rawAtomNum = obj.atomNum;\n  let atomMass: number | undefined;\n  if (typeof rawAtomNum === \"number\" || rawAtomNum === \"\") {\n    // Вывести двухэтажную конструкцию: масса/атомный номер слева от элемента\n    const atomNum = rawAtomNum === \"\" ? locateAtomNumber(obj) : rawAtomNum;\n    atomMass = obj.mass ?? 0;\n    if (atomNum !== undefined) {\n      addItem({\n        type: \"k\",\n        k: new ChemK(atomNum),\n        pos: \"LB\",\n        kType: \"item\",\n        color,\n      });\n    }\n  } else {\n    atomMass = ifDef(obj.mass, (it) => it);\n  }\n  if (atomMass !== undefined)\n    addItem({\n      type: \"k\",\n      k: new ChemK(atomMass),\n      pos: \"LT\",\n      kType: \"item\",\n      color,\n    });\n\n  if (obj.charge) {\n    addItem({\n      type: \"charge\",\n      charge: obj.charge,\n      color,\n      pos: \"T\",\n    });\n  }\n};\n","import { isLeftCoeff } from \"../../types/CoeffPos\";\nimport { ChemObj } from \"../../core/ChemObj\";\nimport { GroupType, TextNode } from \"./TextNode\";\nimport { addItemProps } from \"./addItemProps\";\nimport { createTextOp } from \"./createTextOp\";\nimport { splitRichText } from \"./splitRichText\";\nimport { correctBondsDirection } from \"./correctBondsDirection\";\n\n/* eslint no-param-reassign: \"off\" */\n\nexport const buildTextNodes = (srcExpr: ChemObj): TextNode => {\n  const rootNode: TextNode = { type: \"group\", groupType: \"expr\" };\n  const stack: [TextNode] | TextNode[] = [rootNode];\n\n  const addItemTo = (item: TextNode, owner: TextNode) => {\n    owner.items = owner.items ?? [];\n    owner.items.push(item);\n  };\n  const addItem = (item: TextNode) => addItemTo(item, stack[0]);\n  const pushLevel = (node: TextNode) => {\n    addItem(node);\n    stack.unshift(node);\n    return node;\n  };\n  const pushGroupLevel = (groupType?: GroupType) =>\n    pushLevel({ type: \"group\", groupType });\n  const popLevel = (): TextNode | undefined => stack.shift();\n\n  let prevEntity: \"agent\" | \"op\" | undefined;\n  let autoNode = false;\n  let firstItem: TextNode | undefined;\n  let lastItem: TextNode | undefined;\n  let atomColor: string | undefined;\n  let itemColor: string | undefined;\n\n  const addSpace = (curEntityType: \"agent\" | \"op\") => {\n    if (prevEntity) {\n      const node: TextNode = {\n        type: \"space\",\n        spaceType: \"agentOp\",\n      };\n      if (prevEntity === \"agent\" && curEntityType === \"agent\") {\n        node.spaceType = \"agentAgent\";\n      } else if (prevEntity === \"op\" && curEntityType === \"op\") {\n        node.spaceType = \"opOp\";\n      }\n      addItem(node);\n    }\n    prevEntity = curEntityType;\n  };\n\n  srcExpr.walk({\n    agentPre(obj) {\n      addSpace(\"agent\");\n      pushGroupLevel(\"agent\");\n      if (obj.n.isSpecified())\n        addItem({\n          type: \"k\",\n          k: obj.n,\n          kType: \"agent\",\n          color: obj.n.color,\n        });\n    },\n    agentPost() {\n      correctBondsDirection(stack[0]);\n      popLevel();\n    },\n    atom(obj) {\n      if (autoNode) return;\n      addItem({\n        type: \"atom\",\n        atom: obj,\n        color: atomColor ?? itemColor,\n      });\n    },\n    bond(obj) {\n      addItem({ type: \"bond\", bond: obj, color: obj.color });\n    },\n    bracketBegin(obj) {\n      pushLevel({\n        type: \"brackets\",\n        color: obj.color,\n      });\n      pushGroupLevel();\n      addItem({\n        type: \"bracket\",\n        text: obj.text,\n        begin: true,\n        color: obj.color,\n      });\n    },\n    bracketEnd(obj) {\n      addItem({\n        type: \"bracket\",\n        text: obj.text,\n        begin: false,\n        color: obj.color,\n      });\n      correctBondsDirection(stack[0]);\n      popLevel();\n      if (obj.n.isSpecified())\n        addItem({\n          type: \"k\",\n          k: obj.n,\n          kType: \"bracket\",\n          pos: isLeftCoeff(obj.n.pos) ? \"LB\" : \"RB\",\n        });\n      if (obj.charge)\n        addItem({\n          type: \"charge\",\n          charge: obj.charge,\n          pos: obj.charge.isLeft ? \"LT\" : \"RT\",\n        });\n      popLevel();\n    },\n    comma() {\n      addItem({ type: \"comma\" });\n    },\n    comment(obj) {\n      addItem({\n        type: \"comment\",\n        comment: obj,\n        items: [splitRichText(obj.text, itemColor)],\n        color: itemColor,\n      });\n    },\n    custom(obj) {\n      addItem({\n        type: \"custom\",\n        custom: obj,\n        items: [splitRichText(obj.text, itemColor)],\n        color: itemColor,\n      });\n    },\n    itemPre(obj) {\n      if (autoNode) return;\n      itemColor = obj.color;\n      atomColor = obj.atomColor;\n      const itemNode = pushLevel({\n        type: \"item\",\n        item: obj,\n        color: obj.color,\n      });\n      firstItem = firstItem || itemNode;\n      lastItem = itemNode;\n    },\n    itemPost(obj) {\n      if (autoNode) return;\n      addItemProps(obj, addItem);\n      popLevel();\n    },\n    mul(obj) {\n      if (!obj.isFirst)\n        addItem({\n          type: \"mul\",\n          color: obj.color,\n        });\n      pushGroupLevel();\n      if (obj.n.isSpecified()) {\n        addItem({ type: \"k\", k: obj.n, kType: \"mul\" });\n      }\n    },\n    mulEnd() {\n      popLevel();\n    },\n    nodePre(obj) {\n      firstItem = undefined;\n      lastItem = undefined;\n      autoNode = obj.autoMode;\n      pushGroupLevel(\"node\");\n    },\n    nodePost(obj) {\n      popLevel();\n      if (obj.charge) {\n        const { isLeft } = obj.charge;\n        const itemNode = isLeft ? firstItem : lastItem;\n        if (itemNode) {\n          addItemTo(\n            {\n              type: \"charge\",\n              charge: obj.charge,\n              pos: isLeft ? \"LT\" : \"RT\",\n            },\n            itemNode\n          );\n        }\n      }\n    },\n    operation(obj) {\n      addSpace(\"op\");\n      addItem(createTextOp(obj));\n    },\n\n    radical(obj) {\n      addItem({\n        type: \"radical\",\n        radical: obj,\n        color: itemColor,\n      });\n    },\n  });\n\n  return rootNode;\n};\n","import { TextNode } from \"./TextNode\";\n\nexport const cloneTextNode = (node: TextNode): TextNode => ({\n  ...node,\n  items: node.items?.map(cloneTextNode),\n});\n","import { TextNode } from \"./TextNode\";\n\nexport const correctBondsDirection = (\n  groupNode: TextNode | undefined\n): void => {\n  if (groupNode?.type !== \"group\") return;\n  const { items } = groupNode;\n  if (!items?.some((node) => node.type === \"bond\" && node.bond.isNeg)) {\n    return;\n  }\n  items.reverse();\n  const n = items.length - 1;\n  if (n > 0 && items[0]?.type === \"bracket\" && items[n]?.type === \"bracket\") {\n    const tmp = items[0]!;\n    items[0] = items[n]!;\n    items[n] = tmp;\n  }\n};\n","import { ChemOp } from \"../../core/ChemOp\";\nimport { TextNode } from \"./TextNode\";\nimport { splitRichText } from \"./splitRichText\";\n\nexport const createTextOp = (op: ChemOp): TextNode => {\n  const opItem: TextNode = {\n    type: \"op\",\n    op,\n    color: op.color,\n  };\n  const { commentPre, commentPost } = op;\n  if (!commentPre && !commentPost) {\n    return opItem;\n  }\n  const items: TextNode[] = [opItem];\n  const colItem: TextNode = {\n    type: \"column\",\n    columnType: \"op\",\n    color: op.color,\n    items,\n  };\n  if (commentPre)\n    items.push({\n      ...splitRichText(commentPre.text, op.color),\n      pos: \"T\",\n    });\n  if (commentPost)\n    items.push({\n      ...splitRichText(commentPost.text, op.color),\n      pos: \"B\",\n    });\n  return colItem;\n};\n","export const dictKeys = (dict: Record<string, unknown>): string =>\n  Object.entries(dict)\n    .filter(([, value]) => value !== undefined)\n    .map(([key]) => key)\n    .sort()\n    .join(\",\");\n","export * from \"./buildTextNodes\";\nexport * from \"./TextNode\";\n","/* eslint no-param-reassign: \"off\" */\n/* eslint prefer-destructuring: \"off\" */\n\nexport const optimizeColors = <T extends { color?: string }>(\n  node: T,\n  getList: (owner: T) => T[] | undefined\n) => {\n  const list = getList(node);\n  if (!list) return;\n  const { color: nodeColor } = node;\n  list.forEach((it) => optimizeColors(it, getList));\n\n  const subColors = new Set<string>();\n  list.forEach((it) => subColors.add(it.color ?? \"\"));\n  const aColors = Array.from(subColors).sort();\n  if (aColors.length === 1 && aColors[0]) {\n    // Если все подчинённые элементы имеют одинаковый и непустой цвет, то он становится цветом узла, а из элементов убирается\n    node.color = aColors[0];\n    list.forEach((it) => {\n      delete it.color;\n    });\n  } else if (aColors.length === 2 && !aColors[0] && aColors[1] === node.color) {\n    // Если одни подчиненные имеют такой же цвет, как узел, а у других цевет не указан, то просто убрать цвет у подчиненных\n    list.forEach((it) => {\n      delete it.color;\n    });\n  } else if (nodeColor && subColors.has(nodeColor)) {\n    // Если есть элементы с таким же цветом как узел, то убрать цвет только у них\n    list.forEach((it) => {\n      if (it.color === nodeColor) {\n        delete it.color;\n      }\n    });\n  }\n};\n","import { TextNode } from \"./TextNode\";\n\ntype ColKey = \"C\" | \"T\" | \"B\";\n\nexport const splitColumn = (nodes: TextNode[] = []) => {\n  const dict: Partial<Record<ColKey, TextNode[]>> = {};\n  nodes.forEach((it) => {\n    const { pos } = it;\n    const key: ColKey = pos === \"T\" || pos === \"B\" ? pos : \"C\";\n    dict[key] = [...(dict[key] ?? []), it];\n  });\n  return dict;\n};\n","import { MarkupChunk, parseMarkup } from \"../../utils/markup\";\nimport { TextNode } from \"./TextNode\";\n\nexport const splitRichText = (\n  srcText: string,\n  textColor: string | undefined\n): TextNode => {\n  const onChunk = (\n    chunk: MarkupChunk | string,\n    color: string | undefined\n  ): TextNode => {\n    if (typeof chunk === \"string\") {\n      return { type: \"text\", text: chunk, color };\n    }\n    const locColor = chunk.color ?? color;\n    const res: TextNode = {\n      type: \"richText\",\n      items: chunk.chunks.map((c) => onChunk(c, locColor)),\n      color: locColor,\n    };\n    if (chunk.type === \"sub\") {\n      res.pos = \"RB\";\n    } else if (chunk.type === \"sup\") {\n      res.pos = \"RT\";\n    }\n    return res;\n  };\n  return onChunk(groupScripted(parseMarkup(srcText)), textColor);\n};\n\n/**\n * H2SO4 -> <rt>\n *   <text>H</text>\n *   <rt pos=RB><text>2</text></rt>\n *\n *   <text>S</text>\n *\n *   <text>O</text>\n *   <rt pos=RB><text>4</text>\n * </rt>\n *                ==>\n * <rt>\n *   <rt>\n *     <text>H</text>\n *     <rt pos=RB><text>2</text></rt>\n *   </rt>\n *   <text>S</text>\n *   <rt>\n *     <text>O</text>\n *     <rt pos=RB><text>4</text></rt>\n *   </rt>\n * </rt>\n * Такая структура позволяет получить группы с индексами. н.р. <msub><mi>H</mi><mn>2</mn></msub>\n * @param chunk\n */\nconst groupScripted = (chunk: MarkupChunk): MarkupChunk => {\n  const { chunks: ungrouped } = chunk;\n  const grouped: (MarkupChunk | string)[][] | [(MarkupChunk | string)[]] = [[]];\n  ungrouped.forEach((subChunk) => {\n    if (\n      typeof subChunk === \"string\" ||\n      (subChunk.type !== \"sub\" && subChunk.type !== \"sup\")\n    ) {\n      grouped.unshift([]);\n    }\n    grouped[0].push(subChunk);\n  });\n  grouped.reverse();\n  const optimized: (MarkupChunk | string)[] = grouped\n    .filter((group) => group.length > 0)\n    .map((group) => {\n      if (group.length === 1) return group[0]!;\n      return {\n        type: \"\",\n        chunks: group,\n      };\n    });\n  return { ...chunk, chunks: optimized };\n};\n","import { ifDef } from \"../../utils/ifDef\";\nimport { TextNode, TextPosition } from \"./TextNode\";\n\nexport type ScriptKey = \"C\" | \"RT\" | \"RB\" | \"LT\" | \"LB\";\nconst scriptKeys: Readonly<Record<TextPosition, ScriptKey>> = {\n  C: \"C\",\n  T: \"C\",\n  B: \"C\",\n  LT: \"LT\",\n  RT: \"RT\",\n  LB: \"LB\",\n  RB: \"RB\",\n};\n\nexport const splitScripts = (nodes: TextNode[] = []) => {\n  const dict: Partial<Record<ScriptKey, TextNode[]>> = {};\n  nodes.forEach((it) => {\n    const { pos } = it;\n    const key: ScriptKey = ifDef(pos, (p) => scriptKeys[p]) ?? \"C\";\n    dict[key] = [...(dict[key] ?? []), it];\n  });\n  return dict;\n};\n","export type HtmlRichClass =\n  | \"agent\"\n  | \"agent-k\"\n  | \"arrow-bidir\"\n  | \"arrow-bkwd\"\n  | \"arrow-both\"\n  | \"arrow-both-left\"\n  | \"arrow-both-right\"\n  | \"arrow-fwd\"\n  | \"charge\"\n  | \"expr\"\n  | \"has-over\"\n  | \"minus\"\n  | \"mul\"\n  | \"node-item\"\n  | \"op\"\n  | \"op-arrow\"\n  | \"op-both\"\n  | \"op-code\"\n  | \"op-comment\"\n  | \"op-footer\"\n  | \"op-head\"\n  | \"over\"\n  | \"supsub\"\n  | \"supsub-left\"\n  | \"symbols\";\n\nexport const htmlRichCls = (clsCode: HtmlRichClass | HtmlRichClass[]): string =>\n  (Array.isArray(clsCode) ? clsCode : [clsCode])\n    .map((c) => `cch-${c}`)\n    .join(\" \");\n","import { TextNode } from \"../buildTextNodes\";\nimport { cloneTextNode } from \"../buildTextNodes/cloneTextNode\";\nimport { XmlNode } from \"../xmlNode/XmlNode\";\nimport { createHtmlRichNodes, CtxHtmlRich } from \"./createHtmlRichNodes\";\nimport { HtmlRichMap } from \"./HtmlRichMap\";\nimport { OptionsHtmlRich } from \"./OptionsHtmlRich\";\n\nexport type ResultHtmlRich = {\n  nodes: XmlNode[] | undefined;\n  srcMap?: HtmlRichMap;\n};\n\nexport const buildHtmlRich = (\n  srcNode: TextNode,\n  options?: OptionsHtmlRich\n): ResultHtmlRich => {\n  const rootNode = cloneTextNode(srcNode);\n  // optimizeColors(rootNode, (n) => Array.isArray(n.items) ? n.items : undefined);\n\n  const ctx: CtxHtmlRich = { options };\n  if (options?.srcMap) {\n    ctx.srcMap = {};\n  }\n  const nodes = createHtmlRichNodes(rootNode, ctx);\n  // v-- stack overflow\n  // nodes.forEach(it => optimizeColors(it, n => Array.isArray(it.content) ? it.content : undefined));\n  const res: ResultHtmlRich = { nodes };\n  if (ctx.srcMap) res.srcMap = ctx.srcMap;\n  return res;\n};\n","import { XmlAttrs } from \"../../utils/xml/xmlTypes\";\nimport { ChemOp } from \"../../core/ChemOp\";\nimport { TextNode } from \"../buildTextNodes\";\nimport { XmlNode } from \"../xmlNode/XmlNode\";\nimport { CtxHtmlRich } from \"./createHtmlRichNodes\";\nimport { HtmlRichClass } from \"./HtmlRichClasses\";\nimport { makeCchTag } from \"./makeCchTag\";\n\n// .cch-op tag\nexport const cchOperation = (\n  ctx: CtxHtmlRich,\n  srcNode: TextNode,\n  op: ChemOp\n): XmlNode => {\n  const arrow = cchArrowTag(ctx, srcNode, op);\n  const cls: HtmlRichClass[] = [\"op\"];\n  const arrows: XmlNode[] = [];\n  if (arrow) {\n    cls.push(\"op-arrow\");\n    arrows.push(arrow);\n  }\n  return makeCchTag({\n    ctx,\n    srcNode,\n    cls,\n    attrs: { \"data-op\": op.srcText },\n    content: [\n      ...arrows,\n      makeCchTag({\n        ctx,\n        srcNode: undefined,\n        cls: \"op-code\",\n        content: op.dstText,\n      }),\n    ],\n  });\n};\n\nconst cchArrowTag = (\n  ctx: CtxHtmlRich,\n  srcNode: TextNode,\n  op: ChemOp\n): XmlNode | undefined => {\n  const { srcText } = op;\n  if (srcText === \"-->\" || srcText === \"-->\") {\n    return longRightArrow(ctx);\n  }\n  if (srcText === \"<--\" || srcText === \"<|--\") {\n    return longLeftArrow(ctx);\n  }\n  if (srcText === \"<==>\") {\n    return makeCchTag({\n      ctx,\n      srcNode,\n      cls: \"arrow-both\",\n      content: [bothArrowsLeft(ctx), bothArrowsRight(ctx)],\n    });\n  }\n  if (srcText === \"<-->\" || srcText === \"<|--|>\") {\n    return makeCchTag({\n      ctx,\n      srcNode,\n      cls: [\"arrow-bidir\"],\n      content: [longLeftArrow(ctx), longRightArrow(ctx)],\n    });\n  }\n  return undefined;\n};\n\nconst figure = ({\n  ctx,\n  width,\n  height,\n  d,\n  cls,\n}: {\n  ctx: CtxHtmlRich;\n  width: number;\n  height: number;\n  d: string;\n  cls: HtmlRichClass;\n}): XmlNode => {\n  const attrs: XmlAttrs = {\n    width: `${width / 1000}em`,\n    height: `${height / 1000}em`,\n    viewBox: `0 0 ${width} ${height}`,\n    preserveAspectRatio: \"xMaxYMin slice\",\n    fill: \"currentColor\",\n  };\n  return makeCchTag({\n    ctx,\n    srcNode: undefined,\n    cls,\n    content: [\n      {\n        tag: \"svg\",\n        attrs,\n        content: [\n          {\n            tag: \"path\",\n            attrs: { d },\n          },\n        ],\n      },\n    ],\n  });\n};\n\nconst longRightArrow = (ctx: CtxHtmlRich): XmlNode =>\n  figure({\n    ctx,\n    cls: \"arrow-fwd\",\n    width: 400000,\n    height: 522,\n    d: `M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n  11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n  39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n  151.7 139 205zm0 0v40h399900v-40z`,\n  });\n\nconst longLeftArrow = (ctx: CtxHtmlRich): XmlNode =>\n  figure({\n    ctx,\n    width: 400000,\n    height: 522,\n    cls: \"arrow-bkwd\",\n    d: `M400000 241H110l3-3c68.7-52.7 113.7-120\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\n l-3-3h399890zM100 241v40h399900v-40z`,\n  });\n\nconst bothArrowsLeft = (ctx: CtxHtmlRich): XmlNode =>\n  figure({\n    ctx,\n    width: 400000,\n    height: 901,\n    cls: \"arrow-both-left\",\n    d: `M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z`,\n  });\n\nconst bothArrowsRight = (ctx: CtxHtmlRich): XmlNode =>\n  figure({\n    ctx,\n    width: 400000,\n    height: 901,\n    cls: \"arrow-both-right\",\n    d: `M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\n  -27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\n  13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\n  -84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\n  -119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n  -12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n  151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z`,\n  });\n","import { addAll } from \"../../utils/addAll\";\nimport { TextNode } from \"../buildTextNodes\";\nimport { splitColumn } from \"../buildTextNodes/splitColumn\";\nimport { splitScripts } from \"../buildTextNodes/splitScripts\";\nimport { XmlNode } from \"../xmlNode/XmlNode\";\nimport { HtmlRichClass, htmlRichCls } from \"./HtmlRichClasses\";\nimport { HtmlRichMap } from \"./HtmlRichMap\";\nimport { OptionsHtmlRich } from \"./OptionsHtmlRich\";\nimport { addClassToXmlNode } from \"../xmlNode/addClassToXmlNode\";\nimport { makeCchTag } from \"./makeCchTag\";\nimport { cchOperation } from \"./cchOperation\";\nimport { textInsideTag } from \"../../utils/xml/textInsideTag\";\n\n/*\n Приняты следующие допущения.\n Агент.\n - все вложенные конструкции (узлы и скобки) раскрываются в плоский список элементов\n - не предполагается наличие подстрочных индексов\n - надстрочными индексами считаются только степени окисления\n - если есть хотя бы один надстрочный индекс, то у сверху резервируется padding,\n   а сами индексы выводятся при помощи position:absolute. \n   padding нужен, чтобы они не вылезали за границы формулы.\n*/\n\nexport type CtxHtmlRich = {\n  options?: OptionsHtmlRich;\n  srcMap?: HtmlRichMap;\n};\n\nexport const createHtmlRichNodes = (\n  srcNode: TextNode,\n  ctx: CtxHtmlRich\n): XmlNode[] => {\n  const textTag = (content: string, cls?: HtmlRichClass) => [\n    makeCchTag({ ctx, srcNode, content, cls }),\n  ];\n  switch (srcNode.type) {\n    case \"atom\":\n      return textTag(srcNode.atom.id);\n    case \"bond\":\n      return textTag(bondMap[srcNode.bond.tx] ?? srcNode.bond.tx);\n    case \"bracket\":\n      return textTag(srcNode.text);\n    case \"brackets\":\n      return makeScripted(srcNode, ctx, (nodes) => nodesList(nodes, ctx));\n    case \"charge\":\n      return makeCharge(srcNode, srcNode.charge.text, ctx);\n    case \"column\":\n      if (srcNode.columnType === \"op\") return makeComplexOp(srcNode, ctx);\n      return [];\n    case \"comma\":\n      return textTag(\",\");\n    case \"comment\":\n      return makeRichText(srcNode, ctx);\n    case \"custom\":\n      return [\n        makeCchTag({\n          ctx,\n          srcNode,\n          cls: \"symbols\",\n          content: nodesList(srcNode.items, ctx),\n        }),\n      ];\n    case \"group\":\n      if (srcNode.groupType === \"node\" || !srcNode.groupType) {\n        return nodesList(srcNode.items, ctx);\n      }\n      return makeGroup(srcNode, srcNode.groupType, ctx);\n    case \"item\":\n      return makeItem(srcNode, ctx);\n    case \"k\":\n      return textTag(\n        srcNode.k.toString(),\n        srcNode.kType === \"agent\" ? \"agent-k\" : undefined\n      );\n    case \"mul\":\n      return textTag(\"∙\", \"mul\");\n    case \"op\":\n      return [cchOperation(ctx, srcNode, srcNode.op)];\n    case \"radical\":\n      return textTag(srcNode.radical.label);\n    case \"richText\":\n      return makeRichText(srcNode, ctx);\n    case \"space\":\n      return []; // implemented by gap in .cch-expr\n    case \"text\":\n      return textTag(textInsideTag(srcNode.text));\n    default:\n      break;\n  }\n  return [];\n};\n\nconst bondMap: Record<string, string> = {\n  \"-\": \"–\",\n};\n\nconst nodesList = (\n  items: TextNode[] | undefined,\n  ctx: CtxHtmlRich\n): XmlNode[] =>\n  (items ?? []).map((it) => createHtmlRichNodes(it, ctx)).flatMap((it) => it);\n\nconst hasOver = (srcNode: TextNode): boolean => {\n  if (srcNode.type === \"item\") {\n    return (srcNode.items ?? []).some((it) => it.pos === \"T\");\n  }\n  return (srcNode.items ?? []).some(hasOver);\n};\n\nconst makeGroup = (\n  srcNode: TextNode,\n  groupType: string | undefined,\n  ctx: CtxHtmlRich\n): XmlNode[] => {\n  let cls: HtmlRichClass | HtmlRichClass[] | undefined;\n  if (groupType === \"expr\") {\n    cls = \"expr\";\n  } else if (groupType === \"agent\") {\n    cls = [\"agent\"];\n    if (hasOver(srcNode)) cls.push(\"has-over\");\n  }\n  return [\n    makeCchTag({\n      ctx,\n      srcNode,\n      cls,\n      content: () => nodesList(srcNode.items, ctx),\n    }),\n  ];\n};\n\nconst optionalGroup = (\n  list: TextNode[] | undefined,\n  ctx: CtxHtmlRich,\n  cls?: HtmlRichClass | HtmlRichClass[]\n): XmlNode => {\n  let tag: XmlNode | undefined;\n  if (list?.length === 1) {\n    const n = nodesList(list, ctx);\n    if (n.length === 1) tag = n[0]!;\n  }\n  if (!tag) {\n    tag = makeCchTag({\n      ctx,\n      srcNode: undefined,\n      content: () => nodesList(list, ctx),\n    });\n  }\n  if (cls) {\n    addClassToXmlNode(tag, htmlRichCls(cls));\n  }\n  return tag;\n};\n\nconst makeItem = (srcNode: TextNode, ctx: CtxHtmlRich): XmlNode[] => {\n  // Если нужно оптимизировать количество тегов, то конечно лучше выдавать result\n  // Но если нужно иметь возможность при наведении курсора находить элемент узла, то нужен дополнительный тег\n  const content = () =>\n    makeScripted(srcNode, ctx, (items) => makeColumn(splitColumn(items), ctx));\n  if (!ctx.srcMap) {\n    return content();\n  }\n  return [\n    makeCchTag({\n      ctx,\n      srcNode,\n      content,\n      cls: \"node-item\",\n    }),\n  ];\n};\n\nconst makeScripted = (\n  srcNode: TextNode,\n  ctx: CtxHtmlRich,\n  makeCenter: (items: TextNode[]) => XmlNode[]\n): XmlNode[] => {\n  const { items = [] } = srcNode;\n  const result: XmlNode[] = [];\n  const scr = splitScripts(items);\n  const addScripts = (\n    top: TextNode[] | undefined,\n    bottom: TextNode[] | undefined,\n    left: boolean\n  ) => {\n    result.push(\n      makeCchTag({\n        ctx,\n        srcNode: undefined,\n        cls: left ? [\"supsub\", \"supsub-left\"] : \"supsub\",\n        content: () => [optionalGroup(top, ctx), optionalGroup(bottom, ctx)],\n      })\n    );\n  };\n  if (scr.LT || scr.LB) addScripts(scr.LT, scr.LB, true);\n  if (scr.C) {\n    addAll(result, makeCenter(scr.C));\n  }\n  if (scr.RT || scr.RB) addScripts(scr.RT, scr.RB, false);\n  return result;\n};\n\nconst makeColumn = (\n  col: ReturnType<typeof splitColumn>,\n  ctx: CtxHtmlRich\n): XmlNode[] => {\n  if (!col.T && !col.B) {\n    return nodesList(col.C, ctx);\n  }\n  const colItems: XmlNode[] = [optionalGroup(col.C, ctx)];\n  let cls: HtmlRichClass | undefined;\n  if (col.T) {\n    cls = \"over\";\n    colItems.push(optionalGroup(col.T, ctx));\n  }\n  const box = makeCchTag({\n    ctx,\n    srcNode: undefined,\n    cls,\n    content: colItems,\n  });\n  return [box];\n};\n\nconst makeCharge = (\n  srcNode: TextNode,\n  chargeText: string,\n  ctx: CtxHtmlRich\n): XmlNode[] => {\n  const create = (value: string) => {\n    if (value === \"-\") {\n      return makeCchTag({\n        ctx,\n        srcNode: undefined,\n        cls: \"minus\",\n        content: \"–\",\n      });\n    }\n    return makeCchTag({ ctx, content: value, srcNode: undefined });\n  };\n  return [\n    makeCchTag({\n      ctx,\n      srcNode,\n      cls: \"charge\",\n      content: chargeText.includes(\"-\")\n        ? () => splitChargeText(chargeText, create)\n        : chargeText,\n    }),\n  ];\n};\n\nconst splitChargeText = (\n  text: string,\n  create: (value: string) => XmlNode\n): XmlNode[] =>\n  text\n    .split(/(-)/)\n    .filter((s) => !!s)\n    .map(create);\n\nconst makeRichText = (srcNode: TextNode, ctx: CtxHtmlRich): XmlNode[] => {\n  const scr = splitScripts(srcNode.items ?? []);\n  if (!scr.RB && !scr.RT) {\n    return nodesList(scr.C, ctx);\n  }\n  return [\n    makeCchTag({\n      ctx,\n      srcNode,\n      cls: \"symbols\",\n      content: () => [\n        ...nodesList(scr.C, ctx),\n        makeCchTag({\n          ctx,\n          srcNode: undefined,\n          cls: \"supsub\",\n          content: () => [\n            optionalGroup(scr.RT, ctx),\n            optionalGroup(scr.RB, ctx),\n          ],\n        }),\n      ],\n    }),\n  ];\n};\n\nconst opComment = (ctx: CtxHtmlRich, items: TextNode[]): XmlNode =>\n  makeCchTag({\n    ctx,\n    srcNode: undefined,\n    cls: \"op-comment\",\n    content: () => nodesList(items, ctx),\n  });\n\nconst opContainer = (\n  ctx: CtxHtmlRich,\n  srcNode: TextNode,\n  cls: HtmlRichClass,\n  content: () => XmlNode[]\n): XmlNode[] => [makeCchTag({ ctx, srcNode, cls, content })];\n\nconst makeComplexOp = (srcNode: TextNode, ctx: CtxHtmlRich): XmlNode[] => {\n  const { C: center, T: top, B: bottom } = splitColumn(srcNode.items ?? []);\n  const opCode = (): XmlNode => optionalGroup(center, ctx, \"op-code\");\n  if (top && bottom) {\n    return opContainer(ctx, srcNode, \"op-both\", () => [\n      opComment(ctx, top),\n      opCode(),\n      opComment(ctx, bottom),\n    ]);\n  }\n  if (top) {\n    return opContainer(ctx, srcNode, \"op-head\", () => [\n      opComment(ctx, top),\n      opCode(),\n    ]);\n  }\n  if (bottom) {\n    return opContainer(ctx, srcNode, \"op-footer\", () => [\n      opCode(),\n      opComment(ctx, bottom),\n    ]);\n  }\n  return [];\n};\n","import { XmlAttrs } from \"../../utils/xml/xmlTypes\";\nimport { TextNode } from \"../buildTextNodes\";\nimport { XmlNode } from \"../xmlNode/XmlNode\";\nimport { CtxHtmlRich } from \"./createHtmlRichNodes\";\nimport { HtmlRichClass, htmlRichCls } from \"./HtmlRichClasses\";\n\nexport const makeCchTag = (p: {\n  ctx: CtxHtmlRich;\n  srcNode: TextNode | undefined;\n  cls?: HtmlRichClass | HtmlRichClass[];\n  attrs?: XmlAttrs;\n  content?: XmlNode[\"content\"] | (() => XmlNode[\"content\"]);\n}): XmlNode => {\n  const { content, ctx, srcNode, cls } = p;\n  const node: XmlNode = {\n    tag: \"span\",\n  };\n  if (p.attrs) node.attrs = p.attrs;\n  if (srcNode?.color) {\n    node.color = srcNode.color;\n  }\n  const setAttr = (name: string, value: string) => {\n    let { attrs } = node;\n    if (!attrs) {\n      attrs = {};\n      node.attrs = attrs;\n    }\n    attrs[name] = value;\n  };\n  if (ctx.options?.idGen) {\n    const id = ctx.options.idGen(srcNode);\n    if (id) {\n      setAttr(\"id\", id);\n      if (ctx.srcMap && srcNode) {\n        ctx.srcMap[id] = { txtNode: srcNode };\n      }\n    }\n  }\n  if (cls) {\n    setAttr(\"class\", htmlRichCls(cls));\n  }\n  if (content) {\n    node.content = typeof content === \"function\" ? content() : content;\n  }\n  return node;\n};\n","import { XmlAttrs } from \"../../utils/xml/xmlTypes\";\n\nexport type MathMLOptions = {\n  namespace?: boolean | string;\n};\n\nexport const mathMLRootAttrs = (options?: MathMLOptions): XmlAttrs => {\n  const res: XmlAttrs = {};\n  let ns = options?.namespace;\n  if (ns === undefined || ns === true)\n    ns = \"http://www.w3.org/1998/Math/MathML\";\n  if (ns) {\n    res.xmlns = ns;\n  }\n  return res;\n};\n","import { ifDef } from \"../../utils/ifDef\";\nimport { TextNode } from \"../buildTextNodes/TextNode\";\nimport { optimizeXmlColors } from \"../xmlNode/optimizeXmlColors\";\nimport { XmlNode } from \"../xmlNode/XmlNode\";\nimport { createMathMLNode } from \"./createMathMLNode\";\nimport { CtxCreateMathMLNode } from \"./CtxCreateMathMLNode\";\nimport { MathMLOptions, mathMLRootAttrs } from \"./MathMLOptions\";\n\nexport const buildMathML = (\n  rootNode: TextNode,\n  options?: MathMLOptions\n): XmlNode => {\n  const ctx: CtxCreateMathMLNode = {};\n  const dstNode: XmlNode = {\n    tag: \"math\",\n    attrs: mathMLRootAttrs(options),\n    content: ifDef(createMathMLNode(rootNode, ctx), (it) => [it]),\n  };\n  optimizeXmlColors(dstNode);\n  return dstNode;\n};\n","import { textInsideTag } from \"../../utils/xml/textInsideTag\";\nimport { splitColumn } from \"../buildTextNodes/splitColumn\";\nimport { TextNode } from \"../buildTextNodes/TextNode\";\nimport { FnNodeToXml } from \"../xmlNode/FnNodeToXml\";\nimport { XmlNode } from \"../xmlNode/XmlNode\";\nimport { CtxCreateMathMLNode } from \"./CtxCreateMathMLNode\";\nimport { mathColumn } from \"./utils/mathColumn\";\nimport { mathItem } from \"./utils/mathItem\";\nimport { mathOptRow } from \"./utils/mathOptRow\";\nimport { mathRichText } from \"./utils/mathRichText\";\nimport { mathScripted } from \"./utils/mathScripted\";\nimport { mathText } from \"./utils/mathText\";\nimport { onNodeItem } from \"./utils/onNodeItem\";\n\nconst customNode = (\n  srcNode: TextNode,\n  ctx: CtxCreateMathMLNode\n): XmlNode | undefined => {\n  // в отличие от comment, тут основной тег mi\n  const customCtx = {\n    ...ctx,\n    textMode: \"custom\",\n  } satisfies CtxCreateMathMLNode;\n  return mathOptRow(srcNode.items ?? [], (node: TextNode) =>\n    createMathMLNode(node, customCtx)\n  );\n};\n\nexport const createMathMLNode = (\n  srcNode: TextNode,\n  ctx: CtxCreateMathMLNode\n): XmlNode | undefined => {\n  let dstNode: XmlNode | undefined;\n  const create: FnNodeToXml = (node: TextNode) => createMathMLNode(node, ctx);\n  const { color } = srcNode;\n  switch (srcNode.type) {\n    case \"atom\":\n      dstNode = mathItem(srcNode.atom.id, color);\n      break;\n    case \"charge\":\n      dstNode = mathText(\n        { ...ctx, textMode: \"charge\" },\n        srcNode.charge.text,\n        color\n      );\n      break;\n    case \"column\":\n      dstNode = mathColumn(splitColumn(srcNode.items ?? []), create);\n      break;\n    case \"comma\":\n      dstNode = { tag: \"mo\", content: \",\", color };\n      break;\n    case \"custom\":\n      dstNode = customNode(srcNode, ctx);\n      break;\n    case \"bond\":\n      {\n        const { tx } = srcNode.bond;\n        dstNode = {\n          tag: \"mo\",\n          content: tx === \"-\" ? \"–\" : tx,\n          color,\n          attrs: { lspace: \"0\", rspace: \"0\" },\n        };\n      }\n      break;\n    case \"bracket\":\n      dstNode = { tag: \"mo\", content: srcNode.text, color };\n      break;\n    case \"brackets\":\n      dstNode = mathScripted(srcNode.items ?? [], create);\n      break;\n    case \"item\":\n      dstNode = onNodeItem(srcNode, create);\n      break;\n    case \"k\":\n      dstNode = {\n        tag: srcNode.k.isNumber() ? \"mn\" : \"mi\",\n        content: srcNode.k.toString(),\n        color,\n      };\n      break;\n    case \"mul\":\n      // Google Chrome 132.0.6834.84 dont understand &sdot; and &#x22c5;\n      dstNode = { tag: \"mo\", content: \"\\u22c5\", color };\n      break;\n    case \"op\":\n      dstNode = {\n        tag: \"mo\",\n        content: stdOp(srcNode.op.srcText, srcNode.op.dstText),\n      };\n      break;\n    case \"radical\":\n      dstNode = mathItem(srcNode.radical.label, color);\n      break;\n    case \"richText\":\n      dstNode = mathRichText(srcNode, create);\n      break;\n    case \"space\":\n      dstNode =\n        srcNode.spaceType === \"agentOp\"\n          ? undefined\n          : { tag: \"mspace\", attrs: { width: \"0.5em\" } };\n      break;\n    case \"text\":\n      dstNode = mathText(ctx, textInsideTag(srcNode.text), color);\n      break;\n    default:\n      dstNode = mathOptRow(srcNode.items ?? [], create);\n      break;\n  }\n  return dstNode;\n};\n\nexport const stdOpsDict: Record<string, string> = {\n  \"-->\": \"\\u27F6\",\n  \"--|>\": \"→\",\n  \"->\": \"→\",\n  \"®\": \"→\",\n  \"<->\": \"↔\",\n  \"<-->\": \"↔\",\n  \"<=>\": \"⇌\",\n  \"<==>\": \"\\u21CC\",\n  \"!=\": \"≠\",\n  \"<-\": \"←\",\n  \"<--\": \"\\u2190\",\n  \"<|--\": \"←\",\n};\n\nexport const stdOp = (srcText: string, dstText: string): string =>\n  stdOpsDict[srcText] ?? dstText;\n","import { XmlNode } from \"../../xmlNode/XmlNode\";\nimport { dictKeys } from \"../../buildTextNodes/dictKeys\";\nimport { TextNode } from \"../../buildTextNodes/TextNode\";\nimport { FnNodeToXml } from \"../../xmlNode/FnNodeToXml\";\nimport { mathOptRow } from \"./mathOptRow\";\nimport { ifDef } from \"../../../utils/ifDef\";\n\ntype ColDict = {\n  C?: TextNode[] | XmlNode;\n  B?: TextNode[];\n  T?: TextNode[];\n};\n\nexport const mathColumn = (\n  dict: ColDict,\n  create: FnNodeToXml\n): XmlNode | undefined => {\n  const keys = dictKeys(dict);\n  const { C = [], T, B } = dict;\n  const xC = \"tag\" in C ? C : mathOptRow(C, create);\n  if (keys === \"C\" || keys === \"\") {\n    return xC;\n  }\n  let tag = \"\";\n  const xB = ifDef(B, (it) => mathOptRow(it, create));\n  const xT = ifDef(T, (it) => mathOptRow(it, create));\n  let content: XmlNode[] = [];\n  if (xB && xT) {\n    tag = \"munderover\";\n    content = [xC, xB, xT];\n  } else if (xB) {\n    tag = \"munder\";\n    content = [xC, xB];\n  } else if (xT) {\n    tag = \"mover\";\n    content = [xC, xT];\n  }\n  if (!tag) return undefined;\n  return { tag, content };\n};\n","import { XmlNode } from \"../../xmlNode/XmlNode\";\n\nexport const mathItem = (text: string, color: string | undefined): XmlNode => {\n  const res: XmlNode = {\n    tag: \"mi\",\n    color,\n    content: text,\n  };\n  if (text.length === 1) res.attrs = { mathvariant: \"normal\" };\n  return res;\n};\n","import { XmlNode } from \"../../xmlNode/XmlNode\";\nimport { TextNode } from \"../../buildTextNodes/TextNode\";\nimport { FnNodeToXml } from \"../../xmlNode/FnNodeToXml\";\n\nexport const mathOptRow = (nodes: TextNode[], create: FnNodeToXml): XmlNode => {\n  // TODO: так как используется немного устаревшая версия TypeScript, то он не умеет правильно определять тип после filter\n  const content: XmlNode[] = nodes\n    .map(create)\n    .filter((it) => !!it) as XmlNode[];\n  if (content.length === 0) return { tag: \"mrow\" };\n  if (content.length === 1) return content[0]!;\n  return {\n    tag: \"mrow\",\n    content,\n  };\n};\n","import { TextNode } from \"../../buildTextNodes/TextNode\";\nimport { mathScripted } from \"./mathScripted\";\nimport { FnNodeToXml } from \"../../xmlNode/FnNodeToXml\";\n\nexport const mathRichText = (node: TextNode, create: FnNodeToXml) =>\n  mathScripted(node.items ?? [], create);\n","import { splitScripts } from \"../../buildTextNodes/splitScripts\";\nimport { TextNode } from \"../../buildTextNodes/TextNode\";\nimport { FnNodeToXml } from \"../../xmlNode/FnNodeToXml\";\nimport { XmlNode } from \"../../xmlNode/XmlNode\";\nimport { dictKeys } from \"../../buildTextNodes/dictKeys\";\nimport { mathOptRow } from \"./mathOptRow\";\n\nexport const mathScripted = (\n  nodes: TextNode[],\n  create: FnNodeToXml,\n  createCenter?: FnNodeToXml\n): XmlNode => {\n  const dict = splitScripts(nodes);\n  const { C = [], RT, RB, LT, LB } = dict;\n  const key = dictKeys(dict);\n  if (key === \"C\") {\n    return mathOptRow(C, create);\n  }\n  let tag = \"\";\n  let groups: (TextNode[] | string | undefined)[] = [];\n  if (RB && key === \"C,RB\") {\n    tag = \"msub\";\n    groups = [C, RB];\n  } else if (RT && key === \"C,RT\") {\n    tag = \"msup\";\n    groups = [C, RT];\n  } else if (RB && RT && key === \"C,RB,RT\") {\n    tag = \"msubsup\";\n    groups = [C, RB, RT];\n  } else {\n    tag = \"mmultiscripts\";\n    groups = [C, RB, RT, \"mprescripts\", LB, LT];\n  }\n  const content: XmlNode[] = groups.map((it, i): XmlNode => {\n    if (!it) return { tag: \"mrow\" };\n    if (typeof it === \"string\") return { tag: it };\n    const fn = i ? create : createCenter ?? create;\n    return mathOptRow(it, fn) ?? { tag: \"mrow\" };\n  });\n  return { tag, content };\n};\n","import { XmlNode } from \"../../xmlNode/XmlNode\";\nimport { CtxCreateMathMLNode } from \"../CtxCreateMathMLNode\";\nimport { mathItem } from \"./mathItem\";\n\nexport const mathText = (\n  ctx: CtxCreateMathMLNode,\n  text: string,\n  color: string | undefined\n): XmlNode => {\n  if (/^\\d+$/.test(text))\n    return {\n      tag: \"mn\",\n      content: text,\n      color,\n    };\n  if (ctx.textMode === \"custom\") return mathItem(text, color);\n  return {\n    tag: \"mtext\",\n    content: text,\n    color,\n  };\n};\n","import { splitColumn } from \"../../buildTextNodes/splitColumn\";\nimport { TextNode } from \"../../buildTextNodes/TextNode\";\nimport { FnNodeToXml } from \"../../xmlNode/FnNodeToXml\";\nimport { XmlNode } from \"../../xmlNode/XmlNode\";\nimport { mathColumn } from \"./mathColumn\";\nimport { mathScripted } from \"./mathScripted\";\n\nexport const onNodeItem = (\n  itemNode: TextNode,\n  create: FnNodeToXml\n): XmlNode | undefined => {\n  const { items } = itemNode;\n  if (!items) return undefined;\n  const colDict = splitColumn(items);\n  const { C, B, T } = colDict;\n  if (!C) return undefined;\n  const scripted = mathScripted(C, create);\n  return mathColumn({ C: scripted, B, T }, create);\n};\n","import { ifDef } from \"../../utils/ifDef\";\nimport { parseColorCss } from \"../../utils/color/parseColorCss\";\nimport { getRgbSamples } from \"../../utils/color/getRgbSamples\";\nimport { CoeffType, TextNode } from \"../buildTextNodes\";\nimport { cloneTextNode } from \"../buildTextNodes/cloneTextNode\";\nimport { optimizeColors } from \"../buildTextNodes/optimizeColors\";\nimport { splitColumn } from \"../buildTextNodes/splitColumn\";\nimport { ScriptKey, splitScripts } from \"../buildTextNodes/splitScripts\";\nimport { findNearestColor, texColors } from \"./texColors\";\nimport { replaceSpecialTeXSymbols } from \"./replaceSpecialTeXSymbols\";\n\nexport type TeXOptions = {\n  scripts?: \"optimal\" | \"braces\";\n  colors?: \"original\" | \"predefined\" | \"dvips\";\n  noMhchem?: boolean; // dont use mhchem\n  comments?: \"CharChem\" | \"TeX\"; // TeX comments can only be used if all formulas are guaranteed to be output via TeX.\n};\n\ntype CtxTeX = TeXOptions & {\n  extOp: boolean;\n};\n\nexport const buildTeX = (srcNode: TextNode, options?: TeXOptions): string => {\n  const dstNode = cloneTextNode(srcNode);\n  optimizeColors(dstNode, ({ items }) => items);\n  const res = createTexFromNode(dstNode, { ...options, extOp: false });\n  // \\ce{} is mhchem extension\n  // https://mhchem.github.io/MathJax-mhchem/\n  return options?.noMhchem ? `\\\\mathrm{${res}}` : `\\\\ce{${res}}`;\n};\n\nexport const createTexFromNode = (node: TextNode, ctx: CtxTeX): string => {\n  switch (node.type) {\n    case \"atom\":\n      return texColor(node.atom.id, node.color, ctx);\n    case \"bond\":\n      return texColor(node.bond.tx, node.color, ctx);\n    case \"bracket\":\n      return texColor(node.text.replace(/([{}])/g, \"\\\\$1\"), node.color, ctx);\n    case \"brackets\":\n      return texColor(\n        onScripted(splitScripts(node.items ?? []), node.color, ctx),\n        node.color,\n        ctx\n      );\n    case \"charge\":\n      return texColor(node.charge.text, node.color, ctx);\n    case \"column\":\n      if (node.columnType === \"op\") return onComplexOp(node, ctx);\n      return onColumn(node, node.color, ctx);\n    case \"comma\":\n      return \",\";\n    case \"comment\":\n      return applyRichText(node, node.comment.text, ctx);\n    case \"custom\":\n      return applyRichText(node, node.custom.text, ctx);\n    case \"group\":\n      return onGroup(node.items, node.color, ctx);\n    case \"item\":\n      return onItem(node, ctx);\n    case \"k\":\n      return onCoeff(node.k.toString(), node.kType, node.color, ctx);\n    case \"mul\":\n      return ctx.noMhchem ? \" \\\\cdot \" : \"*\";\n    case \"op\":\n      return stdOp(node.op.srcText, node.op.srcText, ctx);\n    case \"radical\":\n      return texColor(escapeTex(node.radical.label), node.color, ctx);\n    case \"richText\":\n      return onRichText(node, ctx);\n    case \"space\":\n      return \" \";\n    case \"text\":\n      return texColor(\n        replaceSpecialTeXSymbols(escapeTex(node.text)),\n        node.color,\n        ctx\n      );\n    default:\n      break;\n  }\n  return \"\";\n};\n\nconst onCoeff = (\n  text: string,\n  type: CoeffType,\n  color: string | undefined,\n  ctx: CtxTeX\n): string => {\n  let k = texColor(text, color, ctx);\n  if (ctx.noMhchem && type === \"agent\") {\n    k += \"\\\\,\";\n  }\n  return k;\n};\n\nexport const getTexColor = (color: string | undefined, ctx: CtxTeX): string => {\n  if (!color) return \"\";\n  let dstColor = color;\n  const inPredefined = ctx?.colors === \"predefined\";\n  if (ctx?.colors === \"dvips\" || inPredefined) {\n    const cc = parseColorCss(color);\n    if (cc) {\n      const s = getRgbSamples(cc);\n      if (s) {\n        const i = findNearestColor(s.r, s.g, s.b, inPredefined);\n        // eslint-disable-next-line prefer-destructuring\n        dstColor = texColors[i]![0];\n        if (inPredefined) dstColor = dstColor.toLowerCase();\n      }\n    }\n  }\n  return dstColor;\n};\n\nconst texColor = (text: string, color: string | undefined, ctx: CtxTeX) => {\n  const dstColor = getTexColor(color, ctx);\n  return dstColor ? `{\\\\color{${dstColor}}${text}}` : text;\n};\n\nconst onGroup = (\n  items: TextNode[] | undefined,\n  color: string | undefined,\n  ctx: CtxTeX\n): string =>\n  texColor(\n    items?.map((it) => createTexFromNode(it, ctx)).join(\"\") ?? \"\",\n    color,\n    ctx\n  );\n\ntype CmdCode = \"^\" | \"_\";\n\nconst optimizedCmd = (cmd: CmdCode, param: string, ctx: CtxTeX): string => {\n  if ((!ctx.scripts || ctx.scripts === \"optimal\") && param.length === 1) {\n    return `${cmd}${param}`;\n  }\n  return `${cmd}{${param}}`;\n};\n\nconst onScripted = (\n  s: ReturnType<typeof splitScripts>,\n  color: string | undefined,\n  ctx: CtxTeX\n): string => {\n  let res = \"\";\n  const onCmd = (cmd: CmdCode, pos: ScriptKey) => {\n    if (s[pos]) {\n      res += optimizedCmd(cmd, onGroup(s[pos], color, ctx), ctx);\n    }\n  };\n  onCmd(\"^\", \"LT\");\n  onCmd(\"_\", \"LB\");\n  res += onGroup(s.C, color, ctx);\n  onCmd(\"^\", \"RT\");\n  onCmd(\"_\", \"RB\");\n  return res;\n};\n\nconst onColumnExt = (\n  center: TextNode[] | string | undefined,\n  top: TextNode[] | string | undefined,\n  bottom: TextNode[] | string | undefined,\n  color: string | undefined,\n  ctx: CtxTeX\n) => {\n  const cvtParam = (param: TextNode[] | string) =>\n    Array.isArray(param) ? onGroup(param, color, ctx) : param;\n  const op = (\n    cmd: \"overset\" | \"underset\",\n    secondary: TextNode[] | string,\n    primary: TextNode[] | string\n  ) => `\\\\${cmd}{${cvtParam(secondary)}}{${cvtParam(primary)}}`;\n\n  const c = center ?? \"\";\n  if (top && bottom) {\n    return op(\"overset\", top, op(\"underset\", bottom, c));\n  }\n  if (top) {\n    return op(\"overset\", top, c);\n  }\n  if (bottom) {\n    return op(\"underset\", bottom, c);\n  }\n  return cvtParam(c);\n};\n\nconst onColumn = (\n  node: TextNode,\n  color: string | undefined,\n  ctx: CtxTeX\n): string => {\n  const col = splitColumn(node.items ?? []);\n  return onColumnExt(col.C, col.T, col.B, color, ctx);\n};\n\nconst onItem = (node: TextNode, ctx: CtxTeX): string => {\n  const col = splitColumn(node.items ?? []);\n  const center = onScripted(splitScripts(col.C ?? []), undefined, ctx);\n  return texColor(\n    onColumnExt(center, col.T, col.B, undefined, ctx),\n    node.color,\n    ctx\n  );\n};\n\nconst onComplexOp = (node: TextNode, ctx0: CtxTeX): string => {\n  const ctx: CtxTeX = { ...ctx0 };\n  const d = splitColumn(node.items ?? []);\n  const complex = isComplexOp(d.C);\n  const mhchem = !ctx0.noMhchem;\n  if (complex && !mhchem) ctx.extOp = true;\n  let above: string | undefined;\n  let below: string | undefined;\n  const opNode = node.items?.find(({ type }) => type === \"op\");\n  if (opNode?.type === \"op\" && ctx0.comments === \"TeX\") {\n    const { op } = opNode;\n    above = op.commentPre?.text;\n    below = op.commentPost?.text;\n  } else {\n    above = onGroup(d.T, node.color, ctx);\n    below = onGroup(d.B, node.color, ctx);\n  }\n  let res = onGroup(d.C, node.color, ctx);\n  if (mhchem) {\n    if (above || below) res += `[${above || \"\"}]`;\n    if (below) res += `[${below}]`;\n  } else if (complex) {\n    // example: \\xrightarrow[under]{over}\n    if (below) res += `[${below}]`;\n    res += `{${above || \"\"}}`;\n  }\n  return res;\n};\n\nconst applyRichText = (node: TextNode, text: string, ctx: CtxTeX): string => {\n  if (ctx.comments === \"TeX\") return replaceSpecialTeXSymbols(text);\n  return onGroup(node.items, node.color, ctx);\n};\n\nconst onRichText = (node: TextNode, ctx: CtxTeX) => {\n  const scripted = splitScripts(node.items ?? []);\n  return onScripted(scripted, node.color, ctx);\n};\n\nconst escapeTex = (text: string): string =>\n  text.replace(/\\\\/g, \"\\\\backslash \").replace(/([{}\\[\\]])/g, \"\\\\$1\");\n\nexport const mhchemOpsDict: Record<string, string> = {\n  \"-->\": \"->\",\n  \"--|>\": \"->\",\n  \"->\": \"->\",\n  \"®\": \"→\",\n  \"<->\": \"<->\",\n  \"<-->\": \"<->\",\n  \"<=>\": \"⇌\",\n  \"<==>\": \"<-->\",\n  \"!=\": \"\\\\ne\",\n  \"<-\": \"<-\",\n  \"<--\": \"<-\",\n  \"<|--\": \"<-\",\n};\n\nexport const stdOp = (\n  srcText: string,\n  dstText: string,\n  ctx: CtxTeX\n): string => {\n  if (!ctx.noMhchem) {\n    return mhchemOpsDict[srcText] ?? dstText;\n  }\n  if (ctx.extOp) {\n    const op = texComplexOps[srcText];\n    if (op) return `\\\\${op}`;\n  }\n  return ifDef(texSimpleOps[srcText], (op) => `\\\\${op}`) ?? dstText;\n};\n\nconst texSimpleOps: Record<string, string> = {\n  \"->\": \"rightarrow\",\n  \"-->\": \"longrightarrow\",\n  \"--|>\": \"longrightarrow\",\n  \"®\": \"rightarrow\",\n  \"<->\": \"leftrightarrow\",\n  \"<-->\": \"longleftrightarrow\",\n  \"<=>\": \"rightleftarrows\",\n  \"<==>\": \"rightleftarrows\",\n  \"!=\": \"ne\",\n  \"<-\": \"leftarrow\",\n  \"<--\": \"longleftarrow\",\n  \"<|--\": \"longleftarrow\",\n};\n\nconst texComplexOps: Record<string, string> = {\n  \"->\": \"xrightarrow\",\n  \"®\": \"xrightarrow\",\n  \"-->\": \"xrightarrow\",\n  \"--|>\": \"xrightarrow\",\n  \"<->\": \"xleftrightarrow\",\n  \"<-->\": \"xleftrightarrow\",\n  \"<=>\": \"xrightleftharpoons\",\n  \"<==>\": \"xrightleftharpoons\", // not supported by MathJax\n  \"<-\": \"xleftarrow\",\n  \"<--\": \"xleftarrow\",\n  \"<|--\": \"xleftarrow\",\n};\n\nconst isComplexOp = (nodes: TextNode[] | undefined): boolean => {\n  if (nodes?.length !== 1 || !nodes[0]) return false;\n  const [node] = nodes;\n  return node.type === \"op\" && !!texComplexOps[node.op.srcText];\n};\n","import { ifDef } from \"../../utils/ifDef\";\nimport { specCharsB } from \"../../compiler/parse/comment\";\n\n/**\n * Replace unicode-symbols to TeX-commands.\n * Опытным путём выявлено, что так TeX-процессоры лучше обрабатывают код.\n * Вызывать после escapeTex, т.к. после замены появятся TeX-команды.\n * @param src\n * @returns\n */\nexport const replaceSpecialTeXSymbols = (src: string): string => {\n  const { regEx, dict } = getData();\n  return src.replace(regEx, (m) => ifDef(dict[m], (c) => `\\\\${c} `) ?? m);\n};\n\nlet cacheDict: Record<string, string> | undefined;\nlet cacheRegEx = /([↑])/g;\n\nconst getData = (): {\n  dict: Record<string, string>;\n  regEx: RegExp;\n} => {\n  if (!cacheDict) {\n    const d: Record<string, string> = {\n      \"↑\": \"uparrow\",\n      \"↓\": \"downarrow\",\n      // \"°\": \"degree\", - not supported by MathJax\n    };\n    Object.entries(specCharsB).forEach(([cmd, uChar]) => {\n      d[uChar] = cmd;\n    });\n    cacheDict = d;\n    const codes = Object.keys(d).join(\"\");\n    cacheRegEx = new RegExp(`([${codes}])`, \"g\");\n  }\n  return {\n    dict: cacheDict,\n    regEx: cacheRegEx,\n  };\n};\n","// Source: https://en.wikibooks.org/wiki/LaTeX/Colors\n\n// name, red, green, blue, is predefined\ntype TexColorDef = [string, number, number, number, boolean?];\n\nexport const texColors: TexColorDef[] = [\n  [\"Apricot\", 0xfb, 0xb9, 0x82],\n  [\"Aquamarine\", 0, 0xb5, 0xbe],\n  [\"Bittersweet\", 0xc0, 0x4f, 0x17],\n  [\"Black\", 0x22, 0x1e, 0x1f, true],\n  [\"Blue\", 0x2d, 0x2f, 0x92, true],\n  [\"BlueGreen\", 0x00, 0xb3, 0xb8],\n  [\"BlueViolet\", 0x47, 0x39, 0x92],\n  [\"BrickRed\", 0xb6, 0x32, 0x1c],\n  [\"Brown\", 0x79, 0x25, 0x00, true],\n  [\"BurntOrange\", 0xf7, 0x92, 0x1d],\n  [\"CadetBlue\", 0x74, 0x72, 0x9a],\n  [\"CarnationPink\", 0xf2, 0x82, 0xb4],\n  [\"Cerulean\", 0x00, 0xa2, 0xe3],\n  [\"CornflowerBlue\", 0x41, 0xb0, 0xe4],\n  [\"Cyan\", 0x00, 0xae, 0xef, true],\n  [\"Dandelion\", 0xfd, 0xbc, 0x42],\n  [\"DarkOrchid\", 0xa4, 0x53, 0x8a],\n  [\"Emerald\", 0x00, 0xa9, 0x9d],\n  [\"ForestGreen\", 0x00, 0x9b, 0x55],\n  [\"Fuchsia\", 0x8c, 0x36, 0x8c],\n  [\"Goldenrod\", 0xff, 0xdf, 0x42],\n  [\"Gray\", 0x94, 0x96, 0x98, true],\n  [\"Green\", 0x00, 0xa6, 0x4f, true],\n  [\"GreenYellow\", 0xdf, 0xe6, 0x74],\n  [\"JungleGreen\", 0x00, 0xa9, 0x9a],\n  [\"Lavender\", 0xf4, 0x9e, 0xc4],\n  [\"LimeGreen\", 0x8d, 0xc7, 0x3e],\n  [\"Magenta\", 0xec, 0x00, 0x8c, true],\n  [\"Mahogany\", 0xa9, 0x34, 0x1f],\n  [\"Maroon\", 0xaf, 0x32, 0x35],\n  [\"Melon\", 0xf8, 0x9e, 0x7b],\n  [\"MidnightBlue\", 0x00, 0x67, 0x95],\n  [\"Mulberry\", 0xa9, 0x3c, 0x93],\n  [\"NavyBlue\", 0x00, 0x6e, 0xb8],\n  [\"OliveGreen\", 0x3c, 0x80, 0x31],\n  [\"Orange\", 0xf5, 0x81, 0x37, true],\n  [\"OrangeRed\", 0xed, 0x13, 0x5a],\n  [\"Orchid\", 0xaf, 0x72, 0xb0],\n  [\"Peach\", 0xf7, 0x96, 0x5a],\n  [\"Periwinkle\", 0x79, 0x77, 0xb8],\n  [\"PineGreen\", 0x00, 0x8b, 0x72],\n  [\"Plum\", 0x92, 0x26, 0x8f],\n  [\"ProcessBlue\", 0x00, 0xb0, 0xf0],\n  [\"Purple\", 0x99, 0x47, 0x9b, true],\n  [\"RawSienna\", 0x97, 0x40, 0x06],\n  [\"Red\", 0xed, 0x1b, 0x23, true],\n  [\"RedOrange\", 0xf2, 0x60, 0x35],\n  [\"RedViolet\", 0xa1, 0x24, 0x6b],\n  [\"Rhodamine\", 0xef, 0x55, 0x9f],\n  [\"RoyalBlue\", 0x00, 0x71, 0xbc],\n  [\"RoyalPurple\", 0x61, 0x3f, 0x99],\n  [\"RubineRed\", 0xed, 0x01, 0x7d],\n  [\"Salmon\", 0xf6, 0x92, 0x89],\n  [\"SeaGreen\", 0x3f, 0xbc, 0x9d],\n  [\"Sepia\", 0x67, 0x18, 0x00],\n  [\"SkyBlue\", 0x46, 0xc5, 0xdd],\n  [\"SpringGreen\", 0xc6, 0xdc, 0x67],\n  [\"Tan\", 0xda, 0x9d, 0x76],\n  [\"TealBlue\", 0x00, 0xae, 0xb3],\n  [\"Thistle\", 0xd8, 0x83, 0xb7],\n  [\"Turquoise\", 0x00, 0xb4, 0xce],\n  [\"Violet\", 0x58, 0x42, 0x9b, true],\n  [\"VioletRed\", 0xef, 0x58, 0xa0],\n  [\"White\", 0xff, 0xff, 0xff, true],\n  [\"WildStrawberry\", 0xee, 0x29, 0x67],\n  [\"Yellow\", 0xff, 0xf2, 0x00, true],\n  [\"YellowGreen\", 0x98, 0xcc, 0x70],\n  [\"YellowOrange\", 0xfa, 0xa2, 0x1a],\n];\n\n// TODO: здесь не все predefined colors\n\nexport const findNearestColor = (\n  red: number,\n  green: number,\n  blue: number,\n  inPredefined: boolean\n): number => {\n  let minDist = Number.MAX_SAFE_INTEGER;\n  let pos = 0;\n  for (let i = 0; i < texColors.length; i++) {\n    const [, r, g, b, predefined] = texColors[i]!;\n    if (inPredefined && !predefined) continue;\n    const dr = red - r;\n    const dg = green - g;\n    const db = blue - b;\n    const dist = dr * dr + dg * dg + db * db;\n    if (dist < minDist) {\n      pos = i;\n      minDist = dist;\n    }\n  }\n  return pos;\n};\n","import { ChemExpr } from \"../core/ChemExpr\";\nimport { compile } from \"../compiler/compile\";\nimport { ChemObj } from \"../core/ChemObj\";\nimport { OptionsHtmlRich } from \"./htmlRich/OptionsHtmlRich\";\nimport { buildTextNodes } from \"./buildTextNodes\";\nimport { buildHtmlRich } from \"./htmlRich/buildHtmlRich\";\nimport { buildTextFormat, OptionsTextFormat } from \"./text/buildTextFormat\";\nimport { buildTeX, TeXOptions } from \"./tex/buildTeX\";\nimport { MathMLOptions } from \"./mathml/MathMLOptions\";\nimport { buildMathML } from \"./mathml/buildMathML\";\nimport { renderXmlNode, renderXmlNodes } from \"./xmlNode/renderXmlNode\";\n\ntype OptionsXmlRender = {\n  indent?: string;\n};\n\ntype FmtHtmlRich = {\n  type: \"html\";\n  options?: OptionsHtmlRich & OptionsXmlRender;\n};\ntype FmtText = {\n  type: \"text\";\n  options?: OptionsTextFormat;\n};\ntype FmtTeX = {\n  type: \"TeX\";\n  options?: TeXOptions;\n};\ntype FmtMathML = {\n  type: \"MathML\";\n  options?: MathMLOptions & OptionsXmlRender;\n};\n\nexport type FmtDef = FmtHtmlRich | FmtText | FmtTeX | FmtMathML;\nexport type FmtType = FmtDef[\"type\"];\n\nexport const textTypes: readonly FmtType[] = [\"html\", \"text\", \"MathML\", \"TeX\"];\n\nexport const textFormula = (\n  objOrCode: ChemObj | string,\n  fmtOrType: FmtDef | FmtType\n): string => {\n  const chemObj =\n    typeof objOrCode === \"string\" ? compile(objOrCode) : objOrCode;\n  if (chemObj instanceof ChemExpr && !chemObj.isOk()) {\n    return chemObj.getMessage();\n  }\n  const fmt: FmtDef =\n    typeof fmtOrType === \"string\" ? { type: fmtOrType } : fmtOrType;\n  const textNode = buildTextNodes(chemObj);\n  switch (fmt.type) {\n    case \"html\": {\n      const { indent, ...htmlOptions } = fmt.options ?? {};\n      return renderXmlNodes(buildHtmlRich(textNode, htmlOptions).nodes, {\n        indent,\n        noSelfClosed: true,\n      });\n    }\n    case \"text\":\n      return buildTextFormat(textNode, fmt.options);\n    case \"TeX\":\n      return buildTeX(textNode, fmt.options);\n    case \"MathML\": {\n      const { indent, ...mmlOptions } = fmt.options ?? {};\n      return renderXmlNode(buildMathML(textNode, mmlOptions), { indent });\n    }\n    default:\n      break;\n  }\n  return \"\";\n};\n","/**\n * ASCII is used predominantly.\n * But the result is still in UNICODE.\n * Because comments and abstract elements can contain an extended set of characters.\n */\n\nimport { TextNode } from \"../buildTextNodes\";\nimport { cloneTextNode } from \"../buildTextNodes/cloneTextNode\";\nimport { optimizeColors } from \"../buildTextNodes/optimizeColors\";\nimport { splitColumn } from \"../buildTextNodes/splitColumn\";\nimport { ScriptKey, splitScripts } from \"../buildTextNodes/splitScripts\";\n\ntype OxidationPos =\n  | \"*RT\"\n  | \"RT*\"\n  | \"*RB\"\n  | \"RB*\"\n  | \"*LB\"\n  | \"LB*\"\n  | \"*LT\"\n  | \"LT*\";\ntype FnOxidation = (center: string, oxst: string) => string;\ntype FnScript = (text: string, left?: boolean) => string;\ntype FnOpComment = (text: string, where: \"above\" | \"below\") => string;\n\nexport type OptionsTextFormat = {\n  // default values are first\n  operations?: \"ascii\" | \"dstText\";\n  opComments?: \"text\" | \"ignore\" | \"quoted\" | FnOpComment;\n  sup?: \"withHat\" | \"text\" | FnScript;\n  sub?: \"text\" | \"withUnderscore\" | FnScript;\n  oxidationState?: \"ignore\" | \"sup\" | OxidationPos | FnOxidation;\n  mul?: string; // *\n  scriptDivider?: string; // \"\"\n};\n\nexport const buildTextFormat = (\n  srcNode: TextNode,\n  options?: OptionsTextFormat\n): string => {\n  const dstNode = cloneTextNode(srcNode);\n  optimizeColors(dstNode, ({ items }) => items);\n  return strNode(dstNode, options);\n};\n\nconst strNode = (srcNode: TextNode, options?: OptionsTextFormat): string => {\n  switch (srcNode.type) {\n    case \"atom\":\n      return srcNode.atom.id;\n    case \"bond\":\n      return srcNode.bond.tx;\n    case \"bracket\":\n      return srcNode.text;\n    case \"brackets\":\n      return strScripted(splitScripts(srcNode.items), undefined, options);\n    case \"charge\":\n      return srcNode.charge.text;\n    case \"column\":\n      return strExtOp(srcNode, options);\n    case \"comma\":\n      return \",\";\n    case \"comment\":\n    case \"custom\":\n    case \"group\":\n      return strItems(srcNode.items, options);\n    case \"item\":\n      return strNodeItem(srcNode, options);\n    case \"k\":\n      return srcNode.k.toString();\n    case \"mul\":\n      return options?.mul ?? \"*\";\n    case \"op\":\n      return strOp(srcNode.op.dstText, options);\n    case \"radical\":\n      return srcNode.radical.label;\n    case \"richText\":\n      return strRichText(srcNode.items, options);\n    case \"space\":\n      return \" \";\n    case \"text\":\n      return srcNode.text;\n    default:\n      break;\n  }\n  return \"\";\n};\n\nconst strItems = (\n  items: (TextNode | string)[] | undefined,\n  options?: OptionsTextFormat,\n  divider = \"\"\n): string =>\n  (items ?? [])\n    .map((node) => (typeof node === \"string\" ? node : strNode(node, options)))\n    .join(divider);\n\nconst strOp = (dstText: string, options?: OptionsTextFormat): string => {\n  const mode = options?.operations ?? \"ascii\";\n  let result: string | undefined;\n  if (mode === \"ascii\") {\n    result = opDictAscii[dstText];\n  }\n  return result ?? dstText;\n};\n\nconst opDictAscii: Record<string, string> = {\n  \"→\": \"->\",\n  \"—→\": \"->\",\n  \"↔\": \"<->\",\n  \"←→\": \"<->\",\n  \"\\u21CC\": \"<=>\",\n  \"∙\": \"*\",\n  \"≠\": \"=/=\",\n  \"←—\": \"<-\",\n  \"←\": \"<-\",\n};\n\nconst strExtOp = (\n  node: TextNode,\n  options: OptionsTextFormat | undefined\n): string => {\n  const col = splitColumn(node.items);\n  let items: (TextNode | string)[] = col.C ?? [];\n  const commMode = options?.opComments ?? \"text\";\n  const commCvt = (text: string, where: \"above\" | \"below\") => {\n    if (commMode === \"quoted\") return `\"${text}\"`;\n    if (typeof commMode === \"function\") return commMode(text, where);\n    return text;\n  };\n  if (commMode !== \"ignore\") {\n    if (col.B) {\n      const bottom = strItems(col.B, options);\n      items = [...items, commCvt(bottom, \"below\")];\n    }\n    if (col.T) {\n      const top = strItems(col.T, options);\n      items = [commCvt(top, \"above\"), ...items];\n    }\n  }\n  return strItems(items, options);\n};\n\nconst strRichText = (\n  items: TextNode[] | undefined,\n  options: OptionsTextFormat | undefined\n): string => {\n  const s = splitScripts(items);\n  const c = strItems(s.C, options);\n  return strScripted(s, c, options);\n};\n\nconst strNodeItem = (\n  srcNode: TextNode,\n  options: OptionsTextFormat | undefined\n): string => {\n  const col = splitColumn(srcNode.items ?? []);\n  const scripted = splitScripts(col.C ?? []);\n  const centerItems: (TextNode | string)[] = scripted.C ?? [];\n  const oxMode = options?.oxidationState;\n  let center: string | undefined;\n  if (col.T && oxMode) {\n    if (typeof oxMode === \"function\") {\n      const c = strItems(centerItems, options);\n      const oxst = strItems(col.T, options, options?.scriptDivider);\n      center = oxMode(c, oxst);\n    } else {\n      const oxPos = oxMode === \"sup\" ? \"*RT\" : oxMode;\n      const sPos = oxPosToScript[oxPos as OxidationPos];\n      if (sPos) {\n        const oldScr = scripted[sPos] ?? [];\n        const newScr =\n          oxPos[0] === \"*\" ? [...col.T, ...oldScr] : [...oldScr, ...col.T];\n        scripted[sPos] = newScr;\n      }\n    }\n  }\n  center = center ?? strItems(centerItems, options);\n  return strScripted(scripted, center, options);\n};\nconst oxPosToScript: Record<OxidationPos, ScriptKey> = {\n  \"*RT\": \"RT\",\n  \"RT*\": \"RT\",\n  \"*RB\": \"RB\",\n  \"RB*\": \"RB\",\n  \"*LT\": \"LT\",\n  \"LT*\": \"LT\",\n  \"*LB\": \"LB\",\n  \"LB*\": \"LB\",\n};\n\nconst strScripted = (\n  dict: ReturnType<typeof splitScripts>,\n  center: string | undefined,\n  options: OptionsTextFormat | undefined\n): string =>\n  [\n    strSup(dict.LT, options, true),\n    strSub(dict.LB, options, true),\n    center ?? strItems(dict.C, options),\n    strSub(dict.RB, options),\n    strSup(dict.RT, options),\n  ].join(\"\");\n\nconst strSup = (\n  items: TextNode[] | undefined,\n  options: OptionsTextFormat | undefined,\n  left?: boolean\n): string => {\n  let res = strItems(items, options, options?.scriptDivider);\n  if (res) {\n    const sup = options?.sup ?? \"withHat\";\n    if (sup === \"withHat\") {\n      res = `^${res}`;\n    } else if (typeof sup === \"function\") {\n      res = sup(res, left);\n    }\n  }\n  return res;\n};\n\nconst strSub = (\n  items: TextNode[] | undefined,\n  options: OptionsTextFormat | undefined,\n  left?: boolean\n): string => {\n  let res = strItems(items, options, options?.scriptDivider);\n  if (res) {\n    const sub = options?.sub;\n    if (sub === \"withUnderscore\") {\n      res = `_${res}`;\n    } else if (typeof sub === \"function\") {\n      res = sub(res, left);\n    }\n  }\n  return res;\n};\n","import { XmlNode } from \"./XmlNode\";\n\n/* eslint no-param-reassign: \"off\" */\n\nexport const addClassToXmlNode = (\n  node: XmlNode,\n  className: string | string[]\n) => {\n  const newList = (\n    typeof className === \"string\" ? className : className.join(\" \")\n  )\n    .split(\" \")\n    .filter((s) => s);\n  const oldList = new Set<string>(node.attrs?.class?.split(\" \") ?? []);\n  newList.forEach((name) => oldList.add(name));\n  node.attrs = node.attrs || {};\n  node.attrs!.class = Array.from(oldList).join(\" \");\n};\n","import { optimizeColors } from \"../buildTextNodes/optimizeColors\";\nimport { XmlNode } from \"./XmlNode\";\n\nexport const optimizeXmlColors = (node: XmlNode) =>\n  optimizeColors(node, ({ content }) =>\n    Array.isArray(content) ? content : undefined\n  );\n","import { drawTag } from \"../../utils/xml/drawTag\";\nimport { escapeXml } from \"../../utils/xml/escapeXml\";\nimport { XmlNode } from \"./XmlNode\";\n\nexport type OptionsRenderXmlNode = {\n  indent?: string;\n  noSelfClosed?: boolean;\n};\n\nexport const renderXmlNode = (\n  { tag, attrs, color, content }: XmlNode,\n  options?: OptionsRenderXmlNode,\n  level: number = 0\n) => {\n  const indent = options?.indent ?? \"\";\n  const canSelfClosed = !options?.noSelfClosed;\n  const attrsExt = color\n    ? {\n        ...attrs,\n        style: `color: ${color};`, // Предполагается, что такого атрибута нет в attrs\n      }\n    : attrs;\n  let res = \"\";\n  const addStr = (str: string, strLevel: number) => {\n    if (indent) res += indent.repeat(strLevel);\n    res += str;\n    if (indent) res += \"\\n\";\n  };\n\n  if (!content || (Array.isArray(content) && content.length === 0)) {\n    if (canSelfClosed) {\n      addStr(drawTag(tag, attrsExt, true), level);\n    } else {\n      addStr(`${drawTag(tag, attrsExt)}</${tag}>`, level);\n    }\n  } else {\n    addStr(drawTag(tag, attrsExt, !content), level);\n    if (typeof content === \"string\" && content.trim()) {\n      const xc = escapeXml(content);\n      if (xc.length > 40) {\n        addStr(xc, level + 1);\n      } else {\n        if (indent) res = res.slice(0, -1);\n        res += xc;\n        addStr(`</${tag}>`, 0);\n        return res;\n      }\n    } else if (Array.isArray(content)) {\n      content.forEach((subNode) => {\n        res += renderXmlNode(subNode, options, level + 1);\n      });\n    }\n    if (content) {\n      addStr(`</${tag}>`, level);\n    }\n  }\n  return res;\n};\n\nexport const renderXmlNodes = (\n  nodes: XmlNode[] | undefined,\n  options?: OptionsRenderXmlNode,\n  level: number = 0\n): string =>\n  (nodes ?? []).map((node) => renderXmlNode(node, options, level)).join(\"\");\n","/* eslint-disable class-methods-use-this */\nimport { ChemK } from \"../core/ChemK\";\nimport { Double, Int } from \"../types\";\nimport { strMass } from \"../math/massUtils\";\nimport { ChemCharge } from \"../core/ChemCharge\";\nimport { ChemOp } from \"../core/ChemOp\";\nimport { ChemComment } from \"../core/ChemComment\";\nimport { MarkupChunkType, markupFlat, parseMarkup } from \"../utils/markup\";\n\nexport class RulesBase {\n  agentK(k: ChemK): string {\n    return k.toString();\n  }\n\n  atom(id: string): string {\n    return id;\n  }\n\n  comma(): string {\n    return \",\";\n  }\n\n  comment(text: string): string {\n    return this.useMarkup(text);\n  }\n\n  custom(text: string): string {\n    return this.useMarkup(text);\n  }\n\n  itemCount(k: ChemK): string {\n    return k.toString();\n  }\n\n  bracketCount(k: ChemK): string {\n    return this.itemCount(k);\n  }\n\n  itemMass(mass: Double): string {\n    return strMass(mass);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  itemMassAndNum(mass: Double, number: Int | undefined): string {\n    return \"\";\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  itemCharge(charge: ChemCharge): string {\n    return \"\";\n  }\n\n  nodeCharge(charge: ChemCharge): string {\n    return charge.text;\n  }\n\n  bracketCharge(charge: ChemCharge): string {\n    return this.nodeCharge(charge);\n  }\n\n  operation(op: ChemOp): string {\n    return `${this.opComment(op.commentPre)}${op.dstText}${this.opComment(\n      op.commentPost\n    )}`;\n  }\n\n  opComment(comm?: ChemComment): string {\n    return comm ? this.useMarkup(comm.text) : \"\";\n  }\n\n  postProcess(text: string): string {\n    return text;\n  }\n\n  radical(label: string): string {\n    return label;\n  }\n\n  mul(): string {\n    return \"∙\";\n  }\n\n  mulK(k: ChemK): string {\n    return String(k);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  colorBegin(color: string): string {\n    return \"\";\n  }\n\n  colorEnd(): string {\n    return \"\";\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  markupSection(type: MarkupChunkType, isOpen: boolean): string {\n    return \"\";\n  }\n\n  useMarkup(text: string): string {\n    const topChunk = parseMarkup(text);\n    let result = \"\";\n    markupFlat(topChunk, ({ phase, chunk }) => {\n      if (typeof chunk === \"string\") {\n        result += chunk;\n      } else if (phase === \"open\" || phase === \"close\") {\n        const isOpen = phase === \"open\";\n        if (!chunk.type && chunk.color) {\n          result += isOpen ? this.colorBegin(chunk.color) : this.colorEnd();\n        } else {\n          result += this.markupSection(chunk.type, isOpen);\n        }\n      }\n    });\n    return result;\n  }\n}\n","import { RulesBase } from \"./RulesBase\";\nimport { rulesBB } from \"./rulesBB\";\nimport { rulesCharChem } from \"./rulesCharChem\";\nimport { rulesHtml } from \"./rulesHtml\";\nimport { rulesMhchem } from \"./rulesMhchem\";\nimport { rulesRTF } from \"./rulesRTF\";\nimport { rulesText } from \"./rulesText\";\n\nexport const dictTextRules: Record<string, RulesBase> = {\n  bb: rulesBB,\n  charChem: rulesCharChem,\n  html: rulesHtml,\n  mhchem: rulesMhchem,\n  rtf: rulesRTF,\n  text: rulesText,\n};\n","/* eslint-disable class-methods-use-this */\nimport { Double, Int } from \"../types\";\nimport { ChemK } from \"../core/ChemK\";\nimport { RulesBase } from \"./RulesBase\";\nimport { strMass } from \"../math/massUtils\";\nimport { ChemCharge } from \"../core/ChemCharge\";\n\n/**\n * Правила для формирования BB-кода представления формулы (для вставки в форумы)\n */\nclass RulesBB extends RulesBase {\n  agentK(k: ChemK): string {\n    return `[b]${k}[/b]`;\n  }\n\n  comment(text: string): string {\n    return `[i]${text}[/i]`;\n  }\n\n  custom(text: string): string {\n    return `[i]${text}[/i]`;\n  }\n\n  itemCount(k: ChemK): string {\n    return `[sub]${k}[/sub]`;\n  }\n\n  itemMass(mass: Double): string {\n    return `[sup]${strMass(mass)}[/sup]`;\n  }\n\n  itemMassAndNum(mass: Double, num: Int): string {\n    return `[sup]${strMass(mass)}[/sup][sub]${num}[/sub]`;\n  }\n\n  nodeCharge(charge: ChemCharge): string {\n    return `[sup]${charge.text}[/sup]`;\n  }\n\n  colorBegin(color: string): string {\n    return `[color=${color}]`;\n  }\n\n  colorEnd(): string {\n    return \"[/color]\";\n  }\n}\n\nexport const rulesBB = Object.freeze(new RulesBB());\n","/* eslint-disable class-methods-use-this */\nimport { RulesBase } from \"./RulesBase\";\nimport { Int, Double } from \"../types\";\nimport { ChemK } from \"../core/ChemK\";\nimport { strMass } from \"../math/massUtils\";\nimport { ChemCharge } from \"../core/ChemCharge\";\nimport { ChemOp } from \"../core/ChemOp\";\nimport { ChemComment } from \"../core/ChemComment\";\n\n/*\nСледует учесть, что это не полноценная система обратного преобразования выражения в текст формулы.\nЗдесь действуют те же ограничения, что и для остальных правил: формула должна быть текстовой(линейной)\n */\n\nconst exportCoeff = (k: ChemK) => (k.isNumber() ? String(k) : `'${k}'`);\n\nclass RulesCharChem extends RulesBase {\n  agentK(k: ChemK): string {\n    return exportCoeff(k);\n  }\n\n  comment(text: string): string {\n    return `\"${text}\"`;\n  }\n\n  custom(text: string): string {\n    return `{${text}}`;\n  }\n\n  itemCount(k: ChemK): string {\n    return exportCoeff(k);\n  }\n\n  itemMass(mass: Double): string {\n    return `$M(${strMass(mass)})`;\n  }\n\n  itemMassAndNum(mass: Double, num: Int): string {\n    return `$nM(${strMass(mass)},${num})`;\n  }\n\n  nodeCharge(charge: ChemCharge): string {\n    return `^${charge.text}`;\n  }\n\n  operation(op: ChemOp): string {\n    return `${this.opComment(op.commentPre)}${op.srcText}${this.opComment(\n      op.commentPost\n    )}`;\n  }\n\n  opComment(comm?: ChemComment): string {\n    return comm ? this.comment(comm.text) : \"\";\n  }\n\n  postProcess(text: string): string {\n    return text.replace(/\\$color\\(\\)\\$color/g, \"$color\");\n  }\n\n  radical(label: string): string {\n    return this.custom(label);\n  }\n\n  mul(): string {\n    return \"*\";\n  }\n\n  mulK(k: ChemK): string {\n    return exportCoeff(k);\n  }\n\n  colorBegin(color: string): string {\n    return `$color(${color})`;\n  }\n\n  colorEnd(): string {\n    return \"$color()\";\n  }\n}\n\nexport const rulesCharChem = Object.freeze(new RulesCharChem());\n","/* eslint-disable class-methods-use-this */\nimport { Double, Int } from \"../types\";\nimport { RulesBase } from \"./RulesBase\";\nimport { ChemK } from \"../core/ChemK\";\nimport { strMass } from \"../math/massUtils\";\nimport { drawTag } from \"../utils/xml/drawTag\";\nimport { escapeXml } from \"../utils/xml/escapeXml\";\nimport { ChemCharge } from \"../core/ChemCharge\";\nimport { ChemOp } from \"../core/ChemOp\";\nimport { ChemComment } from \"../core/ChemComment\";\nimport { MarkupChunkType } from \"../utils/markup\";\n\n/**\n * Правила для формирования HTML-представления формулы\n * Важно учесть, что полученная разметка предполагает использование определенных правил CSS\n * Их можно скачать тут\n *   http://charchem.org/download/charchem.css\n *\n * Различные части формулы оборачиваются специальными тегами, чтобы их было проще кастомизировать.\n * <b/> - Коэффициент агента\n * <em/> - Текстовый комментарий\n * <i/> - Абстрактные функциональные группы, н.р. {R}OH\n * <sub/> - Подстрочные коэффициенты\n * <span class=\"echem-op\"/> - Операции в химических выражениях\n */\nexport class RulesHtml extends RulesBase {\n  agentK(k: ChemK): string {\n    const attr: string = k.color ? ` style=\"color:${escapeXml(k.color)}\"` : \"\";\n    return `<b${attr}>${k}</b>`;\n  }\n\n  comment(text: string): string {\n    return `<em>${super.comment(text)}</em>`;\n  }\n\n  custom(text: string): string {\n    return `<i>${super.custom(text)}</i>`;\n  }\n\n  itemCount(k: ChemK): string {\n    return `<sub>${k}</sub>`;\n  }\n\n  itemMass(mass: Double): string {\n    return `<sup>${strMass(mass)}</sup>`;\n  }\n\n  itemMassAndNum(mass: Double, num: Int): string {\n    return `${drawTag(\"span\", { class: \"echem-mass-and-num\" })}${strMass(\n      mass\n    )}<br/>${num}</span>`;\n  }\n\n  itemCharge(charge: ChemCharge): string {\n    return `<sup class=\"echem-item-charge\">${charge.text}</sup>`;\n  }\n\n  nodeCharge(charge: ChemCharge): string {\n    return `<sup>${charge.text}</sup>`;\n  }\n\n  operation(op: ChemOp): string {\n    let result = drawTag(\"span\", { class: \"echem-op\" });\n    result += this.opComment(op.commentPre);\n    switch (op.srcText) {\n      case \"-->\":\n        result += `<span class=\"chem-long-arrow\">→</span>`;\n        break;\n      case \"<==>\":\n        result += `<span class=\"chem-long-arrow\">\\u21CC</span>`;\n        break;\n      default:\n        result += op.dstText;\n        break;\n    }\n    result += this.opComment(op.commentPost);\n    return `${result}</span>`;\n  }\n\n  opComment(comm?: ChemComment): string {\n    return comm\n      ? `<span class=\"echem-opcomment\">${this.useMarkup(comm.text)}</span>`\n      : \"\";\n  }\n\n  colorBegin(color: string): string {\n    return `<span style=\"color:${escapeXml(color)}\">`;\n  }\n\n  colorEnd(): string {\n    return \"</span>\";\n  }\n\n  override markupSection(type: MarkupChunkType, isOpen: boolean): string {\n    const tag = markupTagDict[type] ?? \"span\";\n    return isOpen ? `<${tag}>` : `</${tag}>`;\n  }\n}\n\nconst markupTagDict: Record<string, string> = {\n  sup: \"sup\",\n  sub: \"sub\",\n};\n\nexport const rulesHtml = Object.freeze(new RulesHtml());\n","/* eslint-disable class-methods-use-this */\nimport { Double, Int } from \"../types\";\nimport { ChemK } from \"../core/ChemK\";\nimport { RulesBase } from \"./RulesBase\";\nimport { strMass } from \"../math/massUtils\";\nimport { ChemCharge } from \"../core/ChemCharge\";\nimport { ChemOp } from \"../core/ChemOp\";\nimport { MarkupChunkType } from \"../utils/markup\";\n\nconst opDict: Record<string, string> = {\n  \"-->\": \"->\",\n  \"<=>\": \"<-->\",\n  \"<==>\": \"<-->\",\n};\n\n// MathJax/mhchem\n// https://mhchem.github.io/MathJax-mhchem/\n\nclass RulesMhchem extends RulesBase {\n  // Возможно, нужны разные правила для чисел, дробных чисел и абстрактных значений\n  agentK(k: ChemK) {\n    return String(k);\n  }\n\n  itemCount(k: ChemK): string {\n    return `_{${k}}`;\n  }\n\n  itemMass(mass: Double): string {\n    return `^{${strMass(mass)}}`;\n  }\n\n  itemMassAndNum(mass: Double, num: Int): string {\n    return `^{${strMass(mass)}}_{${num}}`;\n  }\n\n  nodeCharge(charge: ChemCharge): string {\n    return `^{${charge.text}}`;\n  }\n\n  operation(op: ChemOp): string {\n    let result: string = opDict[op.srcText] ?? op.srcText;\n    const t1 = op.commentPre;\n    const t2 = op.commentPost;\n    if (t1 || t2) {\n      result += `[{${t1?.text ?? \"\"}}]`;\n    }\n    if (t2) {\n      result += `[{${t2.text}}]`;\n    }\n    return result;\n  }\n\n  mul() {\n    return \"*\";\n  }\n\n  colorBegin(color: string): string {\n    return `\\\\color{${color}}{`;\n  }\n\n  colorEnd() {\n    return \"}\";\n  }\n\n  override markupSection(type: MarkupChunkType, isOpen: boolean): string {\n    const cmd = markupDict[type];\n    if (!cmd) return \"\";\n    return isOpen ? `${cmd}{` : \"}\";\n  }\n}\n\nconst markupDict: Record<string, string> = {\n  sup: \"^\",\n  sub: \"_\",\n};\n\nexport const rulesMhchem = Object.freeze(new RulesMhchem());\n","/* eslint-disable class-methods-use-this */\nimport { Char, Double, Int } from \"../types\";\nimport { RulesBase } from \"./RulesBase\";\nimport { ChemK } from \"../core/ChemK\";\nimport { strMass } from \"../math/massUtils\";\nimport { ChemCharge } from \"../core/ChemCharge\";\nimport { ChemOp } from \"../core/ChemOp\";\nimport { ifDef } from \"../utils/ifDef\";\n\n/*\nЭти правила дают не очень качественный результат.\nПока нет поддержки цветов. И некрасиво выводятся операции с подписями\n */\n\nconst specialCharacters = new Set([\n  \"'\",\n  \"*\",\n  \":\",\n  \"\\\\\",\n  \"_\",\n  \"{\",\n  \"|\",\n  \"}\",\n  \"~\",\n]);\n\nconst rtfChar = (src: Char): string => {\n  if (specialCharacters.has(src)) return `\\\\${src}`;\n  const code = src.charCodeAt(0);\n  if (code > 127) return `{\\\\cf2\\\\rtlch \\\\ltrch\\\\loch \\\\u${code}\\\\'3f}`;\n  return `${src}`;\n};\n\nconst escapeRTF = (text: string): string =>\n  Array.from(text).reduce((src, c) => src + rtfChar(c), \"\");\n\nconst subRTF = (text: string): string => `{\\\\sub ${escapeRTF(text)}}`;\nconst supRTF = (text: string): string => `{\\\\super ${escapeRTF(text)}}`;\n\nclass RulesRTF extends RulesBase {\n  agentK(k: ChemK): string {\n    return escapeRTF(String(k));\n  }\n\n  atom(id: string): string {\n    return id;\n  }\n\n  comment(text: string): string {\n    return escapeRTF(text);\n  }\n\n  custom(text: string): string {\n    return escapeRTF(text);\n  }\n\n  itemCount(k: ChemK): string {\n    return subRTF(String(k));\n  }\n\n  itemMass(mass: Double): string {\n    return supRTF(strMass(mass));\n  }\n\n  itemMassAndNum(mass: Double, num: Int): string {\n    return supRTF(strMass(mass)) + subRTF(String(num));\n  }\n\n  nodeCharge(charge: ChemCharge): string {\n    return supRTF(charge.text);\n  }\n\n  operation(op: ChemOp): string {\n    // Пока не удалось найти нормальную реализацию для размещения комментов над и под стрелкой\n    let result = \"\";\n    ifDef(op.commentPre, (it) => {\n      result += supRTF(it.text);\n    });\n    result += escapeRTF(op.dstText);\n    ifDef(op.commentPost, (it) => {\n      result += subRTF(it.text);\n    });\n    return result;\n  }\n\n  radical(label: string): string {\n    return escapeRTF(label);\n  }\n}\n\nexport const rulesRTF = Object.freeze(new RulesRTF());\n\n/*\nДля поддержки цветов нужно вставить таблицу цветов\n{\\colortbl;\\red0\\green0\\blue0;\\red255\\green0\\blue0;}\nН.р, для красного цвета: {\\cf2 this is red text}\n */\n","import { ChemCharge } from \"../core/ChemCharge\";\nimport { RulesBase } from \"./RulesBase\";\n\nexport class RulesText extends RulesBase {\n  // eslint-disable-next-line class-methods-use-this\n  nodeCharge({ isLeft, text }: ChemCharge): string {\n    return isLeft ? `${text}^` : `^${text}`;\n  }\n}\n\n/**\n * Правила для текстового представления формул.\n * Эти правила обеспечивают минимальный набор возможностей для отображения формул.\n * Например, CH3-CH2-OH\n * Для того чтобы получить больше возможностей, рекомендуется использовать другие правила.\n * Например, HTML или MathJax/mhchem.\n */\nexport const rulesText = Object.freeze(new RulesText());\n","//  LT CU RT\n//     ##\n//     ##\n\nimport { normalize360 } from \"../math/angles\";\n\n//  LB    RB\nexport type CoeffPos = \"LT\" | \"RT\" | \"LB\" | \"RB\" | \"CU\" | \"CD\";\n\nexport const rxCoeffPos = /^LT|RT|LB|RB|CU|CD$/;\n\nexport type CoeffPosOrAngle = CoeffPos | number;\n\nexport const isLeftCoeff = (pos?: CoeffPos): boolean => pos?.[0] === \"L\";\n\nexport const isLeftCoeffA = (pos?: CoeffPosOrAngle): boolean => {\n  if (typeof pos === \"number\") {\n    const angle = normalize360(pos);\n    return angle > 90 && angle < 270;\n  }\n  return isLeftCoeff(pos);\n};\n","export const addAll = <T>(container: T[], appends: readonly T[]) =>\n  appends.forEach((it) => container.push(it));\n","export const addAllSet = <T>(container: Set<T>, appends: Set<T>) =>\n  Array.from(appends).forEach((it) => container.add(it));\n","export const cmp = <T>(a: T, b: T): -1 | 0 | 1 => {\n  if (a < b) return -1;\n  if (b < a) return 1;\n  return 0;\n};\n\nexport const cmpLess =\n  <T>(less: (first: T, second: T) => boolean) =>\n  (a: T, b: T): -1 | 0 | 1 => {\n    if (less(a, b)) return -1;\n    if (less(b, a)) return 1;\n    return 0;\n  };\n","import { ColorSamples } from \"./ColorSamples\";\n\nexport const withoutSharp = (value: string): string =>\n  value[0] === \"#\" ? value.slice(1) : value;\n\nexport const isColorHex = (value: string, sharp?: boolean): boolean => {\n  if (sharp === true && value[0] !== \"#\") return false;\n  if (sharp === false && value[0] === \"#\") return false;\n  return /^#?([\\dA-F]{3,4}|[\\dA-F]{6}|[\\dA-F]{8})$/i.test(value);\n};\n\nexport const colorHexIsShort = (value: string): boolean => {\n  const { length } = withoutSharp(value);\n  return length === 3 || length === 4;\n};\n\nexport const colorHexWithAlpha = (value: string): boolean => {\n  const { length } = withoutSharp(value);\n  return length === 4 || length === 8;\n};\n\nexport const colorHexSamples = (\n  value: string | undefined\n): ColorSamples | undefined => {\n  if (!value) return undefined;\n  const pure = withoutSharp(value);\n  let chunks: string[] | undefined;\n  switch (pure.length) {\n    case 3:\n    case 4:\n      chunks = pure.split(\"\").map((c) => c + c);\n      break;\n    case 6:\n      chunks = [0, 2, 4].map((n) => pure.slice(n, n + 2));\n      break;\n    case 8:\n      chunks = [0, 2, 4, 6].map((n) => pure.slice(n, n + 2));\n      break;\n    default:\n      break;\n  }\n  if (!chunks) return undefined;\n  const samples: number[] = chunks.map((s) => parseInt(s, 16));\n  if (samples.findIndex((n) => Number.isNaN(n)) >= 0) return undefined;\n  return {\n    r: samples[0]!,\n    g: samples[1]!,\n    b: samples[2]!,\n    a: samples[3],\n  };\n};\n","/**\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/named-color\n */\nexport const colorNamesMap: Record<string, string> = {\n  aliceblue: \"#f0f8ff\",\n  antiquewhite: \"#faebd7\",\n  aqua: \"#00ffff\",\n  aquamarine: \"#7fffd4\",\n  azure: \"#f0ffff\",\n  beige: \"#f5f5dc\",\n  bisque: \"#ffe4c4\",\n  black: \"#000000\",\n  blanchedalmond: \"#ffebcd\",\n  blue: \"#0000ff\",\n  blueviolet: \"#8a2be2\",\n  brown: \"#a52a2a\",\n  burlywood: \"#deb887\",\n  cadetblue: \"#5f9ea0\",\n  chartreuse: \"#7fff00\",\n  chocolate: \"#d2691e\",\n  coral: \"#ff7f50\",\n  cornflowerblue: \"#6495ed\",\n  cornsilk: \"#fff8dc\",\n  crimson: \"#dc143c\",\n  cyan: \"#00ffff\",\n  darkblue: \"#00008b\",\n  darkcyan: \"#008b8b\",\n  darkgoldenrod: \"#b8860b\",\n  darkgray: \"#a9a9a9\",\n  darkgreen: \"#006400\",\n  darkgrey: \"#a9a9a9\",\n  darkkhaki: \"#bdb76b\",\n  darkmagenta: \"#8b008b\",\n  darkolivegreen: \"#556b2f\",\n  darkorange: \"#ff8c00\",\n  darkorchid: \"#9932cc\",\n  darkred: \"#8b0000\",\n  darksalmon: \"#e9967a\",\n  darkseagreen: \"#8fbc8f\",\n  darkslateblue: \"#483d8b\",\n  darkslategray: \"#2f4f4f\",\n  darkslategrey: \"#2f4f4f\",\n  darkturquoise: \"#00ced1\",\n  darkviolet: \"#9400d3\",\n  deeppink: \"#ff1493\",\n  deepskyblue: \"#00bfff\",\n  dimgray: \"#696969\",\n  dimgrey: \"#696969\",\n  dodgerblue: \"#1e90ff\",\n  firebrick: \"#b22222\",\n  floralwhite: \"#fffaf0\",\n  forestgreen: \"#228b22\",\n  fuchsia: \"#ff00ff\",\n  gainsboro: \"#dcdcdc\",\n  ghostwhite: \"#f8f8ff\",\n  gold: \"#ffd700\",\n  goldenrod: \"#daa520\",\n  gray: \"#808080\",\n  green: \"#008000\",\n  greenyellow: \"#adff2f\",\n  grey: \"#808080\",\n  honeydew: \"#f0fff0\",\n  hotpink: \"#ff69b4\",\n  indianred: \"#cd5c5c\",\n  indigo: \"#4b0082\",\n  ivory: \"#fffff0\",\n  khaki: \"#f0e68c\",\n  lavender: \"#e6e6fa\",\n  lavenderblush: \"#fff0f5\",\n  lawngreen: \"#7cfc00\",\n  lemonchiffon: \"#fffacd\",\n  lightblue: \"#add8e6\",\n  lightcoral: \"#f08080\",\n  lightcyan: \"#e0ffff\",\n  lightgoldenrodyellow: \"#fafad2\",\n  lightgray: \"#d3d3d3\",\n  lightgreen: \"#90ee90\",\n  lightgrey: \"#d3d3d3\",\n  lightpink: \"#ffb6c1\",\n  lightsalmon: \"#ffa07a\",\n  lightseagreen: \"#20b2aa\",\n  lightskyblue: \"#87cefa\",\n  lightslategray: \"#778899\",\n  lightslategrey: \"#778899\",\n  lightsteelblue: \"#b0c4de\",\n  lightyellow: \"#ffffe0\",\n  lime: \"#00ff00\",\n  limegreen: \"#32cd32\",\n  linen: \"#faf0e6\",\n  magenta: \"#ff00ff\",\n  maroon: \"#800000\",\n  mediumaquamarine: \"#66cdaa\",\n  mediumblue: \"#0000cd\",\n  mediumorchid: \"#ba55d3\",\n  mediumpurple: \"#9370db\",\n  mediumseagreen: \"#3cb371\",\n  mediumslateblue: \"#7b68ee\",\n  mediumspringgreen: \"#00fa9a\",\n  mediumturquoise: \"#48d1cc\",\n  mediumvioletred: \"#c71585\",\n  midnightblue: \"#191970\",\n  mintcream: \"#f5fffa\",\n  mistyrose: \"#ffe4e1\",\n  moccasin: \"#ffe4b5\",\n  navajowhite: \"#ffdead\",\n  navy: \"#000080\",\n  oldlace: \"#fdf5e6\",\n  olive: \"#808000\",\n  olivedrab: \"#6b8e23\",\n  orange: \"#ffa500\",\n  orangered: \"#ff4500\",\n  orchid: \"#da70d6\",\n  palegoldenrod: \"#eee8aa\",\n  palegreen: \"#98fb98\",\n  paleturquoise: \"#afeeee\",\n  palevioletred: \"#db7093\",\n  papayawhip: \"#ffefd5\",\n  peachpuff: \"#ffdab9\",\n  peru: \"#cd853f\",\n  pink: \"#ffc0cb\",\n  plum: \"#dda0dd\",\n  powderblue: \"#b0e0e6\",\n  purple: \"#800080\",\n  rebeccapurple: \"#663399\",\n  red: \"#ff0000\",\n  rosybrown: \"#bc8f8f\",\n  royalblue: \"#4169e1\",\n  saddlebrown: \"#8b4513\",\n  salmon: \"#fa8072\",\n  sandybrown: \"#f4a460\",\n  seagreen: \"#2e8b57\",\n  seashell: \"#fff5ee\",\n  sienna: \"#a0522d\",\n  silver: \"#c0c0c0\",\n  skyblue: \"#87ceeb\",\n  slateblue: \"#6a5acd\",\n  slategray: \"#708090\",\n  slategrey: \"#708090\",\n  snow: \"#fffafa\",\n  springgreen: \"#00ff7f\",\n  steelblue: \"#4682b4\",\n  tan: \"#d2b48c\",\n  teal: \"#008080\",\n  thistle: \"#d8bfd8\",\n  tomato: \"#ff6347\",\n  // transparent\tSee transparent.\n  turquoise: \"#40e0d0\",\n  violet: \"#ee82ee\",\n  wheat: \"#f5deb3\",\n  white: \"#ffffff\",\n  whitesmoke: \"#f5f5f5\",\n  yellow: \"#ffff00\",\n  yellowgreen: \"#9acd32\",\n};\n\nexport const findColorByName = (name: string): string | undefined =>\n  colorNamesMap[name.toLowerCase()];\n","import { ColorRgb } from \"./Color\";\n\nexport const isColorRgb = (value: string): boolean =>\n  /^rgb\\(\\s*\\d{1,3}\\s*,\\s*\\d{1,3}\\s*,\\s*\\d{1,3}\\s*\\)$/i.test(value);\n\nexport const isColorRgba = (value: string): boolean =>\n  /^rgba\\(\\s*\\d{1,3}\\s*,\\s*\\d{1,3}\\s*,\\s*\\d{1,3}\\s*,\\s*(1|0|0?\\.\\d+)\\s*\\)$/i.test(\n    value\n  );\n\nexport const colorRgbParse = (value: string): ColorRgb | undefined => {\n  const chunks = value.split(/[\\(\\),]/);\n  let srcSamples: string[] = [];\n  if (isColorRgb(value)) {\n    srcSamples = chunks.slice(1, 4);\n  } else if (isColorRgba(value)) {\n    srcSamples = chunks.slice(1, 5);\n  } else return undefined;\n  const sampleValues: number[] = srcSamples.map((s) => +s);\n  if (sampleValues.some((n) => Number.isNaN(n))) return undefined;\n  const color: ColorRgb = {\n    type: \"rgb\",\n    r: sampleValues[0]!,\n    g: sampleValues[1]!,\n    b: sampleValues[2]!,\n    a: sampleValues[3],\n  };\n  if (color.a) color.a *= 255;\n  return color;\n};\n","import { Color } from \"./Color\";\nimport { colorHexSamples } from \"./colorHex\";\nimport { findColorByName } from \"./colorNamesMap\";\nimport { ColorSamples } from \"./ColorSamples\";\nimport { traceColor } from \"./traceColor\";\n\nexport const getRgbSamples = (color: Color): ColorSamples | undefined =>\n  traceColor(color, {\n    name: (c) => colorHexSamples(findColorByName(c.name)),\n    hex: (c) => colorHexSamples(c.value),\n    rgb: ({ r, g, b, a }) => ({ r, g, b, a }),\n  });\n","import { Color } from \"./Color\";\nimport { isColorHex } from \"./colorHex\";\nimport { findColorByName } from \"./colorNamesMap\";\nimport { colorRgbParse } from \"./colorRgb\";\n\nexport const parseColorCss = (value: string | undefined): Color | undefined => {\n  if (!value) return undefined;\n  if (findColorByName(value))\n    return {\n      type: \"name\",\n      name: value,\n    };\n  if (isColorHex(value, true))\n    return {\n      type: \"hex\",\n      value,\n    };\n  return colorRgbParse(value);\n};\n","import { Color, ColorHex, ColorName, ColorRgb } from \"./Color\";\n\nexport interface ColorVisitor<Result = void> {\n  name(c: ColorName): Result;\n  hex(c: ColorHex): Result;\n  rgb(c: ColorRgb): Result;\n}\n\nexport const traceColor = <Result = void>(\n  color: Color,\n  visitor: ColorVisitor<Result>\n): Result => {\n  switch (color.type) {\n    case \"name\":\n      return visitor.name(color);\n    case \"hex\":\n      return visitor.hex(color);\n    case \"rgb\":\n      return visitor.rgb(color);\n    default:\n      break;\n  }\n  throw Error(`Invalid color = ${JSON.stringify(color)}`);\n};\n","export const delay = (ms: number): Promise<void> =>\n  new Promise<void>((resolve) => {\n    setTimeout(() => resolve(), ms);\n  });\n","export const getItemForced = <K extends string | number, V>(\n  record: Record<K, V>,\n  key: K,\n  defaultValue: V | (() => V)\n): V => {\n  const existingValue = record[key];\n  if (existingValue !== undefined) return existingValue;\n  const newValue: V =\n    // @ts-ignore\n    typeof defaultValue === \"function\" ? defaultValue() : defaultValue;\n  // eslint-disable-next-line no-param-reassign\n  record[key] = newValue;\n  return newValue;\n};\n","export const ifDef = <IN, OUT>(\n  value: IN | undefined,\n  onDef: (v: IN) => OUT\n): OUT | undefined => (value === undefined ? undefined : onDef(value));\n","export const isSubStr = (\n  text: string,\n  pos: number,\n  subStr: string\n): boolean => {\n  for (let i = 0; i < subStr.length; i++) {\n    if (text[pos + i] !== subStr[i]) return false;\n  }\n  return true;\n};\n","export const lastItem = <T>(list?: T[]): T | undefined =>\n  list ? list[list.length - 1] : undefined;\n","export const listToDict = <TValue, TKey extends string | number>(\n  list: TValue[],\n  makeKey: (v: TValue) => TKey\n): Record<TKey, TValue> =>\n  list.reduce(\n    (dict, item) => ({ ...dict, [makeKey(item)]: item }),\n    {} as Record<TKey, TValue>\n  );\n","import { isSubStr } from \"./isSubStr\";\n\n/**\n * Markup commands\n * \\color{...}\n * {\\color{...}...}\n * ^. or ^{...}\n * _. or _{...}\n */\nexport type MarkupChunkType = \"sub\" | \"sup\" | \"\";\n\nexport interface MarkupChunk {\n  type: MarkupChunkType;\n  color?: string;\n  chunks: (MarkupChunk | string)[];\n}\n\nexport const scanMarkupEnd = (\n  text: string,\n  start: number,\n  stopper: string\n): number => {\n  let level = 0;\n  let pos = start;\n  while (pos < text.length) {\n    const ch = text[pos++];\n    if (ch === stopper && level <= 0) break;\n    if (ch === \"{\") level++;\n    else if (ch === \"}\") level--;\n  }\n  return pos;\n};\n\nexport const parseMarkup = (\n  text: string,\n  topType: MarkupChunkType = \"\",\n  topColor: string | undefined = undefined\n): MarkupChunk => {\n  const chunks: (MarkupChunk | string)[] = [];\n  let pos = 0;\n  let prevPos = 0;\n  let color = topColor;\n  const updateLeftText = (lastPos: number) => {\n    if (lastPos > prevPos) {\n      const chunkText = text.slice(prevPos, lastPos);\n      chunks.push(\n        color === topColor\n          ? chunkText\n          : {\n              type: \"\",\n              color,\n              chunks: [chunkText],\n            }\n      );\n    }\n  };\n  const addChunk = (newType: MarkupChunkType) => {\n    if (pos === text.length) return;\n    updateLeftText(pos - 1);\n    const nextCh = text[pos++]!;\n    if (nextCh === \"{\") {\n      prevPos = pos;\n      pos = scanMarkupEnd(text, pos, \"}\");\n      const nested = parseMarkup(text.slice(prevPos, pos - 1), newType);\n      chunks.push(nested);\n    } else {\n      chunks.push({ type: newType, chunks: [nextCh] });\n    }\n    prevPos = pos;\n  };\n  const getColor = (start: number): string | undefined => {\n    const stop = text.indexOf(\"}\", start);\n    let newColor: string | undefined;\n    if (stop < 0) {\n      pos = start;\n      newColor = undefined;\n    } else {\n      newColor = text.slice(start, stop);\n      pos = stop + 1;\n    }\n    prevPos = pos;\n    return newColor;\n  };\n  while (pos < text.length) {\n    const ch = text[pos++];\n    if (ch === \"^\") {\n      addChunk(\"sup\");\n    } else if (ch === \"_\") {\n      addChunk(\"sub\");\n    } else if (ch === \"\\\\\" && isSubStr(text, pos, \"color{\")) {\n      // color for right text\n      updateLeftText(pos - 1);\n      const newColor = getColor(pos + 6);\n      if (newColor) color = newColor;\n    } else if (ch === \"{\" && isSubStr(text, pos, \"\\\\color{\")) {\n      // limited text\n      updateLeftText(pos - 1);\n      const newColor = getColor(pos + 7);\n      pos = scanMarkupEnd(text, pos, \"}\");\n      chunks.push(parseMarkup(text.slice(prevPos, pos - 1), \"\", newColor));\n      prevPos = pos;\n    }\n  }\n  updateLeftText(pos);\n  const res: MarkupChunk = { type: topType, chunks };\n  if (topColor) res.color = topColor;\n  return res;\n};\n\nexport interface ParamsMarkupFlat {\n  phase: \"open\" | \"close\" | \"full\";\n  chunk: MarkupChunk | string;\n  owner: MarkupChunk;\n}\nexport const markupFlat = (\n  m: MarkupChunk,\n  onChunk: (params: ParamsMarkupFlat) => void\n): void => {\n  m.chunks.forEach((chunk) => {\n    if (typeof chunk === \"string\") {\n      onChunk({ phase: \"full\", chunk, owner: m });\n    } else {\n      onChunk({ phase: \"open\", chunk, owner: m });\n      markupFlat(chunk, onChunk);\n      onChunk({ phase: \"close\", chunk, owner: m });\n    }\n  });\n};\n","export const removeItem = <T>(list: T[], item: T) => {\n  const pos = list.indexOf(item);\n  if (pos >= 0) {\n    list.splice(pos, 1);\n  }\n};\n","import { Int } from \"../types\";\n\nexport const romanNum: Record<string, Int> = {\n  i: 1,\n  ii: 2,\n  iii: 3,\n  iv: 4,\n  v: 5,\n  vi: 6,\n  vii: 7,\n  viii: 8,\n};\n","import { XmlAttrs } from \"./xmlTypes\";\nimport { escapeXml } from \"./escapeXml\";\n\nexport const drawTag = (\n  tagName: string,\n  attrs?: XmlAttrs,\n  closed?: boolean,\n  escape?: (value: string) => string\n) => {\n  let result = `<${tagName}`;\n  if (attrs) {\n    const cvt = escape ?? escapeXml;\n    Object.keys(attrs).forEach((attrName) => {\n      result += ` ${attrName}=\"${cvt(attrs[attrName]!)}\"`;\n    });\n  }\n  if (closed) result += \" /\";\n  return `${result}>`;\n};\n","const dict: Record<string, string> = {\n  \"'\": \"apos\",\n  '\"': \"quot\",\n  \"&\": \"amp\",\n  \"<\": \"lt\",\n  \">\": \"gt\",\n  \"\\u00A0\": \"nbsp\",\n};\n\nexport const escapeXml = (\n  value: string,\n  nonAscii?: (code: number) => string\n): string =>\n  Array.from(value)\n    .map((char) => {\n      if (char in dict) {\n        return `&${dict[char]};`;\n      }\n      if (!nonAscii || (char >= \" \" && char <= \"~\")) {\n        return char;\n      }\n      const esc = nonAscii(char.charCodeAt(0));\n      return esc ? `&#${esc};` : char;\n    })\n    .join(\"\");\n\nexport const hexLow = (code: number) => `x${code.toString(16)}`;\n\nexport const dec = (code: number) => String(code);\n","/**\n * If you need to keep spaces at the ends, you need to replace them with special characters.\n * Otherwise, they will be ignored during output.\n *\n * Also, you can't use names like &nbsp; here. Because they will be escaped.\n *\n * @param text\n * @returns\n */\nexport const textInsideTag = (text: string): string =>\n  text.replace(/\\s+/g, \" \").replace(/(^ )|( $)/g, \"\\u00A0\");\n","export default [2, 2, 0];","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import { addAutoCompileEvent } from \"./browser/autoCompile\";\nimport { ChemSys } from \"./ChemSys\";\nimport { PeriodicTable } from \"./core/PeriodicTable\";\n\nexport { ChemSys };\n\nif (typeof window !== \"undefined\") {\n  // @ts-ignore\n  window.ChemSys = ChemSys;\n  // deprecated. Used for compatibility with previous versions.\n  // @ts-ignore\n  window.MenTblArray = PeriodicTable.elements;\n  // @ts-ignore\n  window.MenTbl = PeriodicTable.dict;\n  addAutoCompileEvent();\n}\n"],"names":["ChemSys","Object","freeze","addDict","globalDict","Lang","ver","getVersion","verStr","getVersionStr","compile","formula","documentCompile","cfg","draw","owner","exprOrCode","config","renderFormulaCfg","makeSVG","fontPropsCache","expr","makeFormulaSvgText","makeTextFormula","objOrCode","rules","chemObj","dictTextRules","textFormula","fmtOrType","textTypesList","textTypes","makeBruttoKey","src","makeBrutto","lang","key","params","langId","tr","curLang","locale","navLang","Dict","dict","isAbstract","calcMass","applyAgentK","roundMass","mass","calcCharge","findElem","id","findElement","drawTable","drawPeriodicTable","findCategory","table","elemId","TblRules","Std","tableRulesStd","Wide","tableRulesWide","Short","tableRulesShort","EasyChemistry","tableRulesEasyChemistry","TblCategory","block","categoryBlock","blockDLa","categoryBlockDLa","props","categoryProps","drawTag","tag","attrs","content","undefined","escapeXml","String","esc","equalize","equation","eq","ChemEquation","initBySrc","solve","isSolved","getExpr","ChemExpr","createWithError","makeError","DrawSysIds","svg","canvas","addClass","elem","className","classList","add","cls","getAttribute","clsList","split","clsSet","Set","setAttribute","Array","from","join","WebFontCache","autoCompile","document","nodes","querySelectorAll","length","cfgNode","drawSys","drawSysId","toLowerCase","useText","useTextLow","nonText","addAutoCompileEvent","window","addEventListener","Promise","reject","Error","selector","formulaSelector","list","i","elementCompile","delay","e","resolve","code","textContent","innerText","renderFormulaCanvas","innerHTML","createElement","append","surface","HtmlCanvasSurface","createBrowserChemImgProps","renderTopFrame","buildFrame","isOk","getMessage","isTextFormula","renderFormulaSvg","src0","trim","SvgWebSurface","frame","bounds","exportText","width","height","tmp","body","standaloneExportOptions","remove","baseChainId","baseSubChainId","constructor","compiler","chainsDict","subChainsDict","curChainId","curSubChainId","stack","this","getLastBond","lastBond","onBranchBegin","unshift","onBranchEnd","shift","createChain","newChainId","getCurChain","createSubChain","newId","getCurSubChain","addNode","node","chain","push","subChain","setCurNode","addBond","bond","soft","mergeSubChains","dstId","srcId","step","forEach","it","pt","iadd","dstNodes","mergeChains","srcNode","dstNode","srcChainId","dstChainId","curAgent","filter","makeTransitionBond","dir","node1","bondToRef","srcSubChain","dstSubChain","minus","curNode","changeBondToHard","Point","closeChain","closeSubChain","findNode","find","equals","ChemCompiler","srcText","options","text","pos","curState","stateBegin","curPart","elementStartPos","chainSys","ChainSys","references","mulCounter","MulCounter","varsDict","curWidth","nodesBranch","NodesBranch","bracketsCtrl","BracketsCtrl","middlePoints","altFlag","varSlope","varLength","varPadding","centralNode","varDots","varPos","srcMap","item","pop","setAltFlag","getAltFlag","value","eject","v","curChar","nextChar","subStr","startPos","slice","isFinish","isCurPosEq","Math","min","error","msgId","newParams","ChemError","setState","newState","deltaPos","addSrcMapItem","obj","begin","part","end","createTestCompiler","prepareText","closeEntity","funcBackground","args","background","commands","ChemBackground","parseBackgroundArgs","shapeNames","arg","curPos","argt","isAll","divPos","indexOf","has","shape","fill","val","valPos","parseNodes","stroke","strokeWidth","parseNum","padding","parsePadding","borderRadius","nodesList","chunks","map","nodeDef","findNodeEx","funcC","funcColor","varColor","funcItemColor","varItemColor","funcItemColor1","varItemColor1","funcAtomColor","varAtomColor","funcAtomColor1","varAtomColor1","aligns","r","R","l","L","m","M","funcDblAlign","varAlign","rxCompact","splitDotPositions","descr","result","isRev","check2","match","n","checkEx","m1","n1","m2","n2","c","revSet","reduce","acc","delete","parseSingleDotArg","startsWith","cmd","color","margin","test","dirs","num","parseDotsArgs","dots","res","addPos","dotPos","angle","funcDots","funcL","funcM","varMass","funcPadding","funcPos","rxCoeffPos","funcSlope","toIntOrZero","s","parseVerParameter","a","b","verList","ifDef","v1","v2","verList2","funcVer","high","low","currentVersion","cur","need","funcnM","varAtomNumber","cvt","Number","isNaN","funcsDict","atomColor","atomColor1","bg","C","dblAlign","itemColor","itemColor1","nM","slope","queue","clear","onNode","onBracket","bracketCounter","onOpenBracket","mul","onCloseBracket","close","create","newMul","getMulForBracket","getMulForced","nbStack","copy","svNodes","onSubChain","addNodeItem","subObj","closeItem","ChemNodeItem","getItemColor","getAtomColor","atomNum","bCenter","getNodeForced","items","createAgent","preComm","agent","ChemAgent","onCreateEntity","entityBegin","curBond","openNode","closeNode","onCloseAgent","checkMul","checkMiddlePoints","checkBranch","finalUpdateBondsForNodes","finalUpdateAutoNodes","bonds","index","agentMode","star","closeBranch","startMul","scanCoeff","ChemK","stateAgentMid","walk","nodePre","autoMode","updateAutoNode","agentAnalyse","onDefault","pos0","scanSimpleBond","createSimpleBond","stateElement","stateCustom","stateCommentIn","stateAgentSpace","createLabel","stateNodeRef","stateCharge","stateFuncName","openBranch","openParentheses","openSquareBracket","closeBracketShort","comma","stateUniBond","instChemComma","horizAngles","correct","makeBondStep","isNeg","newAngleDeg","isCorr","calcPt","correctPrev","prevBond","fixed","corrNode","oldPos","reverse","autoCorrection","slopeSign","isAuto","is0","y","isHorizontal","createCommonBond","ChemBond","bindNodeToBond","chemBond","node0","auto0","isZero","plus","bindNodeToCurrentBond","findBondBetweenNodes","nodeA","nodeB","getNodeForBondStart","lastCmd","lastItem","bracketEnd","ChemBracketEnd","nodeIn","onOpenBond","oldNode","applyMiddlePoints","align","mergeBonds","oldBond","newBond","newNode","nbn0","nbn1","removeItem","createPolygonalBond","beginPos","mode","multiplicity","sign","strCount","isDigit","count","createPolygonStep","scanBondSuffix","tx","findRingNodes","nodesFull","j","lastIndexOf","findRingNodesEx","createRingBond","ext","isCycle","angleDegree","pointFromDeg","times","BondDef","bondId","calcDir","isText","soft1","soft3","bondDefDict","bondDef","curBondId","curBondDef","nodesInterval","refs","first","last","max","parseNodesListDef","valuePos","srcList","chunk","dstList","createSplineBond","argPos","scanArgs","makeParamsDict","setBondProperties","param","checkCycledList","autoLocateNodes","paramsList","substring","listToDict","calcPolygonDir","prevDir","pointFromRad","polarAngle","PI","defaultLength","parseRefsList","ref","paramPos","points","midPt","sum","vec","parseAxisCoordinate","isX","center","x","calcBondDirection","getLength","fromAngle","p","P","aParam","rad2deg","A","doubleBondSuffizes","parseBondMultiplicity","getMode","setCross","styleSuffixes","parseStyle","style","N","h","connection","T","setHydrogen","arr0","arr1","S","isGlobal","w","d","W","D","second","makePair","w0","w1","setWidth","createUniversalBond","BracketDecl","StackItem","super","msgInvalidClose","openBracket","stateBracketBegin","openBrace","ChemBracketBegin","bracketPairs","getNodeForBracketEnd","ChemMulEnd","closeBracket","decl","needCloseText","must","have","checkMulBeforeBracket","chargeOwner","ch","scanPostItem","BranchDecl","OpDef","dst","div","opCode","opsList","onCloseOp","curOp","createChemOp","def","op","ChemOp","commentPre","scanId","entity","curEntity","entities","elemNode","getLastItem","bondPoints","createMiddlePoint","k","isFirst","ChemMul","stopMul","existsNode","softBond","testDir","ChemNode","createBackground","PeriodicTable","multipleSum","countH","charge","round","H","createComment","scanComment","convertComment","ChemComment","scanTo","replaceLimited","firstLimiter","lastLimiter","transform","endPos","specChars","replace","replaceGreek","findPhrase","specCharsB","alpha","Alpha","beta","Beta","gamma","Gamma","delta","Delta","epsilon","Epsilon","zeta","Zeta","eta","Eta","theta","Theta","iota","Iota","kappa","Kappa","lambda","Lambda","mu","Mu","nu","Nu","xi","Xi","omicron","Omicron","pi","Pi","rho","Rho","sigma","Sigma","tau","Tau","upsilon","Upsilon","phi","Phi","chi","Chi","psi","Psi","omega","Omega","isSpace","numConstDict","$32","sqrt","$3","$3x2","$2","$22","$2x2","parseNumConst","invalidNumber","srcValue","name","useVariable","declareVariable","parseVariable","parseNumExt","values","mainPreProcess","scan","isValid","fin","p0","prev","level","addArg","bondSuffixes","rec","suffix","action","scanCharge","coeffPos","prevCharge","createCharge","getCoeffPos","isIdFirstChar","isIdChar","isId","scanInt","scanOp","nextPos","onCoeff","skipSpaces","globalMacros","PreProcCtx","aSrc","aPos","msg","errPos","errorPar","start","search","cond","stop","searchEx","write","writeFinish","bodyPreprocess","ctx","plain","defMacro","macro","Macros","applyParamValues","names","curIndex","paramValue","ready","exl","f","readRealParams","p1","scanPar","execMacros","ctx0","readFormalPars","ctx1","realParams","dummyBody","lock","isComment","getSrcItemsForObject","needObj","stateAgent","stateAgentBegin","coeff","stateAgentIn","stateCommentPre","opDef","stateOpEnd","isLeft","preCommPos","scanMarkupEnd","ChemRadical","ChemCustom","Elem","statePostItem","func","onReferenceError","bondNodesKey","useRef","curKey","useRefByNumber","atom","isAtomNode","useRefByAtom","useRefById","commentPost","bracketPos","ChemObj","stA","StructAnalyzer","setCoeff","visitor","agentPre","isStop","agentPost","ChemAtom","ChemSubObj","stable","epsilonMass","floor","brk","other","isCross","checkText","abs","linearText","debugText","polarAngleDeg","toFixed","toa","isVisible","isVerticalConnection","isNodeHidden","bracketBegin","getBracketsContent","ChemCharge","isLeftCoeffA","isRound","leftSigned","rightSigned","minuses","pluses","chargeDescr","romanNum","toUpperCase","ChemComma","comment","custom","getErrorMessage","err","oldLang","message","entityPre","entityPost","getAgents","findMapItems","target","srcMapItemText","applyK","html","rulesHtml","isLinear","NaN","isSpecified","isNumber","isInt","toString","one","mulEnd","zero","clone","nodePost","getCenterItem","curPriority","maxPriority","foundItem","itemPre","radical","itemPost","walkExt","dstText","operation","radicals","descriptions","label","newDict","left","right","elemList","ElemList","addElemById","elemRec","chargeText","makeChargeText","findAtom","findById","findCustom","findKey","findRec","addElemRec","foundRec","ElemRecord","addAtom","addElem","addCustom","addList","addRadical","scale","sortByHill","sort","aid","bid","localeCompare","isCustom","k2s","elementsCache","dictCache","isotopesCache","isotopeDictCache","isotopesDict","elements","keys","massMap","finalMap","isotopes","isotopesDef","He","Li","Be","B","O","F","Ne","Na","Mg","Al","Si","Cl","Ar","K","Ca","Sc","Ti","V","Cr","Mn","Fe","Co","Ni","Cu","Zn","Ga","Ge","As","Se","Br","Kr","Rb","Sr","Y","Zr","Nb","Mo","Tc","Ru","Rh","Pd","Ag","Cd","In","Sn","Sb","Te","I","Xe","Cs","Ba","La","Ce","Pr","Nd","Pm","Sm","Eu","Gd","Tb","Dy","Ho","Er","Tm","Yb","Lu","Hf","Ta","Re","Os","Ir","Pt","Au","Hg","Tl","Pb","Bi","Po","At","Rn","Fr","Ra","Ac","Th","Pa","U","Np","Pu","Am","Cm","Bk","Cf","Es","Fm","Md","No","Lr","Rf","Db","Sg","Bh","Hs","Mt","Ds","Rg","Cn","Nh","Fl","Mc","Lv","Ts","Og","getCycleCenter","cy","vectorSign","q","calcBondSign","cycle","bondSideSign","side","nearBonds","isInit","cycles","bondsMap","analyze","NA","nodesMap","order","unwindCycle","usedNodes","nodesSet","curND","nextNode","nextND","cmp","createCycle","cyBonds","nextOrder","getItemForced","findCyclesForBond","c0","sFwd","sBkw","isEmptyNode","isTextBrackets","isTextBracketsCached","absCharge","stdStyle","line","hline","styles","thickWidth","chiralWidth","lineSpace2","lineSpace2x","lineSpace3","subKY","bracketSubKY","supKY","bracketSupKY","hatch","dash","arrowL","arrowD","opSpace","agentKSpace","mulChar","mulRadius","kw","flDblAlign","nodeMargin","bracketWidth","bracketSpace","useTextBrackets","electronDotD","horizLine","lineWidth","init","me","getFontHeight","font","getFontFace","ceil","getTextWidth","getStyle","styleName","getStyleColored","getIndexStyles","context","fontFace","textLine","canvasFont","measureText","drawLine","org","fillStyle","fillText","getCanvas","domElement","getCtx","htmlContext","fontCache","getContext","size","getFont","webProps","getWebProps","hash","HtmlCanvasLocalFont","applyStyle","translate","Matrix2x3","beginPath","strokeStyle","drawPath","segments","save","onM","moveTo","onL","lineTo","onQ","cp","quadraticCurveTo","onC","cp1","cp2","bezierCurveTo","onA","xRot","largeArc","sweep","tracePath","restore","drawEllipse","offset","radius","ellipse","setSize","SvgWebLocalFont","webFontProps","createScaled","newProps","cssHeight","scaleFontFace","makeCanvasFontProp","bold","italic","fontFamily","addFigure","SvgSurface","svgLocFont","cache","createLocalFontHash","makeWebFontProps","fontStyleChunks","family","fontWeight","webFontWeight","weight","vOffset","testHeight","testWidth","baseline","isBold","textBaseline","mZ","mz","trace","letter","toBottom","clearRect","info","getImageData","traceBox","data","xHeight","actualBoundingBoxAscent","capHeight","ascent","descent","actualBoundingBoxDescent","bbox","fontBoundingBoxDescent","fontBoundingBoxAscent","fontStyle","pixels","finish","best","fontWeightValue","rulesList","doc","findComputedStyle","defaultView","getComputedStyle","element","currentStyle","span","createStyle","htmlCode","firstChild","Element","cssStyle","fontProps","fontSize","stretch","fontStretch","appendChild","ChemImgProps","createRulesList","curStyle","FigBSpline","Figure","segmentLength","bDashed","update","rect","updateRect","Rect","segs","bCycled","sumLen","edgesLen","len","dist","nSegs","curEdge","newEdge","a3","a2","a1","a0","edgeK","isub","t","extendsPoints","srcPoints","bCyclic","preLast","dstPoints","newLast","firstStep","lastStep","FigEllipse","neg","FigFrame","figures","fig","updateFigure","insertFigure","splice","unite","getRelativeBounds","figBounds","FigHashTrapezoid","aWidth","bWidth","dL","dR","calcTrapezoidDir","aL","aR","bL","bR","calcTrapezoidPoints","updatePoint","makeHashTrapezoidPath","dirLen","dir1","transpon","aw2","bw2","srcWidth","dstWidth","minW","dW","hatchLen","desiredStep","stripCount","dStep","t1","w2","p0L","p0R","p1L","p1R","FigPath","rc","grow","createLine","FigRect","drawRect","FigText","ff","baseLine","getBaseline","move","desiredRect","drawTriple","leftTop","leftMid","leftBottom","closeBrace","rightTop","rightMid","rightBottom","top","mid","bot","topConn","botConn","topCa","topCb","midCa","midCb","midCc","botCc","build","setPt","mini","maxi","kx","ky","set","scalePath","drawRubberFigure","rubberFig","imgProps","closeSquareBracket","getRubberBracket","isOpen","sWidth","sHeight","sThickH","sThickV","pathAttrs","cap","repr","defs","path","pathToString","rx","ry","cx","xmlCode","addDef","buildSvgText","xml","version","encoding","standalone","doctype","xmlns","baseProfile","rootAttrs","viewBox","excludeVerInfo","defsList","agentK","itemCount","itemMass","nodeCharge","bracketCharge","bracketCount","used","styleId","seg","dstSeg","rel","addPoint","cpPrev","getPoint","calcCP","onZ","curPoint","onH","onV","dstPoint","dictReady","newSolveItem","dstCol","state","agents","nCols","solves","equationDict","getSolves","initByExpr","isSuitableForEquation","parts","makeElemList","leftPart","rightPart","elemRes","checkElementsMatching","Rational","elemIndex","col","row","getMatrix","getMatrixStr","calcStep","simpleSolve","nRow","findRowForAction","onSimpleSolve","deleteMatrixRow","try2RowsUnit","searchKoeffs","rowIndex","k0Index","k1Index","srcRow","negx","divi","solveItem","srcCol","addi","mulx","findIndex","filledNdx","col0","col1","getUnknownIndices","calcSolves","optimizeKoeffs","checkKoeffs","checkBalance","finalSolve","numCoeffs","newSrc","makeSourceWithNewCoeffs","found","notFound","si","comm","nod","calcAbsMCD","ki","maxX","balance","it0","it1","colNdx","row0","row1","mul0","mul1","sitem","subi","unknownIndices","gen","makeCoeffEnumerator","vars","testKoeffs","unknownIndexes","variants","uIndex","partId","E","coeffEnumerator2d","x0","y0","coeffEnumerator3d","z","z0","coeffEnumeratorNd","dimension","maxLevel","maxMask","mask","subLevelNdx","sn","subVals","dimesion","ru","en","msgAbs","reason","coeffs","oldSrc","prevPos","agentIndex","agentItems","itemsCount","leftPos","calc","listItem","IsAbstractVisitor","isAbstractCoeffs","isAbsK","useItems","locateAtomNumber","ignoreAgentK","l2r","rulesText","ctxOut","space","isLtr","drawCharge","isPrefix","autoNode","rawAtomNum","itemMassAndNum","itemCharge","mulK","nonOptimized","buildTextFromChunks","postProcess","chunkItem","needOpen","needClose","colorBegin","colorEnd","makeTextFormulaSrc","sourceText","curDict","enDict","replaceLangParams","globalDictUpdates","entries","locDict","ruDict","baseDictRu","baseDictEn","navigator","language","browserLanguage","userLanguage","loc","$Native","$English","Group","Period","Row","Lanthanides","Actinides","Metalloids","Halogens","fnParams","getValue","endsWith","divider","createIdentity","createZero","moveX","moveY","scaleX","scaleY","rotate","radians","cosA","cos","sinA","sin","rotateDeg","degrees","deg2rad","apply","deltaX","deltaY","atan2","lengthSqr","distSqr","normal","ccw","staticZero","absLess","absx","norm","addx","subx","muli","divx","bx","by","bottom","isEmpty","moveXY","contains","realDeltaY","clip","x1","y1","x2","y2","makeOutcodes","mkMask","ocu1","ocu2","inside","outside","isSwap","isMask","p2","srcRect","normalize360","degAngle","isClose","strMass","angleInRadians","angleInDegrees","getNodeCenterPos","nodeInfo","nodeFrame","getNodeInfo","nodesInfo","applyPadding","pads","dx","clipLine","ptInside","ptOutside","clipLineByNode","nodeRes","rcNodeCore","isPadding","doubleBond","d1","styleL","styleR","left1","right1","wL","getBondStyleWidth","wR","aSign","getAlignSign","singleLine","drawBezierBond","res0","res1","rect0","rect1","c1","wPoints","vpt","wpt","getBondColor","drawBondArrow","drawBond","drawBondPoly","bondA","bondB","drawBondAB","wedgeBond","stList","tripleBond","cL","calcCenter","bPoints","styleDef","lnStyle","drawWaveLine","drawDashedLine","srcSpace","dstSpace","ampl","arrLen","wp0","wp1","vAmp","segDir","segLen","softBondTemplate","vDir","field","styleLeft","styleCenter","styleRight","wC","left0","right0","canPush","postExec","onPrevious","AgentCmdBrClose","AgentCmd","srcCmd","isCanUnwindNext","unwind","AgentCmdBrOpen","processBrackets","isBridge","checkRtl","rtlNode","rtlNodes","endNode","AgentCmdBridge","dstCmd","beginNode","prevBracket","AgentCmdNode","prevText","nodeBond","createAgentCmdMul","AgentCmdMul","AgentCmdMulBridge","ni","cluster","clusters","findByNode","figK","createCoeff","figure","isPrevBox","isNextBox","bridgeFrame","mFont","mStyle","mFields","figMul","drawMul","srcConn","allBox","yBase","yMiddle","br","n0","ni0","isBothText","isRealText","makeBridge","AgentCmdSoftBond","dstConn","srcNodeInfo","dstNodeInfo","srcBase","srcH","dstH","connPt","insertToCluster","getClusterBoxConnection","getClusterConnection","rcNode","calcOffset","isBothBaseline","calcOffsetAbs","mergeClusters","srcCluster","dstCluster","addAllSet","findByIndex","nodeIndex","clusterIndex","cl","bAbs","dstPos","leftToRight","uniteRest","cmdStack","Clusters","backs","agentFrame","bracketCoeffs","type","drawTextNear","rcCore","drawBracket","bracket","contentRect","figText","getTextInternalRect","textBracket","rubberBracket","isSrcBracket","dy","flAbs","b0","b1","cmdOpen","cmdClose","beginNi","endNi","isText0","contentRect0","rcRel","calcBracketRect","contentRect1","xPad","open","isLeftCoeff","figOpen","figClose","buildAgentPrior","PAgentCtx","prepareNodes","processCommands","drawAllBonds","drawBackground","findAgentCenter","kStyle","irc","createAgentCmd","calcBgRect","makeBackFigure","r0","srcNodes","maxSqr","cc","calcRadius","calcAB","createBgEllipse","createBgRect","calcExplicitCenter","findExplicitlyCentred","monoCycle","findDefaultCenter","allNodesInfo","expNodesInfo","centers","findDefaultY","maxCount","buildNode","previousCmd","canPop","head","buildExpression","einfo","opFrame","buildOp","buildItem","itemFrame","itemFont","onText","txFig","drawText","onMarkup","textWithMarkup","figM","drawTextWithMarkup","drawIndex","atomNumber","pr","drawLewisShell","dotColor","figDot","centerItem","comms","buildOpComment","commWidth","com","drawFn","opDict","opTextFigure","figOp","addOpComment","makeStrokeStyle","opLongArrow","isFilledArrow","minWidth","lineLen","figLine","tri","triStyle","figArrow","opLongLeftArrow","triLeft","figArrowLeft","triRight","figArrowRight","opRect","isTop","tp","figTxt","drawSpecialCharge","lw","maxY","lw2","figCharge","figR","rcFig","moveNearFigure","calcPos","onDot","rcCur","pExt","fn","getShiftCoeff","makeRectExt","rcCoreExt","sp","figFF","drawMarkup","xSup","xSub","updateX","subChunk","isSup","newFont","rsFig","dY","newStyle","stdH","subH","parseMarkup","class","fieldsDict","number","stdOut","fields","tables","NCol","NRow","category","hardNotes","tblN","drawGroups","fallingNumbers","groupIds","groupCls","tableCls","elementBoxCls","periodCols","groupRows","flLanAct","notes","categoryExt","subGroup","cells","actualTables","tdef","t0","rowspan","colspan","drawPeriods","post","flGroups","flPeriods","pre","ofsX","ofsY","cellFields","cellRender","CellRender","srcItem","h1","grpMaps","curCat","catDict","catName","catValues","isArray","catValue","G","gm","grp","LanActMap","curTable","beginTable","X","GrpCache","Map","revMap","categoryKey","pkList","curCategory","cat","get","s_block","p_block","d_block","f_block","f2_block","subgr_a","subgr_b","addItemProps","addItem","kType","atomMass","buildTextNodes","srcExpr","rootNode","groupType","addItemTo","pushLevel","pushGroupLevel","popLevel","prevEntity","firstItem","addSpace","curEntityType","spaceType","correctBondsDirection","splitRichText","itemNode","createTextOp","cloneTextNode","groupNode","some","opItem","colItem","columnType","dictKeys","optimizeColors","getList","nodeColor","subColors","aColors","splitColumn","textColor","onChunk","locColor","groupScripted","ungrouped","grouped","optimized","group","scriptKeys","LT","RT","LB","RB","splitScripts","htmlRichCls","clsCode","buildHtmlRich","createHtmlRichNodes","cchOperation","arrow","cchArrowTag","arrows","makeCchTag","longRightArrow","longLeftArrow","bothArrowsLeft","bothArrowsRight","preserveAspectRatio","textTag","bondMap","makeScripted","makeCharge","makeComplexOp","makeRichText","makeGroup","makeItem","textInsideTag","flatMap","hasOver","optionalGroup","addClassToXmlNode","makeColumn","makeCenter","scr","addScripts","addAll","colItems","includes","splitChargeText","opComment","opContainer","setAttr","idGen","txtNode","mathMLRootAttrs","ns","namespace","buildMathML","createMathMLNode","optimizeXmlColors","mathItem","mathText","textMode","mathColumn","customCtx","mathOptRow","customNode","lspace","rspace","mathScripted","onNodeItem","stdOp","mathRichText","stdOpsDict","xC","xB","xT","mathvariant","createCenter","groups","colDict","scripted","buildTeX","createTexFromNode","extOp","noMhchem","texColor","onScripted","onComplexOp","onColumn","applyRichText","onGroup","onItem","escapeTex","onRichText","replaceSpecialTeXSymbols","getTexColor","dstColor","inPredefined","colors","parseColorCss","getRgbSamples","findNearestColor","g","texColors","onCmd","scripts","optimizedCmd","onColumnExt","cvtParam","secondary","primary","complex","isComplexOp","mhchem","above","below","opNode","comments","mhchemOpsDict","texComplexOps","texSimpleOps","cacheDict","regEx","getData","cacheRegEx","uChar","codes","RegExp","red","green","blue","minDist","MAX_SAFE_INTEGER","predefined","dr","dg","db","fmt","textNode","indent","htmlOptions","renderXmlNodes","noSelfClosed","buildTextFormat","mmlOptions","renderXmlNode","strNode","strScripted","strExtOp","strItems","strNodeItem","strOp","strRichText","operations","opDictAscii","commMode","opComments","commCvt","where","centerItems","oxMode","oxidationState","scriptDivider","oxPos","sPos","oxPosToScript","oldScr","newScr","strSup","strSub","sup","sub","newList","oldList","canSelfClosed","attrsExt","addStr","str","strLevel","repeat","xc","subNode","useMarkup","markupSection","topChunk","markupFlat","phase","bb","rulesBB","charChem","rulesCharChem","rulesMhchem","rtf","rulesRTF","RulesBB","RulesBase","exportCoeff","RulesCharChem","RulesHtml","markupTagDict","RulesMhchem","t2","markupDict","specialCharacters","escapeRTF","charCodeAt","rtfChar","subRTF","supRTF","RulesRTF","RulesText","container","appends","cmpLess","less","withoutSharp","isColorHex","sharp","colorHexIsShort","colorHexWithAlpha","colorHexSamples","pure","samples","parseInt","colorNamesMap","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","findColorByName","isColorRgb","isColorRgba","colorRgbParse","srcSamples","sampleValues","traceColor","hex","rgb","JSON","stringify","ms","setTimeout","record","defaultValue","existingValue","newValue","onDef","isSubStr","makeKey","stopper","topType","topColor","updateLeftText","lastPos","chunkText","addChunk","newType","nextCh","nested","getColor","newColor","ii","iii","iv","vi","vii","viii","tagName","closed","escape","attrName","nonAscii","char","hexLow","dec","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","call","MenTblArray","MenTbl"],"sourceRoot":""}